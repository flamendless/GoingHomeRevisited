local Concord = require("modules.concord.concord")
local Flux = require("modules.flux.flux")
local Gamera = require("modules.gamera.gamera")
local Log = require("modules.log.log")
local Slab = require("modules.slab")
local Timer = require("modules.hump.timer")

local ECS = require("ecs")
local Canvas = require("canvas")
local Resources = require("resources")
local Dissolve = require("dissolve")
local Fade = require("fade")
local Image = require("image")
local Inputs = require("inputs")
local MotionBlur = require("motion_blur")
local Palette = require("palette")
local Preloader = require("preloader")
local Save = require("save")

local max = math.max
local min = math.min
local format = string.format
local lower = string.lower
local gsub = string.gsub
local insert = table.insert

local StateMenu = class()
StateMenu.id = "Menu"

local resources = {images = {}, sources = {}, fonts = {}}
local res_images, res_fonts

function StateMenu:new()
	return self:init({
		camera = nil,
		world = Concord.world(),
		entities = {},
		canvases = {},
		is_ready = false,
		gamestate = nil,
	})
end

function StateMenu:start()
	ECS.load_systems(self.id, self.world)
	self.world.state = self

	local ww, wh = love.graphics.getDimensions()
	local img_ff = Image.resize_image(res_images.flowfield)

	self.camera = Gamera.new(0, 0, ww * 2, wh * 2)
	self.camera:setWindow(0, 0, ww, wh)
	Canvas.init_canvases(self.canvases)
	self.mb_main = MotionBlur:new(self.canvases.main_canvas)
	self.dissolve_ff = Dissolve:new(img_ff, 2)

	self.world:emit("init_menu", self.camera, self.mb_main, self.dissolve_ff)
	self:setup_menu()
	self.world:emit("hide_main_menu", 0.1)
	self.world:emit("hide_sub_menu", 0.1)

	Fade.set_color({0, 0, 0, 1})
	Fade.fade_in(function()
		self.world:emit("allow_cursor", true)
		self.world:emit("set_cursor", 1)
		self.entities.subtitle:remove("anchor")
		self.world:emit("show_main_menu", self.camera)
	end, 1.5, 0.25)
end

function StateMenu:update(dt)
	if not self.is_ready then return end

	local dir = 0
	if Inputs.pressed("down") then
		dir = 1
	elseif Inputs.pressed("up") then
		dir = -1
	end

	if Inputs.pressed("interact") and not is_transition then
		self.world:emit("enter_option")
	end
	self.world:emit("update_cursor", dir)

	if Inputs.released("cancel") then
		self.world:emit("esc")
	end

	local mx, my = love.mouse.getPosition()
	self.world:emit("update", dt)
	self.world:emit("check_mouse_hover", mx, my)
	self.world:emit("hover_effects")
	self.world:emit("update_menu", dt)
end

function StateMenu:draw()
	if not self.is_ready then return end

	love.graphics.setColor(1, 1, 1, 1)
	self.world:emit("draw_menu", self.canvases.main_canvas)
end

function StateMenu:mousepressed(mx, my, mb)
	if not self.is_ready then return end
	self.world:emit("mousepressed", mx, my, mb)
end

function StateMenu:exit()
	Timer.clear()
	Resources.clean(resources)

	self.world:emit("cleanup")
	self.world:clear()

	for i, e in ipairs(self.world:getEntities()) do
		e:destroy()
	end

	for k, e in pairs(self.entities) do
		self.entities[k]:destroy()
		self.entities[k] = nil
	end
end

return StateMenu

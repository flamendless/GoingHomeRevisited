local Concord = require("modules.concord.concord")
local Flux = require("modules.flux.flux")
local Gamera = require("modules.gamera.gamera")
local Log = require("modules.log.log")
local Slab = require("modules.slab")
local Timer = require("modules.hump.timer")

local ECS = require("ecs")
local Canvas = require("canvas")
local Resources = require("resources")
local Dissolve = require("dissolve")
local Fade = require("fade")
local Image = require("image")
local Inputs = require("inputs")
local MotionBlur = require("motion_blur")
local Palette = require("palette")
local Preloader = require("preloader")
local Save = require("save")

local max = math.max
local min = math.min
local format = string.format
local lower = string.lower
local gsub = string.gsub
local insert = table.insert

local StateMenu = class()
StateMenu.id = "Menu"

local Components = {}
Concord.utils.loadNamespace("components", Components)

local Assemblages = {
	Menu = require("assemblages.menu"),
}

local resources = {images = {}, sources = {}, fonts = {}}
local res_images, res_fonts

local tools = !(_TOOLS)
local libs = !(_LIBS)
local options = {"Play", "Settings", "About", "Exit"}
local options_sub = {"Continue", "New Game"}

function StateMenu:setup_menu()
	local ww, wh = love.graphics.getDimensions()
	local bg_door = res_images.bg_door
	local bg_hallway = res_images.bg_hallway
	local title = res_images.title
	local subtitle = res_images.subtitle

	local bg_hw_w, bg_hw_h = bg_hallway:getDimensions()
	local bg_door_w, bg_door_h = bg_door:getDimensions()
	local title_w, title_h = title:getDimensions()
	local subt_w, subt_h = subtitle:getDimensions()

	local scale = min(ww/bg_door_w, wh/bg_door_h)
	local scale_hallway = min(ww/bg_hw_w, wh/bg_hw_h)
	local scale_title = min((bg_door_w * scale)/title_w, (bg_door_h * scale)/title_h)
	local scale_subt = min((title_w * scale_title)/subt_w, (title_h * scale)/subt_h)
	scale_subt = scale_subt * 0.75

	self.entities.bg_door = Concord.entity(self.world)
		:assemble(Assemblages.Menu.bg_door,
			bg_door, ww * 1.5, wh * 0.5, scale, bg_door_w * 0.5, bg_door_h * 0.5)

	self.entities.bg_hallway = Concord.entity(self.world)
		:assemble(Assemblages.Menu.bg_hallway,
			bg_hallway, ww * 0.5, wh * 1.5, scale_hallway, bg_hw_w * 0.5, bg_hw_h * 0.5)

	self.entities.desk = Concord.entity(self.world)
		:assemble(Assemblages.Menu.desk, res_images.sheet_desk, ww, wh)

	!if not _RELEASE then
	self.entities.secret_title = Concord.entity(self.world)
		:assemble(Assemblages.Menu.secret_title, res_fonts.about_64, 32, wh * 0.5)
	self.entities.secret_title:give("color_fade_in", 5, 3)
	!end

	self.entities.title = Concord.entity(self.world)
		:assemble(Assemblages.Menu.title, title, ww * 0.25, wh * 0.5 - 36,
			scale_title, title_w * 0.5, title_h * 0.5)

	self.entities.subtitle = Concord.entity(self.world)
		:assemble(Assemblages.Menu.subtitle, subtitle, ww * 0.25, wh * 1.5,
			self.entities.title, scale_subt, subt_w * 0.5, subt_h * 0.5)

	local jamboree_fnt = "res/fonts/Jamboree.fnt"
	local jamboree_png = "res/fonts/Jamboree.png"
	local sdf_menu = love.graphics.newFontMSDF(jamboree_fnt, jamboree_png)
	local font_menu = res_fonts.menu
	local str_target_h = font_menu:getHeight()
	local str_h = sdf_menu:getHeight()
	local scale = str_target_h/str_h * 0.75
	local offset = 16
	local padding = 2

	for i, str in ipairs(options) do
		local lstr = lower(str)
		local str_w = sdf_menu:getWidth(str) * scale
		local x = self.canvases.bot_canvas.width - str_w - offset
		local y = self.canvases.bot_canvas.y + (i * str_h) + (padding * i) - offset
		local id = "text_" .. lstr

		self.entities[id] = Concord.entity(self.world)
			:assemble(Assemblages.Menu.option_item, id, str, sdf_menu, x, y, scale, i, 1)
			:give("on_enter_menu", "on_" .. lstr, 0, lstr)
			:give("menu_opt")
	end

	for i, str in ipairs(options_sub) do
		local lstr = lower(str)
		lstr = gsub(lstr, "%s+", "")
		local str_w = sdf_menu:getWidth(str) * scale
		local x = self.canvases.bot_canvas.width - str_w - offset
		local y = self.canvases.bot_canvas.y + (i * str_h) + (padding * i) - offset
		local id = "text_sub_" .. lstr

		self.entities[id] = Concord.entity(self.world)
			:assemble(Assemblages.Menu.option_item, id, str, sdf_menu, x, y, scale, i, 2)
			:give("on_enter_menu", "on_" .. lstr)
			:give("menu_sub_opt")
	end
end

local function generate_about()
	local t = {
		{"@COLOR"},
		!if _RELEASE then
		{(!(string.upper(_GAME_TITLE))), res_fonts.about_64, 12},
		!else
		{(!(string.upper(_GAME_TITLE_SECRET))), res_fonts.about_64, 12},
		!end

		{"@COLOR"},
		{"A Game By:"},
		{!(_FULL_NAME_DEVELOPER .. "    " .. _TWITTER_DEVELOPER)},
		{""},

		{"@COLOR"},
		{"Arts By:"},
		{!(_FULL_NAME_ARTIST .. "    " .. _TWITTER_ARTIST)},
		{""},

		{"@COLOR"},
		{"Level Design By:"},
		{!(_FULL_NAME_DESIGNER .. "    " .. _TWITTER_DESIGNER)},
		{""},

		--TODO add musician here

		{"@LAYOUT:LEFT"},
		{"@COLOR"},
		{"TOOLS USED:"},
	}

	for i = 1, #tools, 2 do
		local a = tools[i]
		local b = tools[i + 1] or ""
		local subt = {format("%s, %s", a, b)}

		insert(t, subt)
	end

	insert(t, {"@LAYOUT:RIGHT"})
	insert(t, {"@COLOR"})
	insert(t, {"LIBRARIES USED:"})

	for i = 1, #libs, 3 do
		local a = libs[i]
		local b = libs[i + 1] or ""
		local c = libs[i + 2] or ""

		if b ~= "" then a = a .. "," end
		if c ~= "" then b = b .. "," end

		local subt = {format("%s %s %s", a, b, c)}

		insert(t, subt)
	end

	insert(t, {"@LAYOUT:CENTER"})
	insert(t, {""})
	insert(t, {"SPECIAL THANKS to the people at the LÃ¶ve Discord server"})
	insert(t, {
		res_images.twitter, res_images.discord,
		res_images.website, res_images.mail
	})

	return t
end

function StateMenu:setup_about()
	local about = generate_about()
	!!local about_links = _ABOUT_LINKS
	local l, t, w, h = self.camera:getVisible()
	local font_about = res_fonts.about_20
	local base_x = w * 0.5
	local base_y = h + 16
	local layout = false
	local layout_base_y = 0
	local largest = 0
	local dt_color = false
	local color = Palette.get("about_normal")

	self.entities.btn_back = Concord.entity(self.world)
		:assemble(Assemblages.Menu.btn_back, res_images.btn_back, 8, base_y)
		:give("on_click", 1, function()
			self:esc()
		end)

	for i, el in ipairs(about) do
		if type(el[1]) == "string" then
			local str = el[1]
			local font = el[2] or font_about
			local space = el[3]
			local str_w = font:getWidth(str)
			local str_h = font:getHeight(str)
			local x = base_x - str_w * 0.5
			local y = base_y

			if space then base_y = base_y + space end

			if str == "@LAYOUT:LEFT" then
				base_x = w * 0.25
				layout_base_y = base_y
				layout = true
			elseif str == "@LAYOUT:RIGHT" then
				base_x = w * 0.75
				layout_base_y = base_y
				layout = true
			elseif str == "@LAYOUT:CENTER" then
				base_x = w * 0.5
				base_y = largest
				layout = false
			elseif str == "@COLOR" then
				color = Palette.get("about_hint")
				dt_color = true
			else
				if layout then
					y = layout_base_y
					layout_base_y = layout_base_y + str_h
					largest = max(largest, layout_base_y)
				end

				local id = "about_text_" .. i

				self.entities[id] = Concord.entity(self.world)
					:assemble(Assemblages.Menu.about_text, id, str, font, x, y, color)

				if dt_color then
					color = Palette.get("about_normal")
					dt_color = false
				end

				if not layout then base_y = base_y + str_h end
			end
		elseif el[1].type and el[1]:type() == "Image" then
			local pad = 24
			local img_h

			for i2, image in ipairs(el) do
				local id = "about_image_" .. (i + i2)
				local image_base_x = base_x - (#el * 0.5 * image:getWidth()) - pad
				local x = image_base_x + (image:getWidth() + pad) * (i2 - 1)
				local y = base_y + image:getHeight() * 0.5 - pad
				img_h = image:getHeight()

				self.entities[id] = Concord.entity(self.world)
					:assemble(Assemblages.Menu.about_ext_link, id, image, x, y)
					:give("on_click", 1, function()
						love.system.openURL(about_links[i2])
					end)
			end

			base_y = base_y + img_h + pad
		end
	end
end

function StateMenu:new()
	return self:init({
		camera = nil,
		world = Concord.world(),
		entities = {},
		canvases = {},
		is_ready = false,
		gamestate = nil,
	})
end

function StateMenu:load()
	local resources_data = Resources.get("menu")

	Preloader.start(resources_data, resources,
		function()
			res_images = resources.images
			res_fonts = resources.fonts
			-- TODO play BGM
			self.is_ready = true
			self:start()
			Slab.Initialize()
		end)
end

function StateMenu:start()
	ECS.load_systems(self.id, self.world)
	self.world.state = self

	local ww, wh = love.graphics.getDimensions()
	local img_ff = Image.resize_image(res_images.flowfield)

	self.camera = Gamera.new(0, 0, ww * 2, wh * 2)
	self.camera:setWindow(0, 0, ww, wh)
	Canvas.init_canvases(self.canvases)
	self.mb_main = MotionBlur:new(self.canvases.main_canvas)
	self.dissolve_ff = Dissolve:new(img_ff, 2)

	self.world:emit("init_menu", self.camera, self.mb_main, self.dissolve_ff)
	self:setup_menu()
	self.world:emit("hide_main_menu", 0.1)
	self.world:emit("hide_sub_menu", 0.1)

	Fade.set_color({0, 0, 0, 1})
	Fade.fade_in(function()
		self.world:emit("allow_cursor", true)
		self.world:emit("set_cursor", 1)
		self.entities.subtitle:remove("anchor")
		self.world:emit("show_main_menu", self.camera)
	end, 1.5, 0.25)
end

function StateMenu:update(dt)
	if not self.is_ready then return end

	local dir = 0
	if Inputs.pressed("down") then
		dir = 1
	elseif Inputs.pressed("up") then
		dir = -1
	end

	if Inputs.pressed("interact") and not is_transition then
		self.world:emit("enter_option")
	end
	self.world:emit("update_cursor", dir)

	if Inputs.released("cancel") then
		self.world:emit("esc")
	end

	local mx, my = love.mouse.getPosition()
	self.world:emit("update", dt)
	self.world:emit("check_mouse_hover", mx, my)
	self.world:emit("hover_effects")
	self.world:emit("update_menu", dt)
end

function StateMenu:draw()
	if not self.is_ready then return end

	love.graphics.setColor(1, 1, 1, 1)
	self.world:emit("draw_menu", self.canvases.main_canvas)
end

function StateMenu:mousepressed(mx, my, mb)
	if not self.is_ready then return end
	self.world:emit("mousepressed", mx, my, mb)
end

function StateMenu:exit()
	Timer.clear()
	Resources.clean(resources)

	self.world:emit("cleanup")
	self.world:clear()

	for i, e in ipairs(self.world:getEntities()) do
		e:destroy()
	end

	for k, e in pairs(self.entities) do
		self.entities[k]:destroy()
		self.entities[k] = nil
	end
end

return StateMenu

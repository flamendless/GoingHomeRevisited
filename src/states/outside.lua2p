local Concord = require("modules.concord.concord")
local Flux = require("modules.flux.flux")
local Gamera = require("modules.gamera.gamera")
local Log = require("modules.log.log")
local Timer = require("modules.hump.timer")
local TLE = require("modules.tle.timeline")

local Canvas = require("canvas")
local ECS = require("ecs")
local EventsList = require("data.events_list")
local EventManager = require("event_manager")
local Factory = require("factory")
local Fade = require("fade")
local Info = require("info")
local Inputs = require("inputs")
local NGrading = require("ngrading")
local Resources = require("resources")
local Palette = require("palette")
local Preloader = require("preloader")
local ScreenInfo = require("screen_info")
local Settings = require("settings")

local floor = math.floor
local min = math.min
local random = love.math.random
local format = string.format
local insert = table.insert

local StateOutside = class()
StateOutside.id = "Outside"

!if _DEV then
local world
!end

local Assemblages = {
	Common = require("assemblages.common"),
	InteractiveOutside = require("assemblages.interactive_outside"),
	Items = require("assemblages.items"),
	Outside = require("assemblages.outside"),
	Player = require("assemblages.player"),
	UI = require("assemblages.ui"),
}

local ParticleSystems = {
	RainOutside = require("particle_systems/rain_outside"),
}

local resources = {images = {}, image_data = {}, fonts = {}}
local res_images, res_fonts
local screen_size
local rain_state = {current = 128}
local is_raining = false
local effect
local fireflies_flag = false
local overlay_flag = false
local overlay = {0, 0, 0, 1}
local ambient_color = {0.3, 0.3, 0.3}

local tasks = {
	"Get out of the car",
	"Get inside the house",
}

local function tle_log(msg)
	local str = format("TLE: %s", msg)
	Log.debug(str)
end

function StateOutside:show_arrows_keys()
	local dur = 1.75
	local scale = 1.75
	local scale_sdf = scale - 0.75
	local ax = screen_size.x * 0.35
	local ay = screen_size.y * 0.5
	local jamboree_fnt = "res/fonts/Jamboree.fnt"
	local jamboree_png = "res/fonts/Jamboree.png"
	local font_sdf = love.graphics.newFontMSDF(jamboree_fnt, jamboree_png)

	local e_arrows = Factory.arrows(self.world, res_images.sheet_arrows, ax, ay, 16, scale)
	local e_arrows_keys = Factory.arrows_keys(self.world, e_arrows, font_sdf, ax, ay, scale_sdf)

	for _, e in pairs(e_arrows) do e:give("color_fade_in", dur) end
	for _, e in pairs(e_arrows_keys) do e:give("color_fade_in", dur) end

	return e_arrows, e_arrows_keys
end

function StateOutside:spawn_player(dur_camera_follow)
	self.entities.player = Concord.entity(self.world)
		:assemble(Assemblages.Player.outside_house,
			res_images.sheet_player_idle,
			res_images.sheet_player_walk,
			res_images.sheet_player_run,
			res_images.sheet_player_open_door,
			res_images.sheet_player_upstairs,
			res_images.sheet_player_downstairs,
			false, false)

	self.world:emit("face_left", self.entities.player)
	self.world:emit("camera_follow", self.entities.player, dur_camera_follow)
end

function StateOutside:new()
	return self:init({
		is_ready = false,
		world = Concord.world(),
		entities = {},
		camera = nil,
		gamestate = nil
	})
end

function StateOutside:load()
	local resources_data = Resources.get("outside")

	Preloader.start(resources_data, resources,
		function()
			res_images = resources.images
			res_fonts = resources.fonts
			!if not _RELEASE then
			world = self.world
			!end
			self.is_ready = true
			self:start()
		end)
end

function StateOutside:start()
	ECS.load_systems(self.id, self.world)

	local w, h = res_images.bg_house:getDimensions()
	local ww, hh = love.graphics.getDimensions()

	self.main_canvas = Canvas.create_main({})

	screen_size = vec2:new(ww, hh)
	self.scale = min(screen_size.x/w, screen_size.y/h)

	self.camera = Gamera.new(0, 0, w, h)
	self.camera:setWindow(0, 0, screen_size.x, screen_size.y)
	self.entities.camera = Concord.entity(self.world)
		:assemble(Assemblages.Common.camera, self.camera, self.scale, w, h)

	ScreenInfo.set(w, h, w, h)
	self.world:emit("create_light_map", self.main_canvas.x, self.main_canvas.y, w, h)
	self.world:emit("set_gamestate", self.gamestate)
	self.world:emit("set_ambient_light", ambient_color)

	self.world:emit("set_dialogue_config", {
			pos = {x = ww/2, y = hh * 0.87},
			pos_arrow = {x = ww/2, y = hh * 0.94},
			font = res_fonts.dialogue,
			sheet_arrow = res_images.sheet_dialogue_arrow,
		})

	self.world:emit("set_light_resources", {
			round = res_images.light_round,
			rectangle = res_images.light_rectangle,
			cone = res_images.light_cone,
		})

	self.world:emit("set_action_controls_resources", {
			eye = res_images.sheet_ui_eye,
			hand = res_images.sheet_ui_hand,
			bag = res_images.sheet_ui_bag,
			cancel = res_images.sheet_ui_cancel,
			use = res_images.sheet_ui_use,
			combine = res_images.sheet_ui_combine,
			back = res_images.sheet_ui_back,
		})

	self.world:emit("set_items_resources", {
			item_backdoor_key = res_images.backdoor_key,
		})

	self.world:emit("set_notification_resources", {
			question_mark = res_images.question_mark
		})

	local cx, cy, cw, ch = self.camera:getVisible()

	self.ps1 = ParticleSystems.RainOutside:new(res_images.rain_drop, 128, cw)
	self.ps2 = ParticleSystems.RainOutside:new(res_images.rain_drop2, 128, cw)

	!if not _RELEASE then
	self.world:emit("debug_particle_system", self.ps1.system)
	self.world:emit("debug_particle_system", self.ps2.system)
	self.world:emit("debug_camera", self.camera)
	!end

	self.world:emit("create_inventory_cell",
		res_images.bg_item,
		res_images.bg_desc,
		res_fonts.item_desc)

	self.entities.backdoor_key = Concord.entity(self.world)
		:assemble(Assemblages.Items.backdoor_key, res_images.backdoor_key)

	local bg_house = res_images.bg_house
	local bg_house_w, bg_house_h = bg_house:getDimensions()
	local div = 4
	local qw = bg_house_w/div
	local qh = bg_house_h

	for i = 1, div do
		local id = "bg_house_" .. i
		local x = bg_house_w * ((i - 1) % div)/div
		local y = bg_house_h * floor((i - 1)/div)/div
		local quad = love.graphics.newQuad(x, y, qw, qh, bg_house_w, bg_house_h)

		self.entities[id] = Concord.entity(self.world)
			:assemble(Assemblages.Outside.bg_house, bg_house, x, y, quad)
	end

	self.entities.railings = Concord.entity(self.world)
		:assemble(Assemblages.Outside.railings, res_images.railings)

	self.entities.left_bounds = Concord.entity(self.world)
		:assemble(Assemblages.Outside.left_bounds)

	self.entities.right_bounds = Concord.entity(self.world)
		:assemble(Assemblages.Outside.right_bounds)

	self.entities.left_wall = Concord.entity(self.world)
		:assemble(Assemblages.Outside.left_wall)

	self.entities.right_wall = Concord.entity(self.world)
		:assemble(Assemblages.Outside.right_wall)

	self.entities.wood = Concord.entity(self.world)
		:assemble(Assemblages.Outside.wood)

	self.entities.house_left = Concord.entity(self.world)
		:assemble(Assemblages.Outside.house, "left")

	self.entities.house_right = Concord.entity(self.world)
		:assemble(Assemblages.Outside.house, "right")

	self.entities.house_top = Concord.entity(self.world)
		:assemble(Assemblages.Outside.house, "top")

	self.entities.left_railing = Concord.entity(self.world)
		:assemble(Assemblages.Outside.left_railing)

	self.entities.right_railing = Concord.entity(self.world)
		:assemble(Assemblages.Outside.right_railing)

	self.entities.col_railing_left = Concord.entity(self.world)
		:assemble(Assemblages.Outside.col_railing, "left")

	self.entities.col_railing_right = Concord.entity(self.world)
		:assemble(Assemblages.Outside.col_railing, "right")

	self.entities.house_side = Concord.entity(self.world)
		:assemble(Assemblages.Outside.house_side)

	self.entities.car = Concord.entity(self.world)
		:assemble(Assemblages.Outside.car, res_images.car)

	self.entities.fence = Concord.entity(self.world)
		:assemble(Assemblages.Outside.fence, res_images.fence)

	self.entities.fence_right = Concord.entity(self.world)
		:assemble(Assemblages.Outside.fence_right)

	self.entities.gate = Concord.entity(self.world)
		:assemble(Assemblages.Outside.gate, res_images.gate)

	self.entities.splat_data = Concord.entity(self.world)
		:assemble(Assemblages.UI.splat_data, res_images.sheet_splat)

	self.entities.brush_data = Concord.entity(self.world)
		:assemble(Assemblages.UI.brush_data, res_images.sheet_brush)

	self.entities.cloud_data = Concord.entity(self.world)
		:assemble(Assemblages.UI.cloud_data, res_images.sheet_cloud)

	self.entities.house_light = Concord.entity(self.world)
		:assemble(Assemblages.Outside.house_light, res_images.house_light)

	for k, v in pairs(Assemblages.InteractiveOutside) do
		self.entities[k] = Concord.entity(self.world):assemble(v)
	end

	for i, str in ipairs(tasks) do
		self.entities["task" .. i] = Concord.entity(self.world)
			:assemble(Assemblages.UI.ui_text_paint, "brush",
				str, res_fonts.task, screen_size.x/2, screen_size.y * 0.9)
			:give("task", Palette.get("ui_feedback"))
	end

	local splashes = res_images.splashes
	local is_compatible = Info.is_texturesize_compatible(splashes:getWidth())

	if not is_compatible then
		splashes = res_images.splashes_low
		Log.warn("Texture size for splashes use 'low' version")
	end

	self.splashes = {}

	for i = 1, 3 do
		local x = (i == 1) and 0 or random(-16, 0)
		local y = (i == 1) and 0 or random(-8, 8)
		local e = Concord.entity(self.world)
			:assemble(Assemblages.Outside.splashes, splashes, x, y, is_compatible)

		insert(self.splashes, e)
	end

	self.world:emit("generate_fireflies",
		random(5, 20), res_images.firefly, res_images.firefly_light,
		{x = 670, y = 222}, {x = 1136, y = 286})

	local lut_size, lut_dusk

	if Settings.current.graphics_quality == "Low" then
		lut_size = 16
		lut_dusk = resources.image_data.lut_dusk_16
	else
		lut_size = 64
		lut_dusk = resources.image_data.lut_dusk_64
	end

	effect = NGrading:new(lut_dusk, lut_size)

	--TEST
	!if _DEV then
	-- self.world:emit("move_fireflies")
	Fade.set_alpha(0)
	self:spawn_player(1.5)
	self.entities.player.body.can_move = true

	self.entities.backdoor_key2 = Concord.entity(self.world)
		:assemble(Assemblages.Items.backdoor_key, res_images.backdoor_key)
		:give("id", "item_test")
	self.entities.backdoor_key3 = Concord.entity(self.world)
		:assemble(Assemblages.Items.backdoor_key, res_images.backdoor_key)
	self.entities.backdoor_key4 = Concord.entity(self.world)
		:assemble(Assemblages.Items.backdoor_key, res_images.backdoor_key)
	self.entities.backdoor_key5 = Concord.entity(self.world)
		:assemble(Assemblages.Items.backdoor_key, res_images.backdoor_key)
	self.entities.backdoor_key6 = Concord.entity(self.world)
		:assemble(Assemblages.Items.backdoor_key, res_images.backdoor_key)

	self.camera:setScale(3)
	self.camera:setPosition(self.entities.player.pos.x, self.entities.player.pos.y)
	!end

	--TIMELINE
	self.timeline = TLE.Do(function()
		!if _DEV then
		self.timeline:Pause()
		!end

		Fade.set_alpha(0)
		is_raining = true
		self.ps1.system:setEmissionRate(rain_state.current)
		self.ps2.system:setEmissionRate(rain_state.current)

		fireflies_flag = true
		overlay_flag = true

		tle_log("begin timeline")
		self.camera:setScale(6)
		self.camera:setPosition(262, 61)

		tle_log("start fade in")
		Flux.to(overlay, 4, {[4] = 0})
			:oncomplete(function()
				overlay_flag = false
				tle_log("end fade in")
			end)

		tle_log("start camera pan and zoom")
		Flux.to(self.camera, 6, {x = 520, y = 193})
			:delay(2)
			:oncomplete(function()
				self.timeline:Unpause()
			end)
		self.timeline:Pause()

		Flux.to(self.camera, 10, {x = 960, y = 296, scale = 3})

		tle_log("begin rain fade")
		TLE.Event.Wait(3)
		local dur_fade_rain = 8

		for _, e in ipairs(self.splashes) do
			e:give("color_fade_out", dur_fade_rain)
		end

		Flux.to(rain_state, dur_fade_rain, {current = 0})
			:onupdate(function()
				self.ps1.system:setEmissionRate(rain_state.current)
				self.ps2.system:setEmissionRate(rain_state.current)

				if rain_state.current <= 16 then
					if fireflies_flag then
						self.world:emit("move_fireflies")
						self.world:emit("show_fireflies", 5, function()
								self.world:emit("flicker_fireflies", 3, 5)
							end)
						fireflies_flag = false
						tle_log("fireflies start")
					end
				end
			end)
			:oncomplete(function()
				for i, e in ipairs(self.splashes) do
					e:destroy()
					self.splashes[i] = nil
				end
				tle_log("splashes stopped")

				is_raining = false
				self.ps1.system:stop()
				self.ps2.system:stop()
				self.timeline:Unpause()
				self.world:emit("cleanup_rain")
				tle_log("end rain fade")
			end)
		self.timeline:Pause()

		local timer_hold_key = 1
		local dur_fade_task = 1.25
		local dur_fade_hold = 0.75
		local dur_camera_follow = 1.5
		local p_interact_id = "interact"
		local key_id = Inputs.rev_map[p_interact_id]

		tle_log("task: " .. tasks[1])
		self.world:emit("show_text_paint", self.entities.task1, dur_fade_task)

		tle_log("wait for action")
		local e_hold_key = Factory.hold_key(self.world, key_id,
			screen_size.x/2, screen_size.y/2, timer_hold_key,
			64, res_images.sheet_keypress, res_fonts.ui, dur_fade_task)

		local ev1 = EventsList.hold_key(key_id, p_interact_id,
			timer_hold_key, e_hold_key.progress)
		ev1.on_complete = function()
			tle_log("action completed")

			for id, e in pairs(e_hold_key) do
				e:give("color_fade_out", dur_fade_hold)
			end

			self.world:emit("fade_text_paint", self.entities.task1, dur_fade_task,
				function()
					for id, e in pairs(e_hold_key) do
						e:destroy()
					end
					self.timeline:Unpause()
				end)

			self:spawn_player(dur_camera_follow)
			Flux.to(self.camera, 1, {scale = 3})
			tle_log("player created")
		end

		EventManager.add(ev1)
		self.timeline:Pause()
		self.entities.player.body.can_move = true
		self.entities.player.player.can_interact = true

		TLE.Event.Wait(0.25)
		tle_log("task: " .. tasks[2])

		local dur_fade_task2 = 2.25
		local e_arrows, e_arrows_keys = self:show_arrows_keys()
		local ev2 = EventsList.arrows_keys(e_arrows, e_arrows_keys, dur_fade_task2)

		self.world:emit("show_text_paint", self.entities.task2, dur_fade_task2)

		EventManager.add(ev2)
		self.timeline:Pause()
	end)
end

function StateOutside:update(dt)
	if not self.is_ready then return end

	self.world:emit("preupdate", dt)

	!if _DEV then
	if Inputs.pressed("play") then
		self.timeline:Unpause()
	elseif Inputs.pressed("inventory") then
		self.world:emit("action_interacted_bag", self.entities.interactive_car, self.entities.player)
	end
	!end

	self.world:emit("update", dt)
	self.world:emit("update_light", dt)
	self.world:emit("on_camera_move", self.camera)

	local mx, my = love.mouse.getPosition()
	local wmx, wmy = self.camera:toWorld(mx, my)

	self.world:emit("check_mouse_hover", wmx, wmy)
	self.world:emit("check_mouse_hover_ui", mx, my)
	self.world:emit("hover_effects")

	if is_raining then
		self.ps1:update(dt)
		self.ps2:update(dt)
	end
end

function StateOutside:draw()
	if not self.is_ready then return end

	self.world:emit("draw_light_start")
	self.world:emit("draw_light")

	love.graphics.setBlendMode("alpha")
	love.graphics.setColor(1, 1, 1, 1)
	love.graphics.setCanvas(self.main_canvas.canvas)

	self.camera:draw(function(l, t, w, h)
		effect:apply()

		love.graphics.draw(res_images.bg_sky)
		self.world:emit("draw")
		self.world:emit("draw_z")

		if is_raining then
			self.ps1:draw(0, -16)
			self.ps2:draw(0, -16)
		end

		love.graphics.setShader()

		self.world:emit("draw_light_end")

		if overlay_flag then
			love.graphics.setColor(overlay)
			love.graphics.rectangle("fill", l, t, w, h)
		end
	end)

	self.world:emit("draw_clip")
	self.world:emit("draw_ui")
	Fade.draw()

	love.graphics.setCanvas()
	self.main_canvas:render()
end

function StateOutside:mousepressed(mx, my, mb)
	if not self.is_ready then return end

	local cx, cy = self.camera:toWorld(mx, my)

	self.world:emit("mousepressed", cx, cy, mb)
	self.world:emit("mousepressed_ui", mx, my, mb)
end

function StateOutside:keypressed(key)
	if not self.is_ready then return end
	self.world:emit("keypressed", key)
end

function StateOutside:exit()
	Timer.clear()
	Resources.clean(resources)

	self.ps1.system:stop()
	self.ps2.system:stop()
	self.ps1 = nil
	self.ps2 = nil
	self.timeline:Die()

	self.world:emit("cleanup")
	self.world:clear()

	for i, e in ipairs(self.world:getEntities()) do
		e:destroy()
	end

	for k, v in pairs(self.entities) do
		v:destroy()
		self.entities[k] = nil
	end

	rain_state.current = 128
	effect = nil
	fireflies_flag = false
	overlay_flag = false
end

return StateOutside

local Concord = require("modules.concord.concord")
local Gamera = require("modules.gamera.gamera")
local Timer = require("modules.hump.timer")

local ECS = require("ecs")
local MapData = require("data.map_data")
local Resources = require("resources")
local Preloader = require("preloader")
local ScreenInfo = require("screen_info")

local min = math.min

local StateStorageRoom = class()
StateStorageRoom.id = "StorageRoom"

local Assemblages = {
	Common = require("assemblages.common"),
	Player = require("assemblages.player"),
}

local resources = {images = {}, fonts = {}}
local res_images, res_fonts
local screen_size

function StateStorageRoom:spawn_player()
	self.entities.player = Concord.entity(self.world)
		:assemble(Assemblages.Player.test,
			res_images.sheet_player_idle,
			res_images.sheet_player_walk,
			res_images.sheet_player_run)
end

function StateStorageRoom:new()
	return self:init({
		is_ready = false,
		world = Concord.world(),
		entities = {},
		camera = nil,
		gamestate = nil
	})
end

function StateStorageRoom:load()
	local resources_data = Resources.get("storage_room")

	Preloader.start(resources_data, resources,
		function()
			res_images = resources.images
			res_fonts = resources.fonts

			self.is_ready = true
			self:start()
		end)
end

function StateStorageRoom:start()
	ECS.load_systems(self.id, self.world)

	-- local w, h = res_images.bg_house:getDimensions()
	-- local w, h = love.graphics.getDimensions()
	local world_size = MapData.get_size("Test")
	local w, h = world_size[1], world_size[2]
	local ww, hh = love.graphics.getDimensions()

	screen_size = vec2:new(ww, hh)
	self.scale = min(screen_size.x/w, screen_size.y/h)

	self.camera = Gamera.new(0, 0, w, h)
	self.camera:setWindow(0, 0, screen_size.x, screen_size.y)
	self.entities.camera = Concord.entity(self.world)
		:assemble(Assemblages.Common.camera, self.camera, self.scale, w, h)

	ScreenInfo.set(w, h, ww, hh, self.scale)

	self.world:emit("set_gamestate", self.gamestate)

	!if not _RELEASE then
	self.world:emit("debug_camera", self.camera)
	!end

	--TEST
	local map_path = MapData.get_path("Test")
	self.entities.test_map = Concord.entity(self.world)
		:give("id", "test_map")
		:give("tilemap", map_path)

	self:spawn_player()
end

function StateStorageRoom:update(dt)
	if not self.is_ready then return end

	self.world:emit("preupdate", dt)
	self.world:emit("update_topdown", dt)
	self.world:emit("update", dt)

	!if not _RELEASE then
	self.world:emit("debugging_update", dt)
	!end
end

function StateStorageRoom:draw()
	if not self.is_ready then return end

	self.camera:draw(function(l, t, w, h)
		self.world:emit("draw_map")
		self.world:emit("draw")
		self.world:emit("draw_z")

		!if not _RELEASE then
		self.world:emit("debugging_draw", l, t, w, h)
		!end
	end)

	-- self.world:emit("draw_clip")
	self.world:emit("draw_ui")
end

function StateStorageRoom:keypressed(key)
	if not self.is_ready then return end

	self.world:emit("keypressed", key)
end

function StateStorageRoom:exit()
	Timer.clear()
	Resources.clean(resources)

	self.world:emit("cleanup")
	self.world:clear()

	for i, e in ipairs(self.world:getEntities()) do
		e:destroy()
	end

	for k, v in pairs(self.entities) do
		v:destroy()
		self.entities[k] = nil
	end
end

return StateStorageRoom

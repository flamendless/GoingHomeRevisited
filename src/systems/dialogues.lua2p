local Concord = require("modules.concord.concord")
local Timer = require("modules.hump.timer")

local DialoguesList = require("dialogues")
local Inputs = require("inputs")
local Palette = require("palette")
local ScreenInfo = require("screen_info")
local Utils = require("utils")

local Dialogues = Concord.system({
})

local UI = require("assemblages.ui")

function Dialogues:init(world)
	self.world = world
end

function Dialogues:on_collision_dialogue(e, other)
	@@assert(e.__isEntity)
	@@assert(other.__isEntity)
	local body = e.body
	local other_col = other.collider
	if not e.within_dialogue then
		e:give("within_dialogue", other)
	end
end

function Dialogues:show_dialogue(id, sub, interactive_id)
	@@assert(type(id) == "string")
	@@assert(type(sub) == "string")
	@@sassert(interactive_id, type(interactive_id) == "string")
	@@assert(self.font)
	local dialogue = DialoguesList.get_spec(id, sub)
	local text
	local widest

	if type(dialogue) == "string" then
		text = dialogue
	elseif type(dialogue) == "table" then
		self.dialogue_t = dialogue
		self.current_i = 1
		text = dialogue[1]
		widest = Utils.get_widest_str(dialogue)
	end

	local pos_dialogue = self.pos:copy()
	local pos_arrow = self.pos_arrow:copy()

	local e_dialogue = Concord.entity(self.world)
		:assemble(UI.dialogue_text, "d_" .. id, text, self.font, pos_dialogue)
		:give("reflowprint", ScreenInfo.w * 0.5, "left")

	if interactive_id then
		e_dialogue:give("dialogue_interactive", interactive_id)
	end

	local e_arrow = Concord.entity(self.world)
		:assemble(UI.dialogue_arrow, self.sheet_arrow, pos_arrow)
		:give("color_fade_in", self.dur_show)

	self.world:emit("show_text_paint", e_dialogue, self.dur_show, widest)
	e_dialogue.text_with_paint.paint:give("layer", "dialogue", 1)
	self.world:emit("displayed_dialogue")
end

function Dialogues:hide_dialogue(e)
	self.world:emit("fade_text_paint", e, self.dur_hide)
	self.arrow:give("color_fade_out", self.dur_hide)
	self.world:emit("fading_out_dialogue")
end

function Dialogues:next_dialogue()
	self.current_i = self.current_i + 1

	local next_dialogue = self.dialogue_t[self.current_i]

	if next_dialogue then
		local rfp = self.current_d.reflowprint

		rfp.dt = 0
		rfp.current = 1
		self.current_d.text.text = next_dialogue
	else
		self:hide_dialogue(self.current_d)
	end

	local arrow_anim = self.arrow.animation
	arrow_anim.is_playing = true
	arrow_anim.animation:gotoFrame(1)
	arrow_anim.animation:resume()
end

function Dialogues:update(dt)
	-- self.timer:update(dt)

	if self.arrow then
		local orig = self.arrow.pos.original_pos
		local pos = self.arrow.pos.pos
		local dir = self.arrow.direction

		pos.y = pos.y + 16 * dir.dir * dt

		if pos.y > orig.y + 8 then
			dir.dir = -1
		elseif pos.y <= orig.y then
			dir.dir = 1
		end
	end
end

function Dialogues:keypressed(key)
	if self.has_dialogue then
		if Inputs.is_pressed("ui_interact", key) then
			if self.dialogue_t then
				self:next_dialogue()
			else
				self:hide_dialogue(self.pool[1])
			end
		end
	end
end

function Dialogues:cleanup()
	for _, e in ipairs(self.pool) do
		e:destroy()
	end

	self.timer:clear()
end

return Dialogues

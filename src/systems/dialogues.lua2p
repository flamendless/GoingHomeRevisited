local Concord = require("modules.concord.concord")

local DialoguesList = require("dialogues")
local Inputs = require("inputs")
local Resources = require("resources")
local Palette = require("palette")

local insert = table.insert

local Dialogues = Concord.system({
	pool_camera = {"camera"},
	pool = {"dialogue_item", "text_t", "nf_render_text"},
	pool_choice = {"choice_item", "text_t", "nf_render_text"},
})

local UI = require("assemblages.ui")
local PAD = 32
local c_hc = Palette.get("hovered_choice")

function Dialogues:init(world)
	self.world = world
	self.main_camera = nil
	self.is_waiting = false

	self.pool_camera.onAdded = function(pool, e)
		local camera = e.camera
		if camera.is_main then
			self.main_camera = camera.camera
		end
	end

	self.pool.onAdded = function(pool, e)
		local t = e.text_t
		local str = t.value[t.current_index]
		local bool, signal = self:check_signal(str)
		if bool then
			self.world:emit(signal, e, t.value)
			t.current_index = t.current_index + 1
			local next_str = t.value[t.current_index]
			if next_str then
				e:give("text", next_str)
			end
		else
			e:give("text", str)
		end
	end
end

function Dialogues:wait_dialogue(bool)
	@@assert(type(bool) == "boolean")
	self.is_waiting = bool
end

function Dialogues:spawn_dialogue(main, sub)
	@@assert(type(main) == "string")
	@@assert(type(sub) == "string")
	local e = Concord.entity(self.world):give("dialogue", main, sub)
	self:show_dialogue(sub, DialoguesList.get(main, sub), e)
	e:destroy()
end

function Dialogues:spawn_dialogue_ex(t, is_full, signal_after, ...)
	@@assert(type(t) == "table")
	@@assert(#t ~= 0)
	@@sassert(is_full, type(is_full) == "boolean")
	@@sassert(signal_after, type(signal_after) == "string")
	local e = Concord.entity(self.world):give("dialogue", "", "")
	local e_d = self:show_dialogue("_ex", t, e)
	e:destroy()
	if is_full then
		self.world:emit("on_interact_or_inventory")
	end
	if signal_after then
		e_d:give("on_dialogue_end", signal_after, 0, ...)
	end
end

function Dialogues:show_dialogue(id, dialogues_t, e)
	@@assert(type(id) == "string")
	@@assert(type(dialogues_t) == "table")
	@@assert(e.__isEntity)
	local d = e.dialogue
	local l, _, w, h = self.main_camera:getWindow()
	local x = l + PAD
	local y = h - h * 0.15 * 0.5
	local e_dialogue = Concord.entity(self.world):assemble(UI.dialogue_text,
			id, dialogues_t, x, y)
		:give("reflowprint", w - PAD * 2, "left")
		:give("dialogue", d.main, d.sub)
	self:populate_choices(e_dialogue, dialogues_t)
	self.world:emit("set_sys_inventory", false)

	return e_dialogue
end

function Dialogues:update_dialogue(e, new_dialogues_t)
	@@assert(e.__isEntity)
	@@assert(type(new_dialogues_t) == "table")
	if not e.choice_item then
		e:remove("text_can_proceed")
		:remove("text_t")
		:give("text_t", new_dialogues_t)
		local text = e.text
		if text then
			text.value = new_dialogues_t[1]
		else
			e:give("text", new_dialogues_t[1])
		end
	else
		self:show_dialogue("next_dialogue", new_dialogues_t, e)
	end
end

function Dialogues:proceed_dialogue()
	for _, e in ipairs(self.pool) do
		local rfp = e.reflowprint
		local text = e.text
		if e.text_skipped then
			e:remove("text_skipped")
		elseif e.text_can_proceed then
			local text_t = e.text_t
			rfp.dt = 0
			rfp.current = 1
			text_t.current_index = text_t.current_index + 1
			local str = text_t.value[text_t.current_index]
			if not str then
				self.world:emit("dialogue_reached_end", e)
			else
				local bool, signal = self:check_signal(str)
				if bool then
					self.world:emit(signal, e, text_t.value)
				else
					text.value = str
					e:remove("text_can_proceed")
				end
			end
		end
	end
end

function Dialogues:update(dt)
	if self.is_waiting then return end
	if Inputs.released("interact") then
		if #self.pool_choice ~= 0 then
			self:select_choice()
		else
			self:proceed_dialogue()
		end
	elseif Inputs.pressed("left") then
		self:proceed_choices(-1)
	elseif Inputs.pressed("right") then
		self:proceed_choices(1)
	end
end

function Dialogues:player_interact(player, interactive)
	@@assert(player.__isEntity and player.player)
	@@assert(interactive.__isEntity and interactive.interactive and interactive.dialogue)
	local d = interactive.dialogue
	local t = DialoguesList.get(d.main, d.sub)
	local id = d.main .. "_" .. d.sub
	self:show_dialogue(id, t, interactive)
end

function Dialogues:dialogue_reached_end(e)
	@@assert(e.__isEntity)
	if e.choice_item then
		self:remove_choices()
	end
	if e.has_choices then
		e:give("hidden")
		self:show_choices(e)
	else
		local on_d_end = e.on_dialogue_end
		if on_d_end then
			self.world:emit(on_d_end.signal, unpack(on_d_end.args))
		else
			self.world:emit("on_leave_interact_or_inventory")
			self.world:emit("set_sys_inventory", true)
		end
	end
	e:destroy()
end

function Dialogues:show_choices(e)
	@@assert(e.__isEntity and e.has_choices)
	local d = e.dialogue
	local l, _, _, h = self.main_camera:getWindow()
	local c = e.has_choices
	local font = Resources.data.fonts.ui
	local y = h - h * 0.15 * 0.5
	local p2 = PAD * 2
	for i, str in ipairs(c.value) do
		local id = "choice_" .. str
		local fw = font:getWidth(str)
		local x = l + p2 + ((fw + p2) * (i - 1))
		local text_t = e.text_t.value.choices
		for _, v in ipairs(text_t) do
			if v[1] == str then
				text_t = tablex.copy(v)
				table.remove(text_t, 1)
				break
			end
		end
		local e_choice = Concord.entity(self.world):assemble(UI.choice,
				id, str, text_t, x, y)
			:give("reflowprint", fw + PAD * 2, "left")
			:give("dialogue", d.main, d.sub)
		self:populate_choices(e_choice, text_t)

		if i == 1 then
			self.world:emit("lerp_color", e_choice, c_hc, 0.25, "circin")
			e_choice:give("hovered_choice")
		end
	end
end

function Dialogues:populate_choices(e, t)
	@@assert(e.__isEntity)
	@@assert(type(t) == "table")
	local choices = {}
	if t.choices then
		for _, v in ipairs(t.choices) do
			insert(choices, v[1])
		end
	end
	if #choices ~= 0 then
		e:give("has_choices", unpack(choices))
	end
end

function Dialogues:proceed_choices(dx)
	local f = 0.25
	for i, e in ipairs(self.pool_choice) do
		if e.hovered_choice then
			local cur = mathx.wrap(i + dx, 1, #self.pool_choice + 1)
			if cur ~= i then
				e:remove("hovered_choice")
				self.world:emit("lerp_color", e, Palette.get("ui_dialogue"), f, "circin")
				local next_e = self.pool_choice[cur]:give("hovered_choice")
				self.world:emit("lerp_color", next_e, c_hc, f, "circin")
				break
			end
		end
	end
end

function Dialogues:check_signal(str)
	@@assert(type(str) == "string")
	local bool = stringx.starts_with(str, "_")
	local signal = str:sub(2, #str)
	return bool, signal
end

function Dialogues:select_choice()
	for _, e in ipairs(self.pool_choice) do
		if e.hovered_choice then
			local text_t = e.text_t.value
			if #text_t == 0 then
				self:dialogue_reached_end(e)
			else
				local str = text_t[1]
				local bool, signal = self:check_signal(str)
				if bool then
					self.world:emit(signal, e, text_t)
				else
					local id = e.id.value
					self:show_dialogue(id, text_t, e)
					self:remove_choices()
				end
			end
			break
		end
	end
end

function Dialogues:remove_choices()
	for _, e in ipairs(self.pool_choice) do
		e:destroy()
	end
end

function Dialogues:draw_dialogues()
	for _, e in ipairs(self.pool) do
		self.world:emit("draw_text_ex", e)
	end
	for _, e in ipairs(self.pool_choice) do
		self.world:emit("draw_text_ex", e)
	end
end

function Dialogues:cleanup()
	for _, e in ipairs(self.pool) do
		e:destroy()
	end
	self.main_camera = nil
end

return Dialogues

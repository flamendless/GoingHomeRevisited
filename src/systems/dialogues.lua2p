local Concord = require("modules.concord.concord")
local Timer = require("modules.hump.timer")

local DialoguesList = require("dialogues")
local Palette = require("palette")
local ScreenInfo = require("screen_info")

local Dialogues = Concord.system({
	pool_dialogue = {"id", "dialogue"},
})

local UI = require("assemblages.ui")

function Dialogues:init(world)
	self.world = world
	self.pos = nil
	self.font = nil

	self.timer = Timer()
	self.dur = 1
	self.lifetime = 2

	self.pool_dialogue.onEntityAdded = function(pool, e)
	end

	self.pool_dialogue.onEntityRemoved = function(pool, e)
		self.world:emit("destroyed_dialogue")
	end
end

function Dialogues:set_dialogue_config(t)
	!if _ASSERT then
	Assert.must(t, Types.T_TABLE)
	Assert.is(t.pos, Types.T_VEC2)
	Assert.must(t.font, Types.T_FONT)
	Assert.safe.must(t.dur, Types.T_NUMBER)
	Assert.safe.must(t.lifetime, Types.T_NUMBER)
	!end

	self.pos = t.pos or self.pos
	self.font = t.font
	self.dur = t.dur or self.dur
	self.lifetime = t.lifetime or self.lifetime
end

function Dialogues:show_dialogue(id, sub)
	!if _ASSERT then
	Assert.must(id, Types.T_STRING)
	Assert.must(sub, Types.T_STRING)
	Assert.exists(self.font)
	!end

	local text = DialoguesList.get_spec(id, sub)
	local pos = self.pos:copy()
	local e = Concord.entity(self.world)
		:assemble(UI.dialogue_text, "d_" .. id, text, self.font, pos)
		:give("reflowprint", ScreenInfo.w/2, "left")

	self.world:emit("show_text_paint", e, self.dur)
	self.world:emit("displayed_dialogue")
end

function DialoguesList:hide_dialogue(e)
	self.timer:after(self.lifetime, function()
		self.world:emit("fade_text_paint", e, self.dur)
		self.world:emit("fading_out_dialogue")
	end)
end

function Dialogues:update(dt)
	self.timer:update(dt)
end

function Dialogues:cleanup()
	for _, e in ipairs(self.pool) do
		e:destroy()
	end

	self.timer:clear()
end

return Dialogues

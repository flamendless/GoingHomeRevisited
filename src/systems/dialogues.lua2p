local Concord = require("modules.concord.concord")

local DialoguesList = require("dialogues")
local Inputs = require("inputs")

local Dialogues = Concord.system({
	pool_camera = {"camera"},
	pool = {"dialogue_item", "text_t"},
})

local UI = require("assemblages.ui")

function Dialogues:init(world)
	self.world = world
	self.main_camera = nil
	self.pool_camera.onAdded = function(pool, e)
		local camera = e.camera
		if camera.is_main then
			self.main_camera = camera.camera
		end
	end

	self.pool.onAdded = function(pool, e)
		local t = e.text_t
		e:give("text", t.value[t.current_index])
	end
end

function Dialogues:player_interact(player, interactive)
	@@assert(player.__isEntity and player.player)
	@@assert(interactive.__isEntity and interactive.interactive and interactive.dialogue)
	local d = interactive.dialogue
	self:show_dialogue(d.main, d.sub)
end

function Dialogues:show_dialogue(main, sub)
	@@assert(type(main) == "string")
	@@assert(type(sub) == "string")
	local dialogue = DialoguesList.get(main, sub)
	local l, _, w, h = self.main_camera:getWindow()
	local pad = 32
	local x = l + pad
	local y = h - h * 0.15 * 0.5
	Concord.entity(self.world):assemble(UI.dialogue_text,
			main .. "_" .. sub, dialogue, x, y)
		:give("reflowprint", w - pad * 2, "left")
end

function Dialogues:update(dt)
	if Inputs.released("interact") then
		for _, e in ipairs(self.pool) do
			local d = e.dialogue_item
			if d.can_proceed then
				local rfp = e.reflowprint
				local text_t = e.text_t
				local text = e.text
				rfp.dt = 0
				rfp.current = 1
				text_t.current_index = text_t.current_index + 1
				if text_t.current_index > text_t.max_n then
					self.world:emit("dialogue_finished", e)
				else
					text.value = text_t.value[text_t.current_index]
				end
			end
		end
	end
end

function Dialogues:dialogue_finished(e)
	@@assert(e.__isEntity)
	e:destroy()
end

function Dialogues:cleanup()
	for _, e in ipairs(self.pool) do
		e:destroy()
	end
end

return Dialogues

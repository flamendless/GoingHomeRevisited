local Concord = require("modules.concord.concord")
local TLE = require("modules.tle.timeline")

local Inputs = require("inputs")
local Resources = require("resources")
local Palette = require("palette")

local insert = table.insert
local remove = table.remove

local Dialogues = Concord.system({
	pool_camera = {"camera"},
	pool = {"dialogue_item", "text_t", "nf_render_text"},
	pool_choice = {"choice_item", "text_t", "nf_render_text"},
})

local UI = require("assemblages.ui")
local PAD = 32
local c_hc = Palette.get("hovered_choice")

function Dialogues:init(world)
	self.world = world
	self.camera = nil
	self.is_waiting = false
	self:create_e_dialogue()

	self.timeline = TLE.Do(function()
		while true do
			local text_t = self.e_dialogue.text_t
			local dialogues = text_t and text_t.value
			local current_line = dialogues and dialogues[text_t.current_index]

			if current_line then
				text_t.current_index = text_t.current_index + 1
				local should_pause = true
				local bool, signal, handle_self = self:check_signal(current_line)

				if bool then
					self.world:emit(signal, self.e_dialogue, dialogues)
					current_line = ""
					text_t.max_n = text_t.max_n - 1

					if text_t.current_index > text_t.max_n then
						should_pause = false
					end
				end

				if handle_self then
					self.e_dialogue:remove("text_can_proceed")
						:remove("hidden")
						:give("text", current_line)
				end

				if should_pause then
					self.timeline:Pause()
				end
			elseif text_t and (text_t.current_index > text_t.max_n) then
				self:on_dialogue_reached_end()
			else
				self.timeline:Pause()
			end
		end
	end)

	self.pool_camera.onAdded = function(pool, e)
		local camera = e.camera
		self.camera = camera.camera

		local l, _, w, h = self.camera:getWindow()
		local x = l + PAD
		local y = h - h * 0.15 * 0.5
		self.e_dialogue:give("reflowprint", w - PAD * 2, "left")
			:give("pos", x, y)
	end
end

function Dialogues:create_e_dialogue()
	self.e_dialogue = Concord.entity(self.world)
		:give("id", "dialogue_holder")
		:give("font", "ui")
		:give("color", Palette.get("ui_dialogue"))
		:give("dialogue_item")
		:give("ui_element")
		:give("transform", 0, 1, 1, 0, 0.5)
		:give("layer", "dialogue", 3)
		:give("nf_render_text")
end

function Dialogues:update(dt)
	if self.is_waiting then return end
	if Inputs.released("interact") then
		if #self.pool_choice == 0 then
			self:proceed_dialogue()
		else
			self:proceed_choice()
		end
	elseif Inputs.pressed("left") then
		self:update_choices(-1)
	elseif Inputs.pressed("right") then
		self:update_choices(1)
	end
end

function Dialogues:draw_dialogues()
	if self.e_dialogue.text then
		self.world:emit("draw_text_ex", self.e_dialogue)
	end
	for _, e in ipairs(self.pool_choice) do
		self.world:emit("draw_text_ex", e)
	end
end

function Dialogues:check_signal(str)
	@@assert(type(str) == "string")
	local bool = stringx.starts_with(str, "_")
	if not bool then
		return false, "", true
	end

	local handle_self = not stringx.starts_with(str, "__")
	local signal
	if handle_self then
		signal = str:sub(2, #str)
	else
		signal = str:sub(3, #str)
	end
	return bool, signal, handle_self
end

function Dialogues:wait_dialogue(bool)
	@@assert(type(bool) == "boolean")
	self.is_waiting = bool
end

function Dialogues:spawn_dialogue(dialogues_t, main, sub)
	@@assert(type(dialogues_t) == "table")
	@@assert(type(main) == "string")
	@@assert(type(sub) == "string")
	self.e_dialogue:give("dialogue_meta", main, sub)
		:give("text_t", dialogues_t)
	self:populate_choices(dialogues_t)
	self.world:emit("on_interact_or_inventory")
	self.timeline:Unpause()
end

function Dialogues:spawn_dialogue_ex(dialogue_t, signal_after, ...)
	@@assert(type(dialogue_t) == "table")
	@@assert(#dialogue_t ~= 0)
	@@sassert(signal_after, type(signal_after) == "string")
	self:spawn_dialogue(dialogue_t, "_none", "_none")
	if signal_after then
		self.e_dialogue:give("on_dialogue_end", signal_after, 0, ...)
	end
end

function Dialogues:on_dialogue_reached_end(e)
	if self.is_waiting then
		self.timeline:Pause()
		return
	end
	e = e or self.e_dialogue
	if e.choice_item then
		self:remove_choices()
	end
	if e.has_choices then
		e:give("hidden")
		self:show_choices()
	else
		local on_d_end = e.on_dialogue_end
		if on_d_end then
			self.world:emit(on_d_end.signal, unpack(on_d_end.args))
		else
			self.world:emit("on_leave_interact_or_inventory")
			self.world:emit("set_sys_inventory", true)
			e:remove("dialogue_meta")
				:remove("text_t")
				:remove("text")
				:remove("choice_item")
				:remove("has_choices")
		end
	end
	self.timeline:Pause()
end

function Dialogues:update_dialogues(new_dialogues_t)
	@@assert(type(new_dialogues_t) == "table")
	if not self.e_dialogue.choice_item then
		self.e_dialogue:give("text_t", new_dialogues_t)
		self.timeline:Unpause()
	else
		local d = self.e_dialogue.dialogue_meta
		self:spawn_dialogue(new_dialogues_t, d.main, d.sub)
	end
end

function Dialogues:proceed_dialogue()
	for _, e in ipairs(self.pool) do
		local rfp = e.reflowprint
		if e.text_skipped then
			e:remove("text_skipped")
		elseif e.text_can_proceed then
			rfp.dt = 0
			rfp.current = 1
			self.timeline:Unpause()
		end
	end
end

function Dialogues:show_choices()
	local d = self.e_dialogue.dialogue_meta
	local l, _, _, h = self.camera:getWindow()
	local c = self.e_dialogue.has_choices
	local font = Resources.data.fonts.ui
	local y = h - h * 0.15 * 0.5
	local p2 = PAD * 2
	local prev_x = l + p2
	for i, str in ipairs(c.value) do
		local id = "choice_" .. str
		local fw = font:getWidth(str)
		local x = prev_x
		prev_x = x + fw + p2
		local choice_t = self.e_dialogue.text_t.value.choices
		for _, v in ipairs(choice_t) do
			if v[1] == str then
				choice_t = tablex.copy(v)
				remove(choice_t, 1)
				break
			end
		end
		local e_choice = Concord.entity(self.world):assemble(UI.choice,
				id, str, choice_t, x, y)
			:give("reflowprint", fw + PAD * 2, "left")
			:give("dialogue_meta", d.main, d.sub)
		self:populate_choices(choice_t)

		if i == 1 then
			self.world:emit("lerp_color", e_choice, c_hc, 0.25, "circin")
			e_choice:give("hovered_choice")
		end
	end
end

function Dialogues:populate_choices(t)
	@@assert(type(t) == "table")
	local choices = {}
	if t.choices then
		for _, v in ipairs(t.choices) do
			insert(choices, v[1])
		end
	end
	if #choices ~= 0 then
		self.e_dialogue:give("has_choices", unpack(choices))
	end
end

function Dialogues:update_choices(dx)
	local f = 0.25
	for i, e in ipairs(self.pool_choice) do
		if e.hovered_choice then
			local cur = mathx.wrap(i + dx, 1, #self.pool_choice + 1)
			if cur ~= i then
				e:remove("hovered_choice")
				self.world:emit("lerp_color", e, Palette.get("ui_dialogue"), f, "circin")
				local next_e = self.pool_choice[cur]:give("hovered_choice")
				self.world:emit("lerp_color", next_e, c_hc, f, "circin")
				break
			end
		end
	end
end

function Dialogues:proceed_choice()
	for _, e in ipairs(self.pool_choice) do
		if e.hovered_choice then
			local t = e.text_t
			local text_t = t.value
			if #text_t == 0 and not text_t.choices then
				self:on_dialogue_reached_end(e)
			else
				local str = text_t[1]
				local proceed = true
				if str then
					local bool, signal, handle_self = self:check_signal(str)

					if bool then
						proceed = false
						self.world:emit(signal, e, text_t)
						if handle_self then
							t.current_index = t.current_index + 1
							local next_str = text_t[t.current_index]
							if not next_str then
								self:on_dialogue_reached_end(e)
							end
						end
					end
				end

				if proceed then
					local d = e.dialogue_meta
					self:remove_choices()
					self:spawn_dialogue(text_t, d.main, d.sub)
				end

				if not text_t.choices then
					self:remove_choices()
					self.e_dialogue:remove("has_choices")
				end
			end
			break
		end
	end
end

function Dialogues:remove_choices()
	for _, e in ipairs(self.pool_choice) do
		e:destroy()
	end
end

function Dialogues:cleanup()
	for _, e in ipairs(self.pool) do
		e:destroy()
	end
	for _, e in ipairs(self.pool_choice) do
		e:destroy()
	end
end

return Dialogues

local Concord = require("modules.concord.concord")
local Timer = require("modules.hump.timer")

local Inputs = require("inputs")

local pi = math.pi

local KeyEvent = Concord.system({
	pool_progress = {"hold", "hold_key", "arc"},
	pool = {"on_keypressed", "key_value"},
})

function KeyEvent:init(world)
	self.world = world
end

function KeyEvent:update(dt)
	for _, e in ipairs(self.pool_progress) do
		local hold = e.hold
		local key = e.hold_key.value
		local on_finished = e.hold_on_finish
		local arc = e.arc

		if Inputs.down(key) then
			hold.current_time = mathx.lerp(hold.current_time, hold.current_time + dt, 0.75)
			hold.is_held = true
		else
			hold.current_time = mathx.lerp(hold.current_time, 0, 0.25)
			hold.is_held = false
		end
		hold.was_held = Inputs.released(key)
		arc.end_angle = arc.start_angle + (hold.current_time * 2 * pi/hold.max_time)

		if hold.current_time >= hold.max_time then
			if on_finished then
				Timer.after(on_finished.delay, function()
					self.world:emit(on_finished.signal, unpack(on_finished.args))
				end)
			end
		end
	end

	for _, e in ipairs(self.pool) do
		local key = e.key_value.value
		local on_keypressed = e.on_keypressed
		if Inputs.pressed(key) then
			self.world:emit(on_keypressed.signal, e)
		end
	end
end

return KeyEvent

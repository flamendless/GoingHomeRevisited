local Concord = require("modules.concord.concord")
local Enum = require("modules.enum.enum")
local Flux = require("modules.flux.flux")
local Gamera = require("modules.gamera.gamera")
local Log = require("modules.log.log")
local Timer = require("modules.hump.timer")

local Canvas = require("canvas")
local Dissolve = require("dissolve")
local Fade = require("fade")
local Image = require("image")
local Inputs = require("inputs")
local MotionBlur = require("motion_blur")
local Palette = require("palette")
local Resources = require("resources")
local Save = require("save")

local insert = table.insert
local remove = table.remove
local max = math.max
local min = math.min
local format = string.format
local lower = string.lower
local gsub = string.gsub

local Assemblages = {
	Menu = require("assemblages.menu"),
}

local Menu = Concord.system({
	pool = {"option_key", "color", "pos", "text", "on_enter_menu"},
	pool_disabled = {"option_key", "option_disabled"},
	pool_opt = {"menu_opt"},
	pool_sub_opt = {"menu_sub_opt"},
	pool_desk = {"menu_desk"},
	pool_text = {"menu_text"},
})

local states = Enum("menu", "play", "settings", "about", "exit")
local offset_x = 64
local dur_in = 0.75
local dur_out = 0.5
local color_select = Palette.get("menu_select", 1)
local color_disabled = Palette.get("menu_disabled", 1)
local about_done = false
local ANGLE_UP = 90
local ANGLE_RIGHT = 0
local duration_show = 0.75
local duration_hide = 0.75
local duration_pos = 0.75
local tx = 176
local tools = !(_TOOLS)
local libs = !(_LIBS)
local options = {"Play", "Settings", "About", "Exit"}
local options_sub = {"Continue", "New Game"}

local function color_to_select(color)
	Flux.to(color.value, dur_in, {
			[1] = color_select[1],
			[2] = color_select[2],
			[3] = color_select[3],
			[4] = color_select[4]
		})
end

local function color_to_white(color)
	Flux.to(color.value, dur_out, {
			[1] = color.original[1],
			[2] = color.original[2],
			[3] = color.original[3],
			[4] = color.original[4],
		})
end

local function color_to_disabled(color)
	Flux.to(color.value, dur_out, {
			[1] = color_disabled[1],
			[2] = color_disabled[2],
			[3] = color_disabled[3],
			[4] = color_disabled[4]
		})
end

local about_template = {
	{"@COLOR"},
	{"A Game By:"},
	{!(_FULL_NAME_STUDIO .. "    " .. _TWITTER_STUDIO)},
	{""},

	{"@COLOR"},
	{"Programmer:"},
	{!(_FULL_NAME_DEVELOPER .. "    " .. _TWITTER_DEVELOPER)},
	{""},

	{"@COLOR"},
	{"Arts:"},
	{!(_FULL_NAME_ARTIST .. "    " .. _TWITTER_ARTIST)},
	{""},

	{"@COLOR"},
	{"Level Design:"},
	{!(_FULL_NAME_DESIGNER .. "    " .. _TWITTER_DESIGNER)},
	{""},

	--TODO add musician here
	{"@COLOR"},
	{"Music/Sound:"},
	{!(_FULL_NAME_MUSICIAN .. "    " .. _TWITTER_MUSICIAN)},
	{""},

	{"@LAYOUT:LEFT"},
	{"@COLOR"},
	{"TOOLS USED:"},
}

local function generate_about()
	local t = about_template
	for i = 1, #tools, 3 do
		local a = tools[i]
		local b = tools[i + 1] or ""
		local c = tools[i + 2] or ""
		if b ~= "" then a = a .. "," end
		if c ~= "" then b = b .. "," end
		local subt = {format("%s %s %s", a, b, c)}
		insert(t, subt)
	end

	insert(t, {"@LAYOUT:RIGHT"})
	insert(t, {"@COLOR"})
	insert(t, {"LIBRARIES USED:"})

	for i = 1, #libs, 4 do
		local a = libs[i]
		local b = libs[i + 1] or ""
		local c = libs[i + 2] or ""
		local d = libs[i + 3] or ""
		if b ~= "" then a = a .. "," end
		if c ~= "" then b = b .. "," end
		if d ~= "" then c = c .. "," end
		local subt = {format("%s %s %s %s", a, b, c, d)}
		insert(t, subt)
	end

	insert(t, {"@LAYOUT:CENTER"})
	insert(t, {""})
	insert(t, {"SPECIAL THANKS to the people at the LÃ¶ve Discord server"})
	insert(t, {
		"_IMAGES", "twitter", "discord", "website", "mail",
	})

	return t
end

function Menu:init(world)
	self.world = world
	self.cursor = 1
	self.prev_cursor = self.cursor
	self.current_page = 1
	self.keys = {}
	self.flags = {allow_cursor = false}
	self.transition = false
	self.is_sub_menu = false
	self.current_state = states.menu

	self.pool.onAdded = function(pool, e)
		if not e.option_disabled then
			local option_key = e.option_key
			local page = option_key.page
			if not self.keys[page] then
				self.keys[page] = {}
			end
			insert(self.keys[page], option_key.id)
		end
	end

	self.pool_disabled.onAdded = function(pool, e)
		local option_key = e.option_key
		local t = self.keys[option_key.page]
		for i = #t, 1, -1 do
			local key = t[i]
			if key == option_key.id then
				remove(t, key)
				break
			end
		end
	end
end

function Menu:state_setup()
	local ww, wh = love.graphics.getDimensions()
	local img_ff = Image.resize_image(Resources.data.images.flowfield)
	self.camera = Gamera.new(0, 0, ww * 2, wh * 2)
	self.camera:setWindow(0, 0, ww, wh)
	self.canvases = {}
	Canvas.init_canvases(self.canvases)
	self.mb = MotionBlur(self.canvases.main)
	self.dissolve = Dissolve(img_ff, 2)
	self:setup_menu()
end

function Menu:state_init()
	self:hide_main_menu(0.1)
	self:hide_sub_menu(0.1)

	Fade.set_color({0, 0, 0, 1})
	Fade.fade_in(function()
		self:allow_cursor(true)
		self:set_cursor(1)
		self.subtitle:remove("anchor")
		self:show_main_menu()
		self.world:emit("show_main_menu")
	end, 1.5, 0.25)
end

function Menu:state_update(dt)
	local dir = 0
	if Inputs.pressed("down") then
		dir = 1
	elseif Inputs.pressed("up") then
		dir = -1
	end

	if Inputs.pressed("interact") and not self.is_transition then
		self:enter_option()
	end
	self:update_cursor(dir)

	if Inputs.released("cancel") then
		self:menu_back()
	end

	local mx, my = love.mouse.getPosition()
	self.world:emit("update", dt)
	self.world:emit("check_mouse_hover", mx, my)
	self.world:emit("hover_effects")

	if self.current_state == states.settings and not self.mb.flag_process then
		self.world:emit("update_settings", dt)
	elseif self.current_state == states.exit then
		self.dissolve:update(dt)
	end
end

function Menu:state_draw()
	if self.current_state == states.menu or
		self.current_state == states.settings or
		self.current_state == states.about or
		self.current_state == states.play then

		self.canvases.main:attach()
		self.camera:attach()
			local l, t = self.camera:getVisible()
			self.world:emit("draw")
			if self.current_state == states.settings and not self.mb.flag_process then
				love.graphics.push()
				love.graphics.translate(l, t)
				self.world:emit("draw_settings")
				love.graphics.pop()
			end
			Fade.draw()
		self.camera:detach()
		self.canvases.main:detach()
		self.mb:post_process_draw()
		self.canvases.main:render()
	elseif self.current_state == states.exit then
		self.dissolve:draw(function()
			self.world:emit("draw")
		end)
	end
end

function Menu:setup_menu()
	local ww, wh = love.graphics.getDimensions()
	local bg_door = Resources.data.images.bg_door
	local bg_hallway = Resources.data.images.bg_hallway
	local title = Resources.data.images.title
	local subtitle = Resources.data.images.subtitle

	local bg_hw_w, bg_hw_h = bg_hallway:getDimensions()
	local bg_door_w, bg_door_h = bg_door:getDimensions()
	local title_w, title_h = title:getDimensions()
	local subt_w, subt_h = subtitle:getDimensions()

	local scale = min(ww/bg_door_w, wh/bg_door_h)
	local scale_hallway = min(ww/bg_hw_w, wh/bg_hw_h)
	local scale_title = min((bg_door_w * scale)/title_w, (bg_door_h * scale)/title_h)
	local scale_subt = min((title_w * scale_title)/subt_w, (title_h * scale)/subt_h)
	scale_subt = scale_subt * 0.75

	Concord.entity(self.world)
		:assemble(Assemblages.Menu.bg_door,
			ww * 1.5, wh * 0.5, scale, bg_door_w * 0.5, bg_door_h * 0.5)

	Concord.entity(self.world)
		:assemble(Assemblages.Menu.bg_hallway,
			ww * 0.5, wh * 1.5, scale_hallway, bg_hw_w * 0.5, bg_hw_h * 0.5)

	Concord.entity(self.world)
		:assemble(Assemblages.Menu.desk, ww, wh)

	!if _DEV then
	Concord.entity(self.world)
		:assemble(Assemblages.Menu.secret_title, 32, wh * 0.5)
		:give("color_fade_in", 5, 3)
	!end

	self.title = Concord.entity(self.world)
		:assemble(Assemblages.Menu.title, ww * 0.25, wh * 0.5 - 36,
			scale_title, title_w * 0.5, title_h * 0.5)

	self.subtitle = Concord.entity(self.world)
		:assemble(Assemblages.Menu.subtitle, ww * 0.25, wh * 1.5,
			self.title, scale_subt, subt_w * 0.5, subt_h * 0.5)

	local jamboree_fnt = "res/fonts/Jamboree.fnt"
	local jamboree_png = "res/fonts/Jamboree.png"
	local sdf_menu = love.graphics.newFontMSDF(jamboree_fnt, jamboree_png)
	local font_menu = Resources.data.fonts.menu
	local str_target_h = font_menu:getHeight()
	local str_h = sdf_menu:getHeight()
	local str_scale = str_target_h/str_h * 0.75
	local offset = 16
	local padding = 2

	for i, str in ipairs(options) do
		local lstr = lower(str)
		local str_w = sdf_menu:getWidth(str) * str_scale
		local x = self.canvases.bot.width - str_w - offset
		local y = self.canvases.bot.y + (i * str_h) + (padding * i) - offset
		local id = "text_" .. lstr

		Concord.entity(self.world)
			:assemble(Assemblages.Menu.option_item,
				id, str, jamboree_fnt, jamboree_png, x, y, str_scale, i, 1)
			:give("on_enter_menu", "on_" .. lstr, 0, lstr)
			:give("menu_opt")
	end

	for i, str in ipairs(options_sub) do
		local lstr = lower(str)
		lstr = gsub(lstr, "%s+", "")
		local str_w = sdf_menu:getWidth(str) * str_scale
		local x = self.canvases.bot.width - str_w - offset
		local y = self.canvases.bot.y + (i * str_h) + (padding * i) - offset
		local id = "text_sub_" .. lstr

		Concord.entity(self.world)
			:assemble(Assemblages.Menu.option_item,
				id, str, jamboree_fnt, jamboree_png, x, y, str_scale, i, 2)
			:give("on_enter_menu", "on_" .. lstr)
			:give("menu_sub_opt")
	end
end

function Menu:setup_about()
	local about = generate_about()
	!!local about_links = _ABOUT_LINKS
	local _, _, w, h = self.camera:getVisible()
	local base_x = w * 0.5
	local base_y = h + 16
	local layout = false
	local layout_base_y = 0
	local largest = 0
	local dt_color = false
	local color = Palette.get("about_normal")

	Concord.entity(self.world)
		:assemble(Assemblages.Menu.btn_back, 8, base_y)
		:give("on_click", 1, "menu_back")

	for i, el in ipairs(about) do
		if type(el[1]) == "string" and el[1] ~= "_IMAGES" then
			local str = el[1]
			local resource_id = el[2] or "about_20"
			local font = Resources.data.fonts[resource_id]
			local space = el[3]
			local str_w = font:getWidth(str)
			local str_h = font:getHeight(str)
			local x = base_x - str_w * 0.5
			local y = base_y
			if space then base_y = base_y + space end

			if str == "@LAYOUT:LEFT" then
				base_x = w * 0.25
				layout_base_y = base_y
				layout = true
			elseif str == "@LAYOUT:RIGHT" then
				base_x = w * 0.75
				layout_base_y = base_y
				layout = true
			elseif str == "@LAYOUT:CENTER" then
				base_x = w * 0.5
				base_y = largest
				layout = false
			elseif str == "@COLOR" then
				color = Palette.get("about_hint")
				dt_color = true
			else
				if layout then
					y = layout_base_y
					layout_base_y = layout_base_y + str_h
					largest = max(largest, layout_base_y)
				end
				local id = "about_text_" .. i
				Concord.entity(self.world):assemble(Assemblages.Menu.about_text,
					id, resource_id, str, x, y, color)
				if dt_color then
					color = Palette.get("about_normal")
					dt_color = false
				end
				if not layout then base_y = base_y + str_h end
			end

		elseif type(el[1] == "string") and el[1] == "_IMAGES" then
			base_x = w * 0.5
			base_y = h * 2
			local pad = 24
			local n = #el
			local n2 = (n - 1) * 0.5
			for i2 = 2, n do
				local id = "about_image_" .. (i + i2)
				local resource_id = el[i2]
				local image = Resources.data.images[resource_id]
				local iw, ih = image:getDimensions()

				local bx = base_x - (n2 * iw)
				local x = bx + (iw * (i2 - 2)) + pad * 0.5
				local y = base_y - ih * 0.5 - pad * 0.5
				Concord.entity(self.world):assemble(Assemblages.Menu.about_ext_link,
						id, resource_id, x, y)
					:give("on_click", 1, "open_url", about_links[i2])
			end
		end
	end
end

function Menu:show_main_menu()
	for _, e in ipairs(self.pool_opt) do
		e:remove("hidden")
		:give("target_color", Palette.get("white", 1), duration_show)
		:give("lerp_on_finish", "enable_main_menu")
		:give("move_to_original", duration_pos)
	end
end

function Menu:hide_main_menu(duration)
	@@sassert(duration, type(duration) == "number")
	for _, e in ipairs(self.pool_opt) do
		e:give("target_color", Palette.get("white", 0), duration or duration_hide)
		:give("lerp_on_finish", "hide_entity", 0, e)
		:give("move_by", tx, 0, duration or duration_pos)
	end
end

function Menu:show_sub_menu()
	local next_cursor = (Save.valid_checkpoints == true) and 1 or 2
	for i, e in ipairs(self.pool_sub_opt) do
		e:remove("hidden")
		:give("target_color", Palette.get("white", 1), duration_show)
		:give("lerp_on_finish", "enable_sub_menu", 0, next_cursor)
		:give("move_to_original", duration_pos)

		if next_cursor == 2 and i == 1 then
			e:give("option_disabled")
		end
	end
	self:set_page(2)
end

function Menu:hide_sub_menu(duration)
	@@sassert(duration, type(duration) == "number")
	for _, e in ipairs(self.pool_sub_opt) do
		e:give("target_color", Palette.get("white", 0), duration or duration_hide)
		:give("lerp_on_finish", "hide_entity", 0, e)
		:give("move_by", tx, 0, duration or duration_pos)
	end
end

function Menu:on_menu()
	self:allow_cursor(true)
	self:set_to_prev_cursor()
	self:set_page(1)
end

function Menu:on_play()
	self.is_transition = true
	self.is_sub_menu = true
	self:allow_cursor(false)
	self:hide_main_menu()
	self:show_sub_menu()
end

function Menu:enable_main_menu()
	self:on_menu()
	self.is_transition = false
end

function Menu:enable_sub_menu(next_cursor)
	@@assert(type(next_cursor) == "number")
	self:allow_cursor(true)
	self:set_cursor(next_cursor)
	self.is_transition = false
end

function Menu:set_page(page)
	@@assert(type(page) == "number")
	@@assert(self.keys[page])
	self.current_page = page
	self:update_cursor_color()
end

function Menu:allow_cursor(flag)
	@@assert(type(flag) == "boolean")
	self.flags.allow_cursor = flag
end

function Menu:set_cursor(cursor)
	@@assert(type(cursor) == "number")
	self.cursor = cursor
	self:update_cursor_color()
end

function Menu:set_to_prev_cursor()
	self.cursor = self.prev_cursor
	self:update_cursor_color()
end

function Menu:update_cursor(dt)
	if dt == 0 then return end
	if not self.flags.allow_cursor then return end
	local t = self.keys[self.current_page]
	if dt > 0 then
		self.cursor = t[self.cursor + 1] or t[1]
	elseif dt < 0 then
		self.cursor = t[self.cursor - 1] or t[#t]
	end
	self:update_cursor_color()
end

function Menu:update_cursor_color()
	for _, e in ipairs(self.pool) do
		local option_key = e.option_key
		local pos = e.pos
		local color = e.color
		local disabled = e.option_disabled

		if self.current_page == option_key.page then
			if disabled then
				color_to_disabled(color)
			else
				if self.cursor == option_key.id then
					color_to_select(color)
					Flux.to(pos, dur_in, {x = pos.orig_x - offset_x})
				else
					color_to_white(color)
					Flux.to(pos, dur_out, {x = pos.orig_x})
				end
			end
		end
	end
end

function Menu:enter_option()
	if self.cursor == 0 then return end
	if not self.flags.allow_cursor then return end
	for _, e in ipairs(self.pool) do
		local option_key = e.option_key
		local cb_on_menu = e.on_enter_menu
		local menu_opt = e.menu_opt

		if self.current_page == option_key.page then
			for _, key in ipairs(self.keys[self.current_page]) do
				if key == option_key.id and key == self.cursor then
					self.prev_cursor = option_key.id
					if cb_on_menu then
						self.world:emit(cb_on_menu.signal)
						if menu_opt then
							self.current_state = cb_on_menu.args[1]
						end
					end
					return
				end
			end
		end
	end
end

function Menu:on_newgame()
	local ww, wh = love.graphics.getDimensions()
	local dur = 2
	local timer = 1.25
	-- TODO turn off BGM

	self:hide_sub_menu()
	for _, e in ipairs(self.pool_desk) do
		e:give("hidden")
	end

	--TODO change target_color
	for _, e in ipairs(self.pool_text) do
		e:give("target_color", Palette.get("white", 0), dur)
	end

	local e_desk_fast = Concord.entity(self.world)
		:assemble(Assemblages.Menu.desk_fast, ww, wh)

	Timer.after(timer, function()
		-- TODO add sudden static sound
		e_desk_fast:give("hidden")
		Timer.after(timer, function()
			self.world:emit("switch_state", "Intro")
		end)
	end)
end

function Menu:on_continue()
	-- TODO load saved game here
end

function Menu:on_settings()
	local l, t, w, h = self.camera:getWorld()
	local cworld = {x = l, y = t, w = w, h = h}

	self:allow_cursor(true)
	self.world:emit("init_settings")
	self:MB_move(cworld.w, nil, ANGLE_RIGHT)
end

function Menu:on_about()
	local l, t, w, h = self.camera:getWorld()
	local cworld = {x = l, y = t, w = w, h = h}

	if not about_done then
		self:setup_about()
		about_done = true
	end

	self.world:emit("allow_cursor", false)
	self:MB_move(nil, cworld.h, ANGLE_UP)
end

function Menu:on_exit()
	self.world:emit("allow_cursor", false)
	!if _PLATFORM == "desktop" then
	local btn = love.window.showMessageBox("Alert",
		"Are you sure you want to exit the game?",
		{"Exit", "Cancel", escapebutton = 2})

	if btn == 1 then
		self:hide_main_menu()
		self.dissolve.flag_process = true
		self.dissolve.on_complete = function()
			love.event.quit()
		end
	elseif btn == 2 then
		self.current_state = states.menu
		Log.info("Switched Menu State to: ", self.current_state)
		self:on_menu()
	end
	!end
end

function Menu:menu_back()
	if self.current_state == states.play and self.is_sub_menu and
		not self.is_transition then
		self.is_transition = true
		self.is_sub_menu = false
		self:allow_cursor(false)
		self:hide_sub_menu()
		self:show_main_menu()
	elseif self.current_state ~= states.menu and self.current_state ~= states.play then
		self:MB_return()
	end
end

function Menu:MB_move(tx, ty, angle)
	-- TODO add motion blur sound
	local cx, cy = self.camera:getPosition()
	local cpos = {x = cx, y = cy}
	local duration = 1
	local distance = {1.0}
	local prev_angle = (angle + 180) % 360

	self.mb.flag_process = true
	Flux.to(cpos, duration, {x = tx, y = ty})
		:onstart(function()
			self.mb:store_previous(cx, cy, prev_angle)
			self.mb:set_angle(angle)
			Flux.to(distance, duration, {[1] = 0.0})
				:onupdate(function()
					self.mb:set_strength(distance[1])
				end)
		end)
		:onupdate(function()
			self.camera:setPosition(cpos.x, cpos.y)
			self.world:emit("on_camera_move", self.camera)
		end)
		:oncomplete(function()
			self.mb.flag_process = false
		end)
end

function Menu:MB_return()
	-- TODO add motion blur sound
	local cx, cy = self.camera:getPosition()
	local cpos = vec2(cx, cy)
	local duration = 1
	local distance = {1.0}
	local temp_mb = self.mb.previous

	self.mb.flag_process = true
	Flux.to(cpos, duration, {x = temp_mb.target.x, y = temp_mb.target.y})
		:onstart(function()
			self.mb:set_angle(temp_mb.angle)
			Flux.to(distance, duration, {[1] = 0.0})
				:onupdate(function()
					self.mb:set_strength(distance[1])
				end)
		end)
		:onupdate(function()
			self.camera:setPosition(cpos.x, cpos.y)
			self.world:emit("on_camera_move", self.camera)
		end)
		:oncomplete(function()
			self.current_state = states.menu
			Log.info("Switched Menu State to: ", self.current_state)
			self.mb.flag_process = false
			self:on_menu()
		end)
end

function Menu:state_mousepressed(mx, my, mb)
	self.world:emit("mousepressed", mx, my, mb)
end

function Menu:open_url(str)
	@@assert(type(str) == "string")
	love.system.openURL(str)
end

return Menu

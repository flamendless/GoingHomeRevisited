local Concord = require("modules.concord.concord")
local Flux = require("modules.flux.flux")

local Utils = require("utils")

local min = math.min
local max = math.max

local Menu = Concord.system({
	pool = {"option_key", "color", "position", "text", "on_enter", "option_data"}
})

local offset_x = 64
local dur_in = 0.75
local dur_out = 0.5
local color_red = { 1, 0, 0, 1 }

local color_to_red = function(color)
	Flux.to(color.color, dur_in, {
		[1] = color_red[1],
		[2] = color_red[2],
		[3] = color_red[3],
		[4] = color_red[4]
	})
end

local color_to_white = function(color)
	Flux.to(color.color, dur_out, {
		[1] = color.original_color[1],
		[2] = color.original_color[2],
		[3] = color.original_color[3],
		[4] = color.original_color[4],
	})
end

function Menu:init()
	self.cursor = 0
	self.length_options = 0
	self.flags = {
		allow_cursor = true,
	}

	self.pool.onEntityAdded = function(pool, e)
		self.length_options = self.length_options + 1
		self:menu_set_position()
	end
end

function Menu:menu_set_position()
	for _, e in ipairs(self.pool) do
		local pos = e:get("position")
		local text = e:get("text")
		local data = e:get("option_data")
		local key = e:get("option_key")
		local fonts = e:get("fonts")
		local font = text.font
		local padding = data.padding

		local font = text.font
		do
			local canvas = data.canvas
			local ch = canvas.height

			local highest = 100
			local font_id
			for k, v in pairs(fonts.fonts) do
				local str_h = v:getHeight(text.text)
				local total_h = str_h * data.max_count
				local result = ch - total_h
				if result >= padding then
					highest = min(highest, result)
					font = v
					font_id = k
				end
			end
			if text.font ~= font then
				local scale = canvas.width/canvas.height
				padding = padding - scale * 2
			end
			text.font = font
		end

		local str_w = font:getWidth(text.text)
		local str_h = font:getHeight(text.text)
		local x = data.canvas.width - str_w - padding
		local y = data.canvas.y + data.canvas.height - (key.id * str_h) - padding
		pos.pos.x = x
		pos.pos.y = y
		pos.original_pos = pos.pos:copy()
	end
end

function Menu:check_size()
	for _, e in ipairs(self.pool) do
		local pos = e:get("position")
		local text = e:get("text")
		local data = e:get("option_data")
		local key = e:get("option_key")
		local fonts = e:get("fonts")

	end
end

function Menu:allow_cursor(flag)
	self.flags.allow_cursor = flag
end

function Menu:update_cursor(dt)
	if dt == 0 then return end
	if not self.flags.allow_cursor then return end
	self.cursor = self.cursor + dt
	if self.cursor > self.length_options then
		self.cursor = 1
	elseif self.cursor < 1 then
		self.cursor = self.length_options
	end

	for _, e in ipairs(self.pool) do
		local option_key = e:get("option_key")
		local pos = e:get("position")
		local color = e:get("color")

		if self.cursor == option_key.id then
			color_to_red(color)
			Flux.to(pos.pos, dur_in, {
				x = pos.original_pos.x - offset_x
			})
		else
			color_to_white(color)
			Flux.to(pos.pos, dur_out, {
				x = pos.original_pos.x
			})
		end
	end
end

function Menu:enter_option()
	if self.cursor == 0 then return end
	if not self.flags.allow_cursor then return end
	for _, e in ipairs(self.pool) do
		local option_key = e:get("option_key")
		local text = e:get("text")
		local callback = e:get("on_enter")

		if option_key.id == self.cursor then
			callback.callback()
			break
		end
	end
end

return Menu

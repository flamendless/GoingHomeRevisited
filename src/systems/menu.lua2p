local Concord = require("modules.concord.concord")
local Flux = require("modules.flux.flux")

local Palette = require("palette")

local insert = table.insert
local remove = table.remove

local Menu = Concord.system({
	pool = {"option_key", "color", "position", "text", "on_enter"},
	pool_disabled = {"option_key", "option_disabled"}
})

local offset_x = 64
local dur_in = 0.75
local dur_out = 0.5
local color_red = Palette.get("red", 1)
local color_disabled = Palette.get("disabled", 1)

local function color_to_red(color)
	Flux.to(color.color, dur_in, {
			[1] = color_red[1],
			[2] = color_red[2],
			[3] = color_red[3],
			[4] = color_red[4]
		})
end

local function color_to_white(color)
	Flux.to(color.color, dur_out, {
			[1] = color.original_color[1],
			[2] = color.original_color[2],
			[3] = color.original_color[3],
			[4] = color.original_color[4],
		})
end

local function color_to_disabled(color)
	Flux.to(color.color, dur_out, {
			[1] = color_disabled[1],
			[2] = color_disabled[2],
			[3] = color_disabled[3],
			[4] = color_disabled[4]
		})
end

function Menu:init()
	self.cursor = 1
	self.prev_cursor = self.cursor
	self.current_page = 1
	self.keys = {}
	self.flags = {allow_cursor = false}

	self.pool.onEntityAdded = function(pool, e)
		if not e.option_disabled then
			local option_key = e.option_key
			local page = option_key.page

			if not self.keys[page] then
				self.keys[page] = {}
			end

			insert(self.keys[page], option_key.id)
		end
	end

	self.pool_disabled.onEntityAdded = function(pool, e)
		local option_key = e.option_key
		local t = self.keys[option_key.page]

		for i = #t, 1, -1 do
			local key = t[i]

			if key == option_key.id then
				remove(t, key)

				break
			end
		end
	end
end

function Menu:set_page(page)
	!if _ASSERT then
	Assert.must(page, Types.T_NUMBER)
	Assert.should(self.keys[page])
	!end

	self.current_page = page
	self:update_cursor_color()
end

function Menu:allow_cursor(flag)
	!if _ASSERT then
	Assert.must(flag, Types.T_BOOLEAN)
	!end

	self.flags.allow_cursor = flag
end

function Menu:set_cursor(cursor)
	!if _ASSERT then
	Assert.must(cursor, Types.T_NUMBER)
	!end

	self.cursor = cursor
	self:update_cursor_color()
end

function Menu:set_to_prev_cursor()
	self.cursor = self.prev_cursor
	self:update_cursor_color()
end

function Menu:update_cursor(dt)
	if dt == 0 then return end

	if not self.flags.allow_cursor then return end

	local t = self.keys[self.current_page]

	if dt > 0 then
		self.cursor = t[self.cursor + 1] or t[1]
	elseif dt < 0 then
		self.cursor = t[self.cursor - 1] or t[#t]
	end

	self:update_cursor_color()
end

function Menu:update_cursor_color()
	for _, e in ipairs(self.pool) do
		local option_key = e.option_key
		local pos = e.position
		local color = e.color
		local disabled = e.option_disabled

		if self.current_page == option_key.page then
			if disabled then
				color_to_disabled(color)
			else
				if self.cursor == option_key.id then
					color_to_red(color)
					Flux.to(pos.pos, dur_in, {x = pos.original_pos.x - offset_x})
				else
					color_to_white(color)
					Flux.to(pos.pos, dur_out, {x = pos.original_pos.x})
				end
			end
		end
	end
end

function Menu:enter_option()
	if self.cursor == 0 then return end

	if not self.flags.allow_cursor then return end

	for _, e in ipairs(self.pool) do
		local option_key = e.option_key
		local text = e.text
		local callback = e.on_enter
		local t = self.keys[self.current_page]

		if self.current_page == option_key.page then
			for i, key in ipairs(self.keys[self.current_page]) do
				if key == option_key.id and key == self.cursor then
					self.prev_cursor = option_key.id
					callback.callback()

					return
				end
			end
		end
	end
end

return Menu

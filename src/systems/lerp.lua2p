local Concord = require("modules.concord.concord")
local Flux = require("modules.flux.flux")

local Lerp = Concord.system({
	pool_colors = {"color", "lerp_colors"},
	pool_fade_to_black = {"color", "fade_to_black"},
	pool_pos = {"position", "target_position"},
	pool_color = {"color", "target_color"},
})

function Lerp:init()
	self.pool_pos.onEntityAdded = function(pool, e)
		local pos = e:get("position")
		local target = e:get("target_position")
		local on_complete = e:get("lerp_on_complete")
		local f = Flux.to(pos.pos, target.duration, {
			x = target.target_pos.x,
			y = target.target_pos.y,
		})
		:delay(target.delay)
		:oncomplete(function()
			if on_complete then
				on_complete.callback()
				e:remove("lerp_on_complete")
			end
			e:remove("target_position")
		end)
	end

	self.pool_color.onEntityAdded = function(pool, e)
		local color = e:get("color")
		local target = e:get("target_color")
		local on_complete = e:get("lerp_on_complete")
		Flux.to(color.color, target.duration, {
			[1] = target.target_color[1],
			[2] = target.target_color[2],
			[3] = target.target_color[3],
			[4] = target.target_color[4],
		})
		:delay(target.delay)
		:oncomplete(function()
			if on_complete then
				on_complete.callback()
				e:remove("lerp_on_complete")
			end
			e:remove("target_color")
		end)
	end
end

function Lerp:start_fade()
	for _, e in ipairs(self.pool_fade_to_black) do
		local color = e:get("color")
		local fade = e:get("fade_to_black")
		Flux.to(color.color, fade.duration, {
			[1] = 0,
			[2] = 0,
			[3] = 0,
			[4] = 0,
		}):delay(fade.delay)
	end
end

function Lerp:start_colors_lerp()
	for _, e in ipairs(self.pool_colors) do
		local color = e:get("color")
		local lc = e:get("lerp_colors")

		local lerp_colors
		lerp_colors = function(duration, delay)
			local current = lc.colors[lc.current_color]
			local next_value = lc.current_color + 1
			if next_value > #lc.colors then
				next_value = 1
			end
			local next_color = lc.colors[next_value]
			Flux.to(color.color, duration, {
				[1] = next_color[1],
				[2] = next_color[2],
				[3] = next_color[3],
				[4] = next_color[4],
			}):delay(delay):oncomplete(function()
				lc.current_color = next_value
				if lc.current_color > #lc.colors then
					lc.current_color = 1
				end
				lerp_colors(duration, delay)
			end)
		end
		lerp_colors(lc.duration, lc.delay)
	end
end

return Lerp

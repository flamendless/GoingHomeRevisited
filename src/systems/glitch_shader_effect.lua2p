local Concord = require("modules.concord.concord")

local GlitchShaderEffect = Concord.system({
	pool = {"glitch_shader", "displacement_texture", "use_canvas"},
})

!if _DEV then
local debug_values = {
	u_dis_amount = 0.1,
	u_dis_size = 0.1,
	u_abb_amount_x = 0.1,
	u_abb_amount_y = 0.1,
	u_max_a = 0.5,
}
!end

local reset_tbl = {
	u_dis_amount = 0,
	u_dis_size = 0.1,
	u_abb_amount_x = 0,
	u_abb_amount_y = 0,
	u_max_a = 1.0,
}

function GlitchShaderEffect:init(world)
	self.world = world
	self.is_active = false
	self.pool.onAdded = function(pool, e)
		self:setup_shader(e)
	end
end

function GlitchShaderEffect:set_glitch_effect(bool)
	@@assert(type(bool) == "boolean")
	self.is_active = bool
end

function GlitchShaderEffect:setup_shader(e)
	local gs = e.glitch_shader
	local shader = gs.shader
	local displacement_tex = e.displacement_texture.texture
	shader:send("u_tex_displace", displacement_tex)
	self:update_values_e(e, gs.values)
end

function GlitchShaderEffect:update_values_e(e, new_values)
	if not self.is_active then return end
	local gs = e.glitch_shader
	local shader = gs.shader
	local values = gs.values
	for k, v in pairs(new_values) do
		values[k] = v
		shader:send(k, v)
		!if _DEV then
		debug_values[k] = v
		!end
	end
end

function GlitchShaderEffect:do_random_glitch(e)
	@@assert(e.__isEntity and e.glitch_shader)
	if not self.pool:has(e) then return end
	self:update_values_e(e, {
		u_dis_amount = love.math.random() * 0.1,
		u_dis_size = love.math.random() * 2.0,
		u_abb_amount_x = love.math.random() * 0.1,
		u_abb_amount_y = love.math.random() * 0.1,
		u_max_a = love.math.random() * 1.0 + 0.5,
	})
end

function GlitchShaderEffect:reset_glitch(e)
	@@assert(e.__isEntity and e.glitch_shader)
	if not self.pool:has(e) then return end
	self:update_values_e(e, reset_tbl)
end

function GlitchShaderEffect:draw_glitch_effect()
	if not self.is_active then return end
	love.graphics.setColor(1, 1, 1, 1)
	for _, e in ipairs(self.pool) do
		local canvas = (e.use_canvas and e.use_canvas.canvas)
		local shader = e.glitch_shader.shader
		love.graphics.setShader(shader)
		love.graphics.draw(canvas)
		love.graphics.setShader()
	end
end

!if _DEV then
local Slab = require("modules.slab")

local opt_slider = {
	ReturnOnText = false,
	NumbersOnly = true,
	Precision = 2,
}

function GlitchShaderEffect:debug_slider(id, min, max)
	local val = debug_values[id]
	Slab.Text(id)
	Slab.SameLine()
	if Slab.InputNumberSlider(id, val, min, max, opt_slider) then
		local t = {}
		t[id] = Slab.GetInputNumber()
		for _, e in ipairs(self.pool) do
			self:update_values_e(e, t)
		end
	end
end

function GlitchShaderEffect:debug_update(dt)
	if not self.debug_show then return end
	self.debug_show = Slab.BeginWindow("glitch_shader", {
		Title = "Glitch Shader",
		IsOpen = self.debug_show,
	})
	self:debug_slider("u_dis_amount", 0, 0.1)
	self:debug_slider("u_dis_size", 0.1, 2.0)
	self:debug_slider("u_abb_amount_x", 0, 0.1)
	self:debug_slider("u_abb_amount_y", 0, 0.1)
	self:debug_slider("u_max_a", 0.1, 1.0)
	if Slab.Button("do_random_glitch") then
		for _, e in ipairs(self.pool) do
			self:do_random_glitch(e)
		end
	end
	Slab.EndWindow()
end
!end

return GlitchShaderEffect

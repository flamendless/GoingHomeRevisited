local Concord = require("modules.concord.concord")
local Timer = require("modules.hump.timer")

local Dialogues = require("dialogues")
local Inputs = require("inputs")

local PlayerController = Concord.system({
	pool = {"player_controller", "body", "collider"},
})

function PlayerController:init(world)
	self.world = world

	self.pool.onAdded = function(pool, e)
		@@assert(self.player == nil, "Player already exists")
		self.player = e
	end
end

function PlayerController:player_can_move(bool, e_player)
	@@assert(type(bool) == "boolean")
	@@assert(e_player ~= nil or self.player ~= nil)
	@@sassert(e_player, e_player.__isEntity and e_player.player)
	local e = e_player or self.player
	e.body.can_move = bool
end

function PlayerController:player_can_run(bool, e_player)
	@@assert(type(bool) == "boolean")
	@@assert(e_player ~= nil or self.player ~= nil)
	@@sassert(e_player, e_player.__isEntity and e_player.player)
	local e = e_player or self.player
	e.body.can_run = bool
end

function PlayerController:player_can_interact(bool, e_player)
	@@assert(type(bool) == "boolean")
	@@assert(e_player ~= nil or self.player ~= nil)
	@@sassert(e_player, e_player.__isEntity and e_player.player)
	local e = e_player or self.player
	if bool then
		e:give("can_interact")
	else
		e:remove("can_interact")
	end
end

function PlayerController:update(dt)
	local e = self.player
	if not e then return end
	if e.override_animation then return end
	if not e.body.can_move then return end
	local within_int = e.within_interactive
	local can_interact = e.can_interact
	local body = e.body

	body.dx = 0

	if body.can_run then
		body.is_run = Inputs.down("run_mod")
	end

	if Inputs.down("left") then
		body.dir = -1
		body.dx = -1
	elseif Inputs.down("right") then
		body.dir = 1
		body.dx = 1
	end

	local offset = e.fl_spawn_offset
	local offset_t = e.fl_spawn_offset_dir
	if body.dir == -1 then
		offset.x = offset_t.left
	else
		offset.x = offset_t.right
	end

	if Inputs.pressed("interact") then
		if can_interact and within_int then
			local other = within_int.entity
			local req = other.req_col_dir
			local proceed = true

			if req and (body.dir ~= req.value) then
				proceed = false
			end

			if proceed then
				if other.dialogue_meta then
					self:on_player_interact(e, other)
				elseif other.is_door then
					self.world:emit("on_interact_door", e, other)
				end
			end
		end
	end

	local anim_name = self:player_update_animation(e)
	self:update_speed(e, anim_name)
end

function PlayerController:player_update_animation(e, override_name, override_variant)
	local anim_name = override_name
	local anim_variant = override_variant
	local body = e.body

	if not anim_name then
		if body.dx ~= 0 and not e.hit_wall then
			if body.is_run then
				anim_name = "run"
			else
				anim_name = "walk"
			end
		else
			anim_name = "idle"
		end
	end

	if not anim_variant then
		if body.dir == -1 then
			anim_variant = "_left"
		end
	end

	if anim_variant then
		self.world:emit("switch_animation_tag", e, anim_name .. anim_variant)
	else
		self.world:emit("switch_animation_tag", e, anim_name)
	end

	return anim_name
end

function PlayerController:update_speed(e, anim_name)
	local speed = e.speed
	local speed_data = e.speed_data

	if speed and speed_data then
		local body = e.body
		local new_speed = speed_data.speed_data[anim_name]

		if body.dx ~= 0 then
			local speed_dt = mathx.lerp(speed.vx, new_speed.x, 0.5)
			speed.vx = speed_dt
		end
	end
end

function PlayerController:face_left(e)
	@@assert(e.__isEntity and e.player_controller)
	if e.override_animation then return end
	e.body.dir = -1
	self:player_update_animation(e, "idle", "_left")
end

function PlayerController:face_right(e)
	@@assert(e.__isEntity and e.player_controller)
	if e.override_animation then return end
	e.body.dir = 1
	self:player_update_animation(e, "idle")
end

function PlayerController:idle(e, stop)
	@@assert(e.__isEntity and e.player_controller)
	if e.override_animation then return end
	local body = e.body
	if body.dir == -1 then
		self:player_update_animation(e, "idle", "_left")
	else
		self:player_update_animation(e, "idle")
	end

	if stop then
		body.dx = 0
		body.vel_x = 0
		body.vel_y = 0
	end
end

function PlayerController:player_open_door()
	local e = self.player
	local tag = (e.body.dir == -1) and "open_door_left" or "open_door"
	e:give("change_animation_tag", tag)
	:give("override_animation")
	e:give("animation_on_loop", "anim_pause_at_end", 0, e)
end

function PlayerController:player_open_locked_door()
	local e = self.player
	local tag = (e.body.dir == -1) and "open_door_reverse_left" or "open_door_reverse"
	e:give("change_animation_tag", tag)
	:give("override_animation")
	e:give("animation_on_loop", "anim_pause_at_end", 0, e)
end

function PlayerController:on_player_interact(player, interactive)
	@@assert(player.__isEntity and player.player)
	@@assert(interactive.__isEntity and interactive.interactive)
	player:give("is_interacting")
	self.world:emit("on_interact_or_inventory")
	self.world:emit("create_speech_bubble", player)
	local d = interactive.dialogue_meta
	local dialogues_t = Dialogues.get(d.main, d.sub)
	self.world:emit("spawn_dialogue", dialogues_t, d.main, d.sub)
end

function PlayerController:on_interact_or_inventory()
	local e = self.player
	if not e.prev_body then
		local body = e.body
		local can_interact = e.can_interact
		e:give("prev_body", body.can_move, body.can_run, can_interact ~= nil)
		self:idle(e, true)
	end
	self:player_can_run(false)
	self:player_can_move(false)
	self:player_can_interact(false)
end

function PlayerController:on_leave_interact_or_inventory(_)
	local e = self.player
	local body = e.body
	local prev_body = e.prev_body
	body.can_move = prev_body.can_move
	body.can_run = prev_body.can_run
	if prev_body.can_interact then
		Timer.after(0.5, function()
			e:give("can_interact")
			:remove("is_interacting")
		end)
	end
	e:remove("prev_body")
	self.world:emit("remove_speech_bubble")
end

function PlayerController:player_reset_anim(e)
	@@assert(e.__isEntity and e.player)
	e:remove("override_animation")
	:remove("change_animation_tag")
	:remove("animation_on_loop")
	local anim = e.animation
	anim.is_playing = true
	anim.anim8:resume()
end

return PlayerController

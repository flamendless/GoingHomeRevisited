local Concord = require("modules.concord.concord")

local Inputs = require("inputs")

local PlayerController = Concord.system({
	pool = {"player_controller", "body", "collider"},
})

function PlayerController:init(world)
	self.world = world
end

function PlayerController:player_can_move(bool)
	@@assert(type(bool) == "boolean")
	@@assert(#self.pool ~= 0)
	for _, e in ipairs(self.pool) do
		e.body.can_move = bool
	end
end

function PlayerController:player_can_run(bool)
	@@assert(type(bool) == "boolean")
	@@assert(#self.pool ~= 0)
	for _, e in ipairs(self.pool) do
		e.body.can_run = bool
	end
end

function PlayerController:player_can_interact(bool)
	@@assert(type(bool) == "boolean")
	@@assert(#self.pool ~= 0)
	for _, e in ipairs(self.pool) do
		if bool then
			e:give("can_interact")
		else
			e:remove("can_interact")
		end
	end
end

function PlayerController:update(dt)
	for _, e in ipairs(self.pool) do
		if e.override_animation then return end
		if not e.body.can_move then return end
		local within_interactive = e.within_interactive
		local can_interact = e.can_interact
		local body = e.body

		body.dx = 0

		if body.can_run then
			body.is_run = Inputs.down("run_mod")
		end
		if Inputs.down("left") then
			body.dir = -1
			body.dx = -1
		elseif Inputs.down("right") then
			body.dir = 1
			body.dx = 1
		end

		if Inputs.pressed("interact") then
			if can_interact and within_interactive then
				self.world:emit("player_interact", e, within_interactive.entity)
			end
		end

		local anim_name = self:player_update_animation(e)
		self:update_speed(e, anim_name)
	end
end

function PlayerController:player_update_animation(e, override_name, override_variant)
	local anim_name = override_name
	local anim_variant = override_variant
	local body = e.body

	if not anim_name then
		if body.dx ~= 0 then
			if body.is_run then
				anim_name = "run"
			else
				anim_name = "walk"
			end
		else
			anim_name = "idle"
		end
	end

	if not anim_variant then
		if body.dir == -1 then
			anim_variant = "_left"
		end
	end

	if anim_variant then
		self.world:emit("switch_animation_tag", e, anim_name .. anim_variant)
	else
		self.world:emit("switch_animation_tag", e, anim_name)
	end

	return anim_name
end

function PlayerController:update_speed(e, anim_name)
	local speed = e.speed
	local speed_data = e.speed_data

	if speed and speed_data then
		local body = e.body
		local new_speed = speed_data.speed_data[anim_name]

		if body.dx ~= 0 then
			local speed_dt = mathx.lerp(speed.vx, new_speed.x, 0.5)
			speed.vx = speed_dt
		end
	end
end

function PlayerController:face_left(e)
	@@assert(e.__isEntity and e.player_controller)
	if e.override_animation then return end
	e.body.dir = -1
	self:player_update_animation(e, "idle", "_left")
end

function PlayerController:face_right(e)
	@@assert(e.__isEntity and e.player_controller)
	if e.override_animation then return end
	e.body.dir = 1
	self:player_update_animation(e, "idle")
end

function PlayerController:idle(e, stop)
	@@assert(e.__isEntity and e.player_controller)
	if e.override_animation then return end
	local body = e.body
	if body.dir == -1 then
		self:player_update_animation(e, "idle", "_left")
	else
		self:player_update_animation(e, "idle")
	end

	if stop then
		body.dx = 0
		body.vel_x = 0
		body.vel_y = 0
	end
end

function PlayerController:player_open_door(e, fn)
	@@assert(e.__isEntity)
	@@assert(e.player)
	@@sassert(fn, type(fn) == "function")
	local tag = (e.body.dir == -1) and "open_door_left" or "open_door"
	e:give("change_animation_tag", tag)
	:give("override_animation")
	:give("animation_on_loop", fn, "pauseAtEnd", true)
end

function PlayerController:player_open_locked_door(e, fn)
	@@assert(e.__isEntity)
	@@assert(e.player)
	@@sassert(fn, type(fn) == "function")
	local tag = (e.body.dir == -1) and "open_door_reverse_left" or "open_door_reverse"
	e:give("change_animation_tag", tag)
	:give("override_animation")
	:give("animation_on_loop", fn, "pauseAtEnd", true)
end

function PlayerController:interacted_stairs(e, tag, fn)
	@@assert(e.__isEntity)
	@@assert(e.player)
	@@assert(tag == "upstairs" or tag == "downstairs")
	@@sassert(fn, type(fn) == "function")
	e:give("change_animation_tag", tag)
	:give("override_animation")
	:give("animation_on_update", fn)
end

function PlayerController:player_interact(player, interactive)
	@@assert(player.__isEntity and player.player)
	@@assert(interactive.__isEntity and interactive.interactive)
	player:give("is_interacting")
	self.world:emit("on_interact_or_inventory")
end

function PlayerController:on_interact_or_inventory()
	for _, e in ipairs(self.pool) do
		local body = e.body
		local can_interact = e.can_interact
		e:give("prev_body", body.can_move, body.can_run, can_interact ~= nil)
	end
	self:player_can_run(false)
	self:player_can_move(false)
	self:player_can_interact(false)
end

function PlayerController:on_leave_interact_or_inventory(_)
	for _, e in ipairs(self.pool) do
		local body = e.body
		local prev_body = e.prev_body
		body.can_move = prev_body.can_move
		body.can_run = prev_body.can_run
		if prev_body.can_interact then
			e:give("can_interact")
			:remove("is_interacting")
		end
		e:remove("prev_body")
	end
end

function PlayerController:on_collide_interactive(e, interactive)
	@@assert(e.__isEntity)
	@@assert(interactive.__isEntity)
	self.world:emit("create_speech_bubble", e)
end

function PlayerController:on_leave_interactive(e)
	@@assert(e.__isEntity)
	self.world:emit("remove_speech_bubble")
end

return PlayerController

local Concord = require("modules.concord.concord")

local Inputs = require("inputs")

local PlayerController = Concord.system({
	pool = {"player_controller", "body", "collider3d"},
})

function PlayerController:init(world)
	self.world = world

	-- self.pool.onEntityAdded = function(pool, e)
	-- 	local sp_qm = e.spawn_point_question_mark.pos
    --
	-- 	pos
	-- end
end

function PlayerController:player_interact_item(bool)
	!if _ASSERT then
	Assert.must(bool, Types.T_BOOLEAN)
	!end

	for _, e in ipairs(self.pool) do
		e.body.can_move = not bool
		e.player.can_interact_item = not bool
	end
end

function PlayerController:player_set_movement(bool)
	!if _ASSERT then
	Assert.must(bool, Types.T_BOOLEAN)
	!end

	for _, e in ipairs(self.pool) do
		e.body.can_move = bool
	end
end

function PlayerController:update(dt)
	for _, e in ipairs(self.pool) do
		if e.override_animation then return end

		local body = e.body

		if not body.can_move then return end

		if Inputs.is_down("player_move_left") then
			if body.can_run then
				body.is_run = Inputs.is_down("player_run_mod")
			end

			body.dir = -1
			body.dx = -1
		elseif Inputs.is_down("player_move_right") then
			if body.can_run then
				body.is_run = Inputs.is_down("player_run_mod")
			end

			body.dir = 1
			body.dx = 1
		else
			body.dx = 0
		end

		if Inputs.is_down("player_move_up") then
			body.dy = -1
		elseif Inputs.is_down("player_move_down") then
			body.dy = 1
		else
			body.dy = 0
		end

		local anim_name = self:update_animation(e)

		self:update_speed(e, anim_name)
		self.world:emit("check_within_item", e)
	end
end

function PlayerController:update_spawn_point(e)
	local dir = e.body.dir
	local pos = e.position.pos
	local sp_ac = e.spawn_point_action_controls
	local sp_qm = e.spawn_point_question_mark

	if dir == -1 then
		sp_ac.pos.x = pos.x + 24
		sp_qm.pos.x = pos.x + 8
	else
		sp_ac.pos.x = pos.x + 4
		sp_qm.pos.x = pos.x + 16
	end

	sp_ac.pos.y = pos.y + 8
	sp_qm.pos.y = pos.y
end

function PlayerController:update_animation(e, override_name, override_variance)
	local anim_name = override_name
	local anim_variance = override_variance
	local body = e.body

	if not anim_name then

		if body.dx ~= 0 or body.dy ~= 0 then
			if body.is_run then
				anim_name = "run"
			else
				anim_name = "walk"
			end
		else
			anim_name = "idle"
		end
	end

	if not anim_variance then
		if body.dir == -1 then
			anim_variance = "_left"
		end
	end

	if anim_variance then
		self.world:emit("switch_animation_tag", e, anim_name .. anim_variance)
	else
		self.world:emit("switch_animation_tag", e, anim_name)
	end

	self:update_spawn_point(e)

	return anim_name
end

function PlayerController:update_speed(e, anim_name)
	local speed = e.speed
	local speed_data = e.speed_data

	if speed and speed_data then
		local body = e.body
		local old_speed = speed.speed
		local new_speed = speed_data.speed_data[anim_name]

		if body.dx ~= 0 then
			local speed_dt = mathx.lerp(old_speed.x, new_speed.x, 0.5)

			speed.speed.x = speed_dt
		end

		if body.dy ~= 0 then
			local speed_dt = mathx.lerp(old_speed.y, new_speed.y, 0.5)

			speed.speed.y = speed_dt
		end
	end
end

function PlayerController:face_left(e)
	if e.override_animation then return end

	e.body.dir = -1
	self:update_animation(e, "idle", "_left")
end

function PlayerController:face_right(e)
	if e.override_animation then return end

	e.body.dir = 1
	self:update_animation(e, "idle")
end

function PlayerController:idle(e)
	if e.override_animation then return end

	if e.body.dir == -1 then
		self:update_animation(e, "idle", "_left")
	else
		self:update_animation(e, "idle")
	end
end

function PlayerController:player_open_door(e, fn)
	!if _ASSERT then
	Assert.is(e, Types.T_ENTITY)
	Assert.exists(e.player)
	Assert.safe.must(fn, Types.T_FUNCTION)
	!end

	--method A
	local tag = (e.body.dir == -1) and "open_door_left" or "open_door"

	e:give("change_animation_tag", tag)
	:give("override_animation")
	:give("animation_on_loop", fn, "pauseAtEnd", true)

	--method B
	-- local data = e.multi_animation_data.data[tag]
	-- e.animation.current_tag = tag
	-- e:remove("animation_data")
	-- :give("animation_data", data)
	-- :give("override_animation")
	-- :give("animation_on_loop", fn, "pauseAtEnd", true)
    --
	-- self.world:emit("update_animation_data", e, data)
end

function PlayerController:player_upstairs(e, fn)
	!if _ASSERT then
	Assert.is(e, Types.T_ENTITY)
	Assert.exists(e.player)
	Assert.safe.must(fn, Types.T_FUNCTION)
	!end

	e:give("change_animation_tag", "upstairs")
	:give("override_animation")
	-- :give("animation_on_loop", fn, nil)
	:give("animation_on_update", fn)
end

function PlayerController:keypressed(key)
	if Inputs.is_pressed("player_interact", key) then
		for _, e in ipairs(self.pool) do
			local player = e.player

			if player.can_interact_item then
				self.world:emit("interact_item", e)
			end
		end
	end
end

!if _ASSERT then
local Slab = require("modules.slab")
local DebugFlags = require("debug_flags")
local views = DebugFlags.views
local format = string.format

function PlayerController:draw_debug()
	views.player = Slab.BeginWindow("player", {Title = "Player", IsOpen = views.player})

	for _, e in ipairs(self.pool) do
		local body = e.body
		local player = e.player
		local within_item = e.within_item

		Slab.Text("Body:")
		Slab.Indent()
		Slab.Text("dxy: " .. format("(%i, %i)", body.dx, body.dy))
		Slab.Text("dir: " .. body.dir)

		if Slab.CheckBox(body.can_move, "can_move") then
			body.can_move = not body.can_move
		end

		if Slab.CheckBox(body.can_run, "can_run") then
			body.can_run = not body.can_run
		end

		if Slab.CheckBox(player.can_interact_item, "can_interact_item") then
			player.can_interact_item = not player.can_interact_item
		end

		Slab.Text("is_run: " .. tostring(body.is_run))

		Slab.Unindent()

		if within_item then
			Slab.Text("Within item: " .. within_item.item_id)
		end

		Slab.Text("Override: " .. tostring(e.override_animation ~= nil))
		Slab.Text("Current: " .. e.animation.current_tag)
		Slab.Text("Playing: " .. tostring(e.animation.is_playing))
		Slab.Text("Tags:")
		Slab.Indent()

		for k, _ in pairs(e.multi_animation_data.data) do
			Slab.Text(k)
		end
	end
	Slab.EndWindow()
end
!end

return PlayerController

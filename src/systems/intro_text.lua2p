local Concord = require("modules.concord.concord")
local Flux = require("modules.flux.flux")
local Lume = require("modules.lume.lume")

local IntroText = Concord.system({
	pool = {"text_paint_data"}
})

Intro = require("assemblages.intro")

function IntroText:init(world)
	self.world = world

	self.pool.onEntityAdded = function(pool, e)
		self.paint_data = e:get("text_paint_data").data
	end
end

function IntroText:fade_text(e, dur, timeline)
	self:generate_paint(e, dur)
	e:remove("hidden")
	local color = e:get("color")
	Flux.to(color.color, dur, { [4] = 1 })
		:oncomplete(function()
			Flux.to(color.color, dur, { [4] = 0 })
				:oncomplete(function()
					timeline:Unpause()
					e:give("hidden")
					e:destroy()
				end)
		end)
end

function IntroText:generate_paint(e, dur_in, dur_out)
	!if _ASSERT then
	Assert.should_entity(e)
	Assert.should_number(dur_in)
	Assert.safe_should_number(dur_out)
	!end

	local transform = e:get("transform")
	local text = e:get("static_text").text
	local font = e:get("font").font
	local str_w = font:getWidth(text)
	local str_h = font:getHeight(text)
	local offset = 96
	local text_pos = e:get("position").pos
	local pos = vec2:new(text_pos.x + str_w/2, text_pos.y + str_h/2)
	if transform then
		pos.x = text_pos.x
		pos.y = text_pos.y
	end
	local chance = Lume.randomchoice({true, false})
	local sx = chance == true and -1 or 1

	local paint = Concord.entity(self.world)
		:assemble(Intro.bg_paint, self.paint_data, pos)
		:give("auto_scale", str_w + offset, str_h + offset, false)
		:give("transform", 0, sx, nil, 0.5, 0.5)
		:give("color", {1, 1, 1, 0})

	local color = paint:get("color")
	Flux.to(color.color, dur_in, { [4] = 1 })
		:oncomplete(function()
			Flux.to(color.color, dur_out or dur_in, { [4] = 0 })
				:oncomplete(function()
					paint:destroy()
				end)
				:delay(1)
		end)
end

return IntroText

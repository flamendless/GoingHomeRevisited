local Concord = require("modules.concord.concord")
local Flux = require("modules.flux.flux")
local Timer = require("modules.hump.timer")

local insert = table.insert
local random = love.math.random

local Fireflies = Concord.system({
	pool = {"firefly"},
})

local Outside = require("assemblages.outside")

local function generate_points(x, y, n)
	local offset = 8
	local points = {x = x, y = y}
	local prev_x = x
	local prev_y = y

	for _ = 1, n - 1 do
		local px = random(prev_x - offset, prev_x + offset)
		local py = random(prev_y - offset, prev_y + offset)
		local p = {x = px, y = py}

		prev_x = px
		prev_y = py
		insert(points, p)
	end

	return points
end

function Fireflies:init(world)
	self.world = world
	self.timer = Timer()
	!if _DEV then
	self.debug_fireflies = false
	!end
end

function Fireflies:update(dt)
	self.timer:update(dt)
end

function Fireflies:generate_fireflies(n, sprite_light, min_pos, max_pos)
	@@assert(type(n) == "number")
	@@assert(sprite_light:type() == "Image")
	@@assert(type(min_pos) == "table")
	@@assert(type(min_pos.x) == "number")
	@@assert(type(min_pos.y) == "number")
	@@assert(type(max_pos) == "table")
	@@assert(type(max_pos.x) == "number")
	@@assert(type(max_pos.y) == "number")
	for _ = 1, n do
		local x = random(min_pos.x, max_pos.x)
		local y = random(min_pos.y, max_pos.y)
		local points = generate_points(x, y, 64)
		Concord.entity(self.world)
			:assemble(Outside.firefly, sprite_light, x, y, points)
	end
end

function Fireflies:show_fireflies(dur)
	@@assert(type(dur) == "number")

	for _, e in ipairs(self.pool) do
		e:remove("hidden")
		Flux.to(e.color.value, dur, { [4] = 1 })
			:oncomplete(function()
				e:give("light_flicker", 0.05)
				:give("light_timer")
			end)
	end

	!if _DEV then
	self.debug_fireflies = true
	!end
end

function Fireflies:hide_fireflies(dur)
	@@assert(type(dur) == "number")

	for _, e in ipairs(self.pool) do
		e:remove("light_flicker")
		:remove("light_timer")
		Flux.to(e.color.value, dur, { [4] = 0 })
			:oncomplete(function()
				e:give("hidden")
			end)
	end

	!if _DEV then
	self.debug_fireflies = false
	!end
end

function Fireflies:move_fireflies()
	for _, e in ipairs(self.pool) do
		e:give("firefly_move")
		e:give("path_loop")
		self.world:emit("move_to_next_point", e, true)
	end
	!if _DEV then
	self.debug_move = true
	!end
end

function Fireflies:stop_fireflies()
	for _, e in ipairs(self.pool) do
		e:remove("firefly_move")
		:remove("path_loop")
	end
	!if _DEV then
	self.debug_move = false
	!end
end

function Fireflies:cleanup()
	self.timer:clear()
end

!if _DEV then
local Slab = require("modules.slab")
local flags = {
	path = false,
}

function Fireflies:debug_update(dt)
	if not self.debug_show then return end
	self.debug_show = Slab.BeginWindow("Fireflies", {
		Title = "Fireflies",
		IsOpen = self.debug_show
	})

	if Slab.CheckBox(self.debug_fireflies, "Show") then
		self.debug_fireflies = not self.debug_fireflies
		if self.debug_fireflies then
			self:show_fireflies(5)
		else
			self:hide_fireflies(5)
		end
	end

	if Slab.CheckBox(self.debug_move, "Move") then
		self.debug_move = not self.debug_move
		if self.debug_move then
			self:move_fireflies()
		else
			self:stop_fireflies()
		end
	end

	if Slab.CheckBox(flags.path, "Path") then
		flags.path = not flags.path
		self.world:emit("debug_toggle_path", flags.path, "firefly")
	end

	Slab.EndWindow()
end
!end

return Fireflies

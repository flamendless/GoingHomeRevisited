local Concord = require("modules.concord.concord")
local Flux = require("modules.flux.flux")

local insert = table.insert
local random = love.math.random

local Fireflies = Concord.system({
	pool = {"firefly"},
})

local Outside = require("assemblages.outside")

local function generate_points(x, y, n)
	local offset = 8
	local points = {x = x, y = y}
	local prev_x = x
	local prev_y = y
	for _ = 1, n - 1 do
		local px = random(prev_x - offset, prev_x + offset)
		local py = random(prev_y - offset, prev_y + offset)
		local p = {x = px, y = py}
		prev_x = px
		prev_y = py
		insert(points, p)
	end
	return points
end

function Fireflies:init(world)
	self.world = world
	!if _DEV then
	self.debug_fireflies = false
	!end
end

function Fireflies:generate_fireflies()
	local n = random(10, 20)
	local min_x, max_x = 516, 916
	local y = 236
	for _ = 1, n do
		local x = random(min_x, max_x)
		local points = generate_points(x, y, 64)
		Concord.entity(self.world):assemble(Outside.firefly, x, y, points)
			:give("light_disabled")
	end
end

function Fireflies:show_fireflies(dur)
	@@assert(type(dur) == "number")
	for _, e in ipairs(self.pool) do
		e:remove("light_disabled")
		Flux.to(e.diffuse.value, dur, {
			[1] = 4.96,
			[2] = 4.44,
			[3] = 0.8,
		})
		:onupdate(function()
			self.world:emit("update_light_diffuse", e)
			e:give("light_fading", 8, -1)
		end)
	end

	!if _DEV then
	self.debug_fireflies = true
	!end
end

function Fireflies:hide_fireflies(dur)
	@@assert(type(dur) == "number")
	for _, e in ipairs(self.pool) do
		e:remove("light_fading")
		Flux.to(e.diffuse.value, dur, {
			[1] = 0,
			[2] = 0,
			[3] = 0,
		})
		:onupdate(function()
			self.world:emit("update_light_diffuse", e)
		end)
		:oncomplete(function()
			e:give("light_disabled")
		end)
	end

	!if _DEV then
	self.debug_fireflies = false
	!end
end

function Fireflies:move_fireflies()
	for _, e in ipairs(self.pool) do
		e:give("firefly_move")
		e:give("path_loop")
		self.world:emit("move_to_next_point", e, "update_light_pos")
	end
	!if _DEV then
	self.debug_move = true
	!end
end

function Fireflies:stop_fireflies()
	for _, e in ipairs(self.pool) do
		e:remove("firefly_move")
		:remove("path_loop")
	end
	!if _DEV then
	self.debug_move = false
	!end
end

!if _DEV then
local Slab = require("modules.slab")
local flags = {
	path = false,
}

function Fireflies:debug_update(dt)
	if not self.debug_show then return end
	self.debug_show = Slab.BeginWindow("Fireflies", {
		Title = "Fireflies",
		IsOpen = self.debug_show
	})

	if Slab.CheckBox(self.debug_fireflies, "Show") then
		self.debug_fireflies = not self.debug_fireflies
		if self.debug_fireflies then
			self:show_fireflies(5)
		else
			self:hide_fireflies(5)
		end
	end

	if Slab.CheckBox(self.debug_move, "Move") then
		self.debug_move = not self.debug_move
		if self.debug_move then
			self:move_fireflies()
		else
			self:stop_fireflies()
		end
	end

	if Slab.CheckBox(flags.path, "Path") then
		flags.path = not flags.path
		self.world:emit("debug_toggle_path", flags.path, "firefly")
	end

	Slab.EndWindow()
end
!end

return Fireflies

local Concord = require("modules.concord.concord")

local random = love.math.random

local RainIntro = Concord.system({
	pool_empty = {"empty_rain"},
	pool_data_tilted = {"rain_data", "rain_tilted", "screen_size"},
	pool_drop_tilted = { "rain_drop", "rain_tilted", "position", "acceleration", "collider_circle"},
	pool_splash_tilted = {"rain_splash", "rain_tilted", "position"},
})

function RainIntro:init(world)
	self.world = world
	self.data = nil

	self.pool_data_tilted.onEntityAdded = function(pool, e)
		!if _ASSERT then
		Assert.should_nil(self.data)
		!end

		self.data = e.rain_data.data
		self.scroll_speed = e.rain_data.data.scroll_speed
		self.metadata = e.rain_data.data.metadata
		self.max_width = e.screen_size.width * 1.5
		self.max_height = e.screen_size.height

		for i = 1, e.rain_data.buffer do
			local empty = Concord.entity(self.world)
				:give("empty_rain")
		end
	end
end

function RainIntro:emit_rain(amount, max_amount)
	if (#self.pool_drop_tilted > max_amount) or (amount > #self.pool_empty) then
		return
	end

	local drop = self.data.drop
	local random_amount = random(amount/2, amount * 1.5)

	for i = 1, random_amount do
		local r = random(1, #drop)
		local img = drop[r]
		local x = random(1, self.max_width)
		local pos = vec2:new(x, -64)
		local anim_data = {}

		table.copy(self.metadata.drop, anim_data)
		anim_data.spritesheet = img

		local ax = random(320, 640)
		local ay = random(320, 640)
		local accel = vec2:new(-ax, ay)
		local alpha = random(10, 100)/100
		local z = random(1, 10)
		local scale = random(20, 70)/100 + (z/10)

		local e = self.pool_empty[i]
		if e then
			e:give("animation_data", anim_data)
			:give("position", pos)
			:give("animation")
			:give("rain_drop")
			:give("rain_tilted")
			:give("acceleration", accel)
			:give("z_index", z)
			:give("color", {1, 1, 1, alpha})
			:give("transform", 0, scale, scale)
			:give("collider_circle", 4, vec2:new(9, 32))
			:remove("empty_rain")
		end
	end
end

function RainIntro:emit_splash(e)
	local splash = self.data.splash
	local r = random(1, #splash)
	local img = splash[r]
	local anim_data = {}

	table.copy(self.metadata.splash, anim_data)
	anim_data.spritesheet = img

	e:give("rain_splash")
	:give("animation_on_loop", function()
		e:remove("animation_data")
		:remove("animation")
		:remove("rain_splash")
		:remove("rain_tilted")
		:remove("position")
		:remove("transform")
		:remove("z_index")
		:remove("color")
		:remove("collider_circle")
		:give("empty_rain")
	end, "pauseAtEnd", true)
	self.world:emit("update_animation_data", e, anim_data)
end

function RainIntro:update(dt)
	for _, e in ipairs(self.pool_drop_tilted) do
		local pos = e.position.pos
		local accel = e.acceleration.accel
		local col = e.collider_circle
		local z_index = e.z_index.z

		local dx = pos.x + accel.x * dt
		local dy = pos.y + accel.y * dt

		pos.x = dx
		pos.y = dy

		self.world:emit("check_collision", e)

		if (z_index < 9 and col.is_hit) or (pos.y > self.max_height) then
			e:remove("rain_drop")
			:remove("acceleration")
			self:emit_splash(e)
		end
	end

	for _, e in ipairs(self.pool_splash_tilted) do
		local pos = e.position.pos
		local dx = pos.x + self.scroll_speed * dt

		pos.x = dx
	end
end

return RainIntro

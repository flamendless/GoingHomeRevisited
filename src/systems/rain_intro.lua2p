local Concord = require("modules.concord.concord")

local RainIntro = Concord.system({
	pool_empty = {"empty_rain",},
	pool_data_tilted = {"rain_data", "rain_tilted"},
	pool_drop_tilted = { "rain_drop", "rain_tilted", "position", "acceleration" },
})

local Intro = require("assemblages.intro")

function RainIntro:init(world)
	self.world = world
	self.data = nil

	self.pool_data_tilted.onEntityAdded = function(pool, e)
		!if _ASSERT then
		Assert.should_nil(self.data)
		!end

		local rain_data = e:get("rain_data")
		self.data = rain_data.data
		self.metadata = rain_data.data.metadata

		for i = 1, rain_data.buffer do
			local empty = Concord.entity(self.world)
				:give("empty_rain")
		end
	end
end

function RainIntro:emit_rain(amount)
	!if _ASSERT then
	Assert.should_exists(self.data)
	!end

	if amount > #self.pool_empty then return end

	local drop = self.data.drop
	for i = 1, amount do
		local r = love.math.random(1, #drop)
		local img = drop[r]
		local x = love.math.random(1, love.graphics.getWidth())
		local pos = vec2:new(x, 0)
		local anim_data = {}
		table.copy(self.metadata.drop, anim_data)
		anim_data.spritesheet = img
		local ax = love.math.random(128, 256)
		local ay = love.math.random(128, 256)
		local accel = vec2:new(-ax, ay)
		local alpha = love.math.random(0, 100)/100
		local scale = love.math.random(50, 100)/100
		local z = love.math.random(1, 10)

		local e = self.pool_empty[i]
			:give("animation_data", anim_data)
			:give("position", pos)
			:give("animation")
			:give("rain_drop")
			:give("rain_tilted")
			:give("acceleration", accel)
			:give("z_index", z)
			:give("color", {1, 1, 1, alpha})
			:give("transform", 0, scale, scale)
			:remove("empty_rain")
	end
end

function RainIntro:emit_splash(e)
	local splash = self.data.splash
	local r = love.math.random(1, #splash)
	local img = splash[r]
	local anim_data = {}
	table.copy(self.metadata.splash, anim_data)
	anim_data.spritesheet = img

	e:give("rain_splash")
	:give("animation_on_complete", function()
		e:remove("animation_data")
		:remove("animation")
		:remove("rain_splash")
		:remove("rain_tilted")
		:remove("position")
		:remove("transform")
		:remove("z_index")
		:remove("color")
		:give("empty_rain")
	end, "pauseAtEnd", true)
	self.world:emit("update_animation_data", e, anim_data)
end

function RainIntro:update(dt)
	for _, e in ipairs(self.pool_drop_tilted) do
		local pos = e:get("position").pos
		local accel = e:get("acceleration").accel

		local dx = pos.x + accel.x * dt
		local dy = pos.y + accel.y * dt
		pos.x = dx
		pos.y = dy

		if pos.y > love.graphics.getHeight()/2 then
			e:remove("rain_drop")
			e:remove("acceleration")
			self:emit_splash(e)
		end
	end
end

return RainIntro

local Concord = require("modules.concord.concord")
local Log = require("modules.log.log")
local Lume = require("modules.lume.lume")

local Fade = require("fade")
local IDS = require("data.ids")
local Inputs = require("inputs")
local ListByID = require("ctor.list_by_id")
local Resources = require("resources")

local Pause = Concord.system({
	pool_choice = {
		constructor = ListByID,
		id = IDS.lists.pause_choices,
	},
})

local APause = require("assemblages.pause")

local glitch_chance = {glitch = 0.15, reset = 0.85}
local glitch_chance_h = {glitch = 1, reset = 0}
local opt = {"Resume", "Settings", "Quit"}

function Pause:init(world)
	self.world = world
	self.is_paused = false
	self.prev = {}

	local ww, wh = love.graphics.getDimensions()
	self.canvas = love.graphics.newCanvas(ww, wh)
	self.timer = timer(6, nil, function()
		self:do_pause_glitch(glitch_chance_h)
		self.timer:reset()
	end)
end

function Pause:create_pause_e()
	local ww, wh = love.graphics.getDimensions()
	local ww2, wh2 = ww * 0.5, wh * 0.5
	self.e_bg = Concord.entity(self.world):assemble(APause.bg, ww2, wh2)
	self.e_title = Concord.entity(self.world):assemble(APause.text, ww2, wh2 - 64)
	self.world:emit("reset_glitch", self.e_title)
end

function Pause:create_pause_choices()
	if #self.pool_choice ~= 0 then return end
	local ww, wh = love.graphics.getDimensions()
	local ww2, wh2 = ww * 0.5, wh * 0.5
	local by = wh2 + 16
	local scale = 0.75
	local fnt = Resources.data.fonts.ui
	local fh = fnt:getHeight("") * scale + 8

	self.world:emit("create_list_group", IDS.lists.pause_choices, true, #opt)
	for i, str in ipairs(opt) do
		local x = ww2
		local y = by + (i - 1) * fh
		Concord.entity(self.world):assemble(APause.choice, str, x, y, scale)
	end
end

function Pause:do_pause_glitch(chance)
	@@assert(type(chance) == "table")
	local res = Lume.weightedchoice(chance)
	if res == "glitch" then
		self.world:emit("do_random_glitch", self.e_title)
	elseif res == "reset" then
		self.world:emit("reset_glitch", self.e_title)
	end
	self.timer2 = timer(0.25, nil, function()
		self.world:emit("reset_glitch", self.e_title)
	end)
end

function Pause:update(dt)
	if self.is_paused then
		self.timer:update(dt)
		if self.timer2 then
			self.timer2:update(dt)
		end
	end
	if Inputs.pressed("pause") then
		self:on_pause()
	end
end

function Pause:draw_paused()
	if not self.is_paused then return end
	love.graphics.setCanvas(self.canvas)
	love.graphics.clear()
	self.world:emit("draw_sprite_ex", self.e_bg)
	self.world:emit("draw_text_ex", self.e_title)
	for _, e in ipairs(self.pool_choice) do
		self.world:emit("draw_text_ex", e)
	end
	love.graphics.setCanvas()
	self.world:emit("draw_glitch_effect", self.canvas)
	Fade.draw()
end

function Pause:on_pause()
	if not self.is_paused then
		for i, v in ipairs(self.world:getSystems()) do
			self.prev[i] = v:isEnabled()
			if not v.__unpausable then
				v:setEnabled(false)
			end
		end
		self:create_pause_e()
		self:create_pause_choices()
		self.world:__flush()
		self:do_pause_glitch(glitch_chance_h)
	else
		for i, v in ipairs(self.world:getSystems()) do
			v:setEnabled(self.prev[i])
		end
		tablex.clear(self.prev)
		self.e_bg:destroy()
		self.e_title:destroy()
		self.world:emit("destroy_list", IDS.lists.pause_choices)
	end

	self.is_paused = not self.is_paused
	self.world:emit("set_post_process_effect", "Blur", self.is_paused)
	Log.info("Paused:", self.is_paused)
end

Pause[$_LIST_UPDATE .. IDS.lists.pause_choices] = function(self, e_hovered)
	self:do_pause_glitch(glitch_chance)
	for _, e in ipairs(self.pool_choice) do
		if e ~= e_hovered then
			local color = e.color.value
			color[1] = 1
			color[2] = 1
			color[3] = 1
		end
	end
	local hovered_color = e_hovered.color.value
	hovered_color[1] = 1
	hovered_color[2] = 0
	hovered_color[3] = 0
end

Pause[$_LIST_INTERACT .. IDS.lists.pause_choices] = function(self, e_hovered)
	local text = e_hovered.static_text.value
	if text == "Resume" then
		self:on_pause()
	elseif text == "Settings" then
		--TODO
	elseif text == "Quit" then
		!if _PLATFORM == "desktop" then
		local btn = love.window.showMessageBox("Alert",
			"Are you sure you want to exit the game?",
			{"Return to Main Menu", "Exit Game", "Cancel", escapebutton = 3})
		if btn == 1 then
			self.world:emit("switch_state", "Menu")
		elseif btn == 2 then
			love.event.quit()
		end
		!end
	end
end

return Pause

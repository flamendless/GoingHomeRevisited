local Anim8 = require("modules.anim8.anim8")
local Concord = require("modules.concord.concord")

local min = math.min
local insert = table.insert
local cache_multi_animation = {}

local Animation = Concord.system({
	pool = {"animation", "animation_data", "position"},
	pool_z = {"animation", "animation_data", "position", "z_index"},
	pool_multi = {"multiple_animation_data", "animation", "position"},
	pool_pause = {"animation", "animation_data", "animation_pause_at"}
})

local setup_on_end = function(e, animation)
	!if _ASSERT then
	Assert.should_component(animation)
	!end

	local cb = e:get("animation_on_complete")
	local on_end
	if cb then
		on_end = function()
			cb.callback()
			animation.is_playing = false
			if cb.event then
				animation.animation[cb.event](animation.animation)
			end
		end
	else
		on_end = function()
			if animation.stop_on_last then
				animation.is_playing = false
				animation.animation:pauseAtEnd()
			end
		end
	end
	return on_end
end

local setup_auto_scale = function(e, data)
	local auto_scale = e:get("auto_scale")
	if auto_scale then
		local transform = e:get("transform")
		if auto_scale.is_proportion then
			local scale = min(auto_scale.target_width/data.frame_width, auto_scale.target_height/data.frame_height)
			transform.sx = scale
			transform.sy = scale
		else
			transform.sx = auto_scale.target_width/data.frame_width
			transform.sy = auto_scale.target_height/data.frame_height
		end
	end
end

local setup_animation = function(e, data, on_end)
	local animation = e:get("animation")
	local multi = e:get("multiple_animation_data")

	local obj_grid
	local obj_animation
	if not multi then
		obj_grid = Anim8.newGrid(data.frame_width, data.frame_height, data.sheet_width, data.sheet_height)
		obj_animation = Anim8.newAnimation(obj_grid(unpack(data.frames)), data.durations or data.delay, on_end)
	else
		if cache_multi_animation[animation.current_tag] then
			local cached = cache_multi_animation[animation.current_tag]
			obj_grid = cached.grid
			obj_animation = cached.animation
		else
			obj_grid = Anim8.newGrid(data.frame_width, data.frame_height, data.sheet_width, data.sheet_height)
			obj_animation = Anim8.newAnimation(obj_grid(unpack(data.frames)), data.durations or data.delay, on_end)
			cache_multi_animation[animation.current_tag] = {
				grid = obj_grid,
				animation = obj_animation
			}
			if data.is_flipped then
				obj_animation:flipH()
			end
		end
	end

	animation.grid = obj_grid
	animation.animation = obj_animation

	local quad, x, y, r, sx, sy, ox, oy = obj_animation:getFrameInfo()
	e:give("sprite", data.spritesheet)
	e:give("quad", quad)

	if data.is_flipped then
		e:give("quad_transform", r, sx, sy, ox, oy)
	else
		e:remove("quad_transform")
	end
end

function Animation:init()
	self.custom_pool_z = {}

	self.pool.onEntityAdded = function(pool, e)
		local data = e:get("animation_data")
		local animation = e:get("animation")
		setup_auto_scale(e, data)
		local on_end = setup_on_end(e, animation)
		setup_animation(e, data, on_end)
	end

	self.pool_z.onEntityAdded = function(pool, e)
		insert(self.custom_pool_z, e)
		table.insertion_sort(self.custom_pool_z, function(a, b)
			local a_z = a:get("z_index").z
			local b_z = b:get("z_index").z
			return a_z < b_z
		end)
	end

	self.pool_multi.onEntityAdded = function(pool, e)
		local multi = e:get("multiple_animation_data")
		local animation = e:get("animation")
		local on_end = setup_on_end(e, animation)
		local data = multi.data[multi.first]
		animation.current_tag = multi.first
		e:give("animation_data", data)
	end

	self.pool_pause.onEntityAdded = function(pool, e)
		local data = e:get("animation_data")
		local animation = e:get("animation")
		local pause_at = e:get("animation_pause_at")

		if type(pause_at.at_frame) == "string" then
			if pause_at.at_frame == "first" then
				animation.animation:pauseAtStart()
			elseif pause_at.at_frame == "last" then
				animation.animation:pauseAtEnd()
			end
		elseif type(pause_at.at_frame) == "number" then
			assert(pause_at.at_frame <= data.n_frames, "Passed 'at_frames' must not exceed number of total frames in 'animation_data'")
			animation.animation:gotoFrame(pause_at.at_frame)
			animation.animation:pause()
		end
	end

	self.pool_pause.onEntityRemoved = function(pool, e)
		local animation = e:get("animation")
		animation.animation:resume()
	end
end

function Animation:switch_animation_tag(new_tag)
	!if _ASSERT then
	Assert.should_string(new_tag)
	!end

	for _, e in ipairs(self.pool_multi) do
		local multi = e:get("multiple_animation_data")
		!if _ASSERT then
		assert(multi.data[new_tag], "'new_tag' must exist in the 'data' table")
		!end
		local animation = e:get("animation")
		local on_end = setup_on_end(e, animation)
		if not (new_tag == animation.current_tag) then
			local data = multi.data[new_tag]
			animation.current_tag = new_tag
			e:remove("animation_data")
			e:give("animation_data", data)
			setup_animation(e, data, on_end)
		end
	end
end

function Animation:update(dt)
	for _, e in ipairs(self.pool) do
		local animation = e:get("animation")
		local stop = e:get("animation_stop")
		local dt_multiplier = e:get("dt_multiplier")
		local quad = e:get("quad")

		if dt_multiplier then
			dt = dt * dt_multiplier.mul
		end

		if animation.is_playing then
			if stop then
				animation.is_playing = false
				animation.animation[stop.event](animation.animation)
				local cb = e:get("animation_on_complete")
				if cb then
					cb.callback()
				end
			end
			animation.animation:update(dt)
		end

		local current_quad = animation.animation:getFrameInfo()
		quad.quad = current_quad
	end
end

return Animation

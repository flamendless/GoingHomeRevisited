local Anim8 = require("modules.anim8.anim8")
local Concord = require("modules.concord.concord")

local floor = math.floor
local insert = table.insert
local remove = table.remove

local Animation = Concord.system({
	pool = {"animation", "animation_data", "position"},
	pool_z = {"animation", "animation_data", "position", "z_index"},
	pool_multi = {"multi_animation_data", "animation", "position"},
	pool_pause = {"animation", "animation_data", "animation_pause_at"},
	pool_change = {"animation", "animation_data", "change_animation_tag"}
})

local cache_multi_animation = {}

local setup_on_loop = function(e, animation)
	!if _ASSERT then
	Assert.is(animation, Types.T_COMPONENT)
	!end

	local cb = e.animation_on_loop
	local on_loop

	if cb then
		on_loop = function()
			cb.callback()
			if cb.event then
				animation.is_playing = false
				animation.animation[cb.event](animation.animation)

				if cb.remove_at_end then
					e:remove("animation_on_loop")
					cache_multi_animation[e.animation.current_tag] = nil
				end
			end
		end
	else
		on_loop = function()
			if animation.stop_on_last then
				animation.is_playing = false
				animation.animation:pauseAtEnd()
			end
		end
	end

	return on_loop
end

local setup_animation = function(e, data, on_loop)
	local animation = e.animation
	local multi = e.multi_animation_data
	local current_tag = animation.current_tag
	local obj_grid
	local obj_animation

	if not multi then
		obj_grid = Anim8.newGrid(data.frame_width, data.frame_height,
			data.sheet_width, data.sheet_height)
		obj_animation = Anim8.newAnimation(obj_grid(unpack(data.frames)),
			 data.delay, on_loop)
	else
		if cache_multi_animation[current_tag] then
			local cached = cache_multi_animation[current_tag]

			obj_grid = cached.grid
			obj_animation = cached.animation
		else
			obj_grid = Anim8.newGrid(data.frame_width, data.frame_height,
				data.sheet_width, data.sheet_height)
			obj_animation = Anim8.newAnimation(obj_grid(unpack(data.frames)),
				data.delay, on_loop)

			cache_multi_animation[current_tag] = {
				grid = obj_grid,
				animation = obj_animation
			}

			if data.is_flipped then
				obj_animation:flipH()
			end
		end
	end

	animation.grid = obj_grid
	animation.animation = obj_animation

	local quad, x, y, r, sx, sy, ox, oy = obj_animation:getFrameInfo()

	e:give("sprite", data.spritesheet)
	e:give("quad", quad)

	if data.is_flipped then
		if e.transform then
			ox = ox - e.transform.ox
			oy = oy - e.transform.oy
		end

		e:give("quad_transform", r, sx, sy, ox, oy)
	else
		e:remove("quad_transform")
	end

	if data.start_frame then
		obj_animation:gotoFrame(data.start_frame)
	end

	!if not _RELEASE then
	animation.anim_debug = obj_animation:clone()
	!end
end

function Animation:init()
	self.custom_pool_z = {}

	self.pool.onEntityAdded = function(pool, e)
		local data = e.animation_data
		local animation = e.animation
		local on_loop = setup_on_loop(e, animation)

		setup_animation(e, data, on_loop)
	end

	self.pool_z.onEntityAdded = function(pool, e)
		insert(self.custom_pool_z, e)
		tablex.insertion_sort(self.custom_pool_z, function(a, b)
			local a_z = a.z_index.z
			local b_z = b.z_index.z

			return a_z < b_z
		end)
	end

	self.pool_z.onEntityRemoved = function(pool, e)
		for i = #self.custom_pool_z, 1, -1 do
			local ent = self.custom_pool_z[i]

			if e == ent then remove(self.custom_pool_z, i) end
		end
	end

	self.pool_multi.onEntityAdded = function(pool, e)
		local multi = e.multi_animation_data
		local animation = e.animation
		local on_loop = setup_on_loop(e, animation)
		local data = multi.data[multi.first]

		animation.current_tag = multi.first
		e:give("animation_data", data)
	end

	self.pool_pause.onEntityAdded = function(pool, e)
		local data = e.animation_data
		local animation = e.animation
		local pause_at = e.animation_pause_at

		if type(pause_at.at_frame) == "string" then
			if pause_at.at_frame == "first" then
				animation.animation:pauseAtStart()
			elseif pause_at.at_frame == "last" then
				animation.animation:pauseAtEnd()
			end
		elseif type(pause_at.at_frame) == "number" then
			!if _ASSERT then
			Assert.truthy(pause_at.at_frame <= data.n_frames)
			!end
			animation.animation:gotoFrame(pause_at.at_frame)
			animation.animation:pause()
		end
	end

	self.pool_pause.onEntityRemoved = function(pool, e)
		local animation = e.animation

		animation.animation:resume()
	end

	self.pool_change.onEntityAdded = function(pool, e)
		self:switch_animation_tag(e, e.change_animation_tag.new_tag)
	end
end

function Animation:switch_animation_tag(e, new_tag, override)
	!if _ASSERT then
	Assert.is(e, Types.T_ENTITY)
	Assert.must(new_tag, Types.T_STRING)
	Assert.safe.must(override, Types.T_BOOLEAN)
	!end

	local multi = e.multi_animation_data
	local data = multi.data[new_tag]

	!if _ASSERT then
	Assert.exists(data)
	!end

	local animation = e.animation
	local on_loop = setup_on_loop(e, animation)
	animation.is_playing = true

	if not (new_tag == animation.current_tag) then
		animation.current_tag = new_tag
		e:remove("animation_data")
		e:give("animation_data", data)
		setup_animation(e, data, on_loop)
	end

	if override then e:give("override_animation") end
	e:remove("change_animation_tag")
end

function Animation:update_animation_data(e, data)
	!if _ASSERT then
	Assert.is(e, Types.T_ENTITY)
	Assert.must(data, Types.T_TABLE)
	!end

	local animation = e.animation
	animation.stop_on_last = data.stop_on_last
	animation.is_playing = true
	local on_loop = setup_on_loop(e, animation)

	setup_animation(e, data, on_loop)
end

function Animation:update(dt)
	for _, e in ipairs(self.pool) do
		local animation = e.animation

		if animation.animation then
			local on_update = e.animation_on_update
			local stop = e.animation_stop
			local dt_multiplier = e.dt_multiplier
			local quad = e.quad

			if dt_multiplier then
				dt = dt * dt_multiplier.mul
			end

			if animation.is_playing then
				if stop then
					animation.is_playing = false
					animation.animation[stop.event](animation.animation)

					local cb = e.animation_on_loop

					if cb then
						cb.callback()
					end
				end

				animation.animation:update(dt)

				if on_update then
					on_update.on_update(dt, animation.animation.position)
				end
			end

			local current_quad = animation.animation:getFrameInfo()

			quad.quad = current_quad
		end
	end
end

!if not _RELEASE then
local Slab = require("modules.slab")
local DebugFlags = require("debug_flags")
local views = DebugFlags.views
local min, max = math.min, math.max
local format = string.format
local is_open = false
local selected_e

local min_zoom, max_zoom = 1, 3
local zoom_sheet = 1
local zoom_preview = 1
local is_open_preview = false
local frame_n = 0

function Animation:draw_debug()
	views.animation = Slab.BeginWindow("Animation", {
		Title = "Animation", IsOpen = views.animation})
	for _, e in ipairs(self.pool) do
		local id = e.id.id

		Slab.Text(id)
		Slab.SameLine()

		if Slab.Button("edit") then
			is_open = true
			selected_e = e
			break
		end
	end

	Slab.EndWindow()
	if not is_open then return end
	self:modify_e()
end

function Animation:update_debug(dt)
	if is_open_preview then
		local anim = selected_e.animation.anim_debug

		anim:update(dt)
	end
end

function Animation:modify_e()
	local e = selected_e
	local id = e.id.id
	local anim = e.animation
	local data = e.animation_data

	is_open = Slab.BeginWindow("AnimationEdit", {
		Title = id, IsOpen = is_open})

	Slab.Image("Spritesheet", {Image = data.spritesheet, Scale = zoom_sheet})
	Slab.Text("Zoom: " .. zoom_sheet)
	Slab.SameLine()

	if Slab.Button("-") then zoom_sheet = max(min_zoom, zoom_sheet - 0.5) end
	Slab.SameLine()
	if Slab.Button("+") then zoom_sheet = min(max_zoom, zoom_sheet + 0.5) end
	if Slab.Button("preview") then is_open_preview = not is_open_preview end

	is_open_preview = Slab.BeginWindow("Preview", {
		Title = "Preview", IsOpen = is_open_preview})

	local a = anim.anim_debug
	local sheet = data.spritesheet
	local w, h = data.frame_width, data.frame_height
	local quad = a:getFrameInfo()
	local qx, qy, qw, qh = quad:getViewport()

	Slab.Image("Image", {
		Image = sheet,
		Scale = zoom_preview,
		SubX = qx,
		SubY = qy,
		SubW = qw,
		SubH = qh,
	})

	Slab.Text("Tag: " .. anim.current_tag)

	if Slab.Button("play") then
		a:resume()
	end
	Slab.SameLine()

	if Slab.Button("pause") then
		a:pause()
	end
	Slab.SameLine()

	if Slab.Button("stop") then
		a:gotoFrame(1)
		a:pause()
	end

	local f = format("%i/%i", frame_n, data.n_frames)
	local p = format("%i,%i", x_offset, y_offset)
	Slab.Text("Frame: " .. f)
	Slab.SameLine()
	Slab.Text("Coordinate: " .. p)

	if Slab.Button("<") then
		frame_n = max(0, frame_n - 1)
	end
	Slab.SameLine()

	if Slab.Button(">") then
		frame_n = min(data.n_frames, frame_n + 1)
	end

	Slab.Text("Zoom: " .. zoom_preview)
	Slab.SameLine()
	if Slab.Button("-") then zoom_preview = max(min_zoom, zoom_preview - 0.5) end
	Slab.SameLine()
	if Slab.Button("+") then zoom_preview = min(max_zoom, zoom_preview + 0.5) end

	Slab.EndWindow()
	Slab.EndWindow()
end
!end

return Animation

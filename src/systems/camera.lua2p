local Concord = require("modules.concord.concord")

local Camera = Concord.system({
	pool_follow_pos = {"camera_follow", "position"},
	pool_follow_camera_pos = {"camera_follow", "camera_position"},
	pool_bounds = {"camera_bounds"},
})

function Camera:init(world)
	self.camera = nil
end

function Camera:camera_set(camera)
	!if _ASSERT then
	Assert.should_exists(camera)
	!end

	self.camera = camera
end

function Camera:set_camera_clip(width, height, color)
	!if _ASSERT then
	Assert.should_exists(self.camera)
	Assert.should_number(width)
	Assert.should_number(height)
	Assert.safe_should_color(color)
	!end

	self.clip = {
		width = width,
		height = height,
		color = color or { 1, 0, 0, 1 }
	}
end

function Camera:update(dt)
	if not self.camera then return end
	for _, e in ipairs(self.pool_bounds) do
		local l, t, w, h = self.camera:getVisible()
		local camera_bounds = e.camera_bounds
		camera_bounds.l = l
		camera_bounds.t = t
		camera_bounds.w = w
		camera_bounds.h = h
	end
end

function Camera:camera_follow()
	for _, e in ipairs(self.pool_follow_pos) do
		local x = e.position.pos.x + e.camera_follow.offset.x
		local y = e.position.pos.y + e.camera_follow.offset.y

		self.camera:setPosition(x, y)
	end

	for _, e in ipairs(self.pool_follow_camera_pos) do
		local x = e.camera_position.pos.x + e.camera_follow.offset.x
		local y = e.camera_position.pos.y + e.camera_follow.offset.y

		self.camera:setPosition(x, y)
	end
end

function Camera:update_camera_pos(x, y)
	for _, e in ipairs(self.pool_follow_camera_pos) do
		e.camera_position.pos:sset(x, y)
		self.camera:setPosition(x, y)
	end
end

function Camera:draw_clip()
	local cx, cy, cw, ch = self.camera:getWindow()
	local scale = self.camera:getScale()

	local diff = (ch - self.clip.height * scale)/2
	love.graphics.setColor(self.clip.color)
	love.graphics.rectangle("fill", cx, cy, cw, diff)
	love.graphics.rectangle("fill", cx, ch - diff, cw, diff)
end

!if not _RELEASE then
local Slab = require("modules.slab")
local floor = math.floor
local format = string.format

local min_speed = 64
local max_speed = 260

function Camera:update_debug(dt)
	for _, e in ipairs(self.pool_follow_camera_pos) do
		local pos = e.camera_position.pos
		local x = pos.x
		local y = pos.y

		local dx = 0
		local dy = 0
		local speed = min_speed
		local fast = love.keyboard.isDown("lshift")

		if love.keyboard.isDown("left") then
			dx = -1
		elseif love.keyboard.isDown("right") then
			dx = 1
		end

		if love.keyboard.isDown("up") then
			dy = -1
		elseif love.keyboard.isDown("down") then
			dy = 1
		end

		if fast then
			speed = math.lerp(speed, max_speed, 0.5)
		end

		x = x + speed * dx * dt
		y = y + speed * dy * dt

		pos.x = x
		pos.y = y
	end
end

function Camera:draw_debug()
	Slab.BeginWindow("camera", {Title = "Camera"})

	local scale = self.camera:getScale()
	Slab.Text("scale: ")
	Slab.SameLine()
	if Slab.Input("input_scale", {Text = tostring(scale), ReturnOnText = false, NumbersOnly = true}) then
		scale = Slab.GetInputNumber()
		self.camera:setScale(scale)
	end

	if Slab.Button("-") then
		scale = scale - 1
		self.camera:setScale(scale)
	end

	Slab.SameLine()
	if Slab.Button("+") then
		scale = scale + 1
		self.camera:setScale(scale)
	end

	local x, y = self.camera:getPosition()
	local str_pos = format("position: (%i, %i)", x, y)
	Slab.Text(str_pos)

	if Slab.Button("print") then
		print("camera scale:", scale)
		print("camera pos:", floor(x), floor(y))
	end

	Slab.EndWindow()
end
!end

return Camera

local Concord = require("modules.concord.concord")
local Flux = require("modules.flux.flux")

local Inputs = require("inputs")

local Camera = Concord.system({
	pool = {"camera"},
	pool_clip = {"camera", "camera_clip"},
})

function Camera:init(world)
	self.world = world
	self.main_camera = nil
	self.to_follow = nil
	self.dur_scale = 0.25
	self.can_scale = true
	self.clip = false
	self.follow = false

	self.pool.onAdded = function(pool, e)
		local cam = e.camera.camera

		if e.camera_transform then
			local t = e.camera_transform

			cam:setAngle(t.rot)
			cam:setScale(t.scale)
		end

		if e.camera.is_main then
			self.main_camera = cam
			self.world:emit("on_camera_created", cam)
		end
	end

	self.pool_clip.onAdded = function(pool, e)
		self.clip = true
	end

	self.pool_clip.onRemoved = function(pool, e)
		self.clip = #pool == 0
	end
end

function Camera:interactive_interacted()
	if self.can_scale then
		self.can_scale = false
		self.prev_scale = self.main_camera.scale
		self.target_scale = self.prev_scale + 1
		self.flux = Flux.to(self.main_camera, self.dur_scale, {scale = self.target_scale})
			:oncomplete(function() self.can_scale = true end)
	else
		self.flux:stop()
		self.main_camera.scale = self.target_scale
		self.can_scale = true
	end
end

function Camera:interact_cancelled()
	if self.can_scale then
		self.can_scale = false
		self.target_scale = self.prev_scale
		self.flux = Flux.to(self.main_camera, self.dur_scale, {scale = self.target_scale})
			:oncomplete(function() self.can_scale = true end)
	else
		self.flux:stop()
		self.main_camera.scale = self.prev_scale
		self.can_scale = true
	end
end

function Camera:set_camera_scale_ex(inc, dur)
	@@assert(type(inc) == "number")
	@@assert(type(dur) == "number")
	if self.can_scale_lerp then
		self.can_scale_lerp = false
		self.prev_scale = self.main_camera:getScale()
		self.target_scale = self.prev_scale + inc
		self.flux = Flux.to(self.main_camera, dur, {scale = self.target_scale})
			:oncomplete(function()
				self.can_scale_lerp = true
			end)
	end
end

function Camera:get_follow_coords(target)
	@@assert(target.__isEntity)
	local pos = target.pos
	local x = pos.x
	local y = pos.y

	if target.camera_follow_offset then
		local offset = target.camera_follow_offset
		x = x + offset.x
		y = y + offset.y
	end

	return x, y
end

function Camera:camera_follow(target, dur)
	@@assert(target.__isEntity)
	@@assert(type(dur) == "number")
	self.follow = true
	local cx, cy = self.main_camera:getPosition()
	local tx, ty = self:get_follow_coords(target)
	local dt = {x = cx, y = cy}

	Flux.to(dt, dur or 1, {x = tx, y = ty})
		:onupdate(function()
			self.main_camera:setPosition(dt.x, dt.y)
		end)
		:oncomplete(function()
			self.to_follow = target
		end)
end

function Camera:update(dt)
	if self.follow and self.to_follow then
		local x, y = self:get_follow_coords(self.to_follow)
		self.main_camera:setPosition(x, y)
	end
end

function Camera:draw_clip()
	if not self.clip then return end
	for _, e in ipairs(self.pool_clip) do
		local cam = e.camera.camera
		local cx, cy, cw, ch = cam:getWindow()
		local scale = cam:getScale()
		local diff = (ch - e.camera_clip.h * scale) * 0.5

		love.graphics.setColor(e.camera_clip.color)
		love.graphics.rectangle("fill", cx, cy, cw, diff)
		love.graphics.rectangle("fill", cx, ch - diff, cw, diff)
	end
end

!if _DEV then
local Slab = require("modules.slab")
local format = string.format
local flags = {
	center = true,
	visible = false,
	world = false,
	window = false,
	clip = false,
}

function Camera:debug_update(dt)
	if not self.debug_show then return end
	self.debug_show = Slab.BeginWindow("camera", {
		Title = "Camera",
		IsOpen = self.debug_show
	})
	local camera = self.main_camera
	if camera then
		local x, y = camera:getPosition()
		local scale = camera:getScale()
		local wx, wy, ww, wh = camera:getWorld()
		local sx, sy, sw, sh = camera:getWindow()
		local vx, vy, vw, vh = camera:getVisible()
		local str_world = format("World: (%d, %d, %d, %d)", wx, wy, ww, wh)
		local str_window = format("Window: (%d, %d, %d, %d)", sx, sy, sw, sh)
		local str_visible = format("Visible: (%d, %d, %d, %d)", vx, vy, vw, vh)
		Slab.Text("Pos:")
		Slab.Indent()
		Slab.Text("x:")
		Slab.SameLine()
		if Slab.InputNumberSlider("x", x, 0, sw, {
			ReturnOnText = false,
			NumbersOnly = true,
			Precision = 1,
		}) then
			self.follow = false
			x = Slab.GetInputNumber()
			self.main_camera:setPosition(x, y)
		end
		Slab.Text("y:")
		Slab.SameLine()
		if Slab.InputNumberSlider("y", y, 0, sh, {
			ReturnOnText = false,
			NumbersOnly = true,
			Precision = 1,
		}) then
			self.follow = false
			y = Slab.GetInputNumber()
			self.main_camera:setPosition(x, y)
		end
		Slab.Unindent()

		Slab.Text("Scale:")
		Slab.SameLine()
		if Slab.InputNumberSlider("scale", scale, 1, 10, {
			ReturnOnText = false,
			NumbersOnly = true,
			Precision = 2,
		}) then
			scale = Slab.GetInputNumber()
			self.main_camera:setScale(scale)
		end

		Slab.Text(str_world)
		Slab.Text(str_window)
		Slab.Text(str_visible)

		if Slab.CheckBox(self.follow, "Follow") then self.follow = not self.follow end
		Slab.SameLine()
		if Slab.CheckBox(self.clip, "Clip") then self.clip = not self.clip end
		if Slab.CheckBox(flags.clip, "Debug Clip") then
			flags.clip = not flags.clip
			for  _, e in ipairs(self.pool_clip) do
				local clip = e.camera_clip
				if flags.clip then
					clip.debug_prev = clip.color
					clip.color = {1, 0, 0, 1}
				else
					clip.color = clip.debug_prev
				end
			end
		end
		Slab.SameLine()
		if Slab.CheckBox(flags.center, "Center") then flags.center = not flags.center end
		if Slab.CheckBox(flags.world, "World") then flags.world = not flags.world end
		Slab.SameLine()
		if Slab.CheckBox(flags.window, "Window") then flags.window = not flags.window end
		if Slab.CheckBox(flags.visible, "Visible") then flags.visible = not flags.visible end
	else
		Slab.Text("No camera in current state")
	end
	Slab.EndWindow()

	local speed = 64
	if love.keyboard.isDown("lshift") then
		speed = 128
	end

	local dx, dy = 0, 0
	if Inputs.down("camera_down") then
		dy = 1
	elseif Inputs.down("camera_up") then
		dy = -1
	end
	if Inputs.down("camera_left") then
		dx = -1
	elseif Inputs.down("camera_right") then
		dx = 1
	end

	if dx ~= 0 or dy ~= 0 then
		local x, y = self.main_camera:getPosition()
		x = x + speed * dt * dx
		y = y + speed * dt * dy
		self.follow = false
		self.main_camera:setPosition(x, y)
	end
end

function Camera:debug_draw()
	if not self.debug_show then return end
	local scale = self.main_camera:getScale()
	local wx, wy, ww, wh = self.main_camera:getWorld()
	local sx, sy, sw, sh = self.main_camera:getWindow()
	local vx, vy, vw, vh = self.main_camera:getVisible()

	love.graphics.setLineWidth(1/scale)
	if flags.world then
		love.graphics.setColor(0, 0, 1, 0.7)
		love.graphics.rectangle("line", wx, wy, ww, wh)
		if flags.center then
			love.graphics.line(wx + ww * 0.5, wy, wx + ww * 0.5, wy + wh)
			love.graphics.line(wx, wy + wh * 0.5, wx + ww, wy + wh * 0.5)
			love.graphics.circle("line", wx + ww * 0.5, wy + wh * 0.5, 1)
		end
	end

	if flags.window then
		love.graphics.setColor(0, 1, 0, 0.7)
		love.graphics.rectangle("line", sx, sy, sw, sh)
		if flags.center then
			love.graphics.line(sw * 0.5, sy, sw * 0.5, sh)
			love.graphics.line(sx, sh * 0.5, sw, sh * 0.5)
			love.graphics.circle("line", sw * 0.5, sh * 0.5, 1)
		end
	end

	if flags.visible then
		love.graphics.setColor(1, 1, 0, 0.7)
		love.graphics.rectangle("line", vx, vy, vw, vh)
		if flags.center then
			love.graphics.line(vx + vw * 0.5, vy, vx + vw * 0.5, vy + vh)
			love.graphics.line(vx, vy + vh * 0.5, vx + vw, vy + vh * 0.5)
			love.graphics.circle("line", vx + vw * 0.5, vy + vh * 0.5, 1)
		end
	end
end

function Camera:debug_on_drag(bool)
	@@assert(type(bool) == "boolean")
	self.follow = not bool
end

!end
return Camera

local Concord = require("modules.concord.concord")
local Flux = require("modules.flux.flux")

local Camera = Concord.system({
	pool = {"camera"},
	pool_clip = {"camera", "camera_clip"},
})

function Camera:init(world)
	self.world = world
	self.main_camera = nil
	self.to_follow = nil
	self.dur_scale = 0.25
	self.can_scale = true

	self.pool.onAdded = function(pool, e)
		local cam = e.camera.camera

		if e.camera_transform then
			local t = e.camera_transform

			cam:setAngle(t.rot)
			cam:setScale(t.scale)
		end

		if e.camera.is_main then
			self.main_camera = cam
			self.world:emit("on_camera_created", cam)
		end
	end
end

function Camera:interactive_interacted()
	if self.can_scale then
		self.can_scale = false
		self.prev_scale = self.main_camera.scale
		self.target_scale = self.prev_scale + 1
		self.flux = Flux.to(self.main_camera, self.dur_scale, {scale = self.target_scale})
			:oncomplete(function() self.can_scale = true end)
	else
		self.flux:stop()
		self.main_camera.scale = self.target_scale
		self.can_scale = true
	end
end

function Camera:interact_cancelled()
	if self.can_scale then
		self.can_scale = false
		self.target_scale = self.prev_scale
		self.flux = Flux.to(self.main_camera, self.dur_scale, {scale = self.target_scale})
			:oncomplete(function() self.can_scale = true end)
	else
		self.flux:stop()
		self.main_camera.scale = self.prev_scale
		self.can_scale = true
	end
end

function Camera:set_camera_scale_ex(inc, dur)
	@@assert(type(inc) == "number")
	@@assert(type(dur) == "number")
	if self.can_scale_lerp then
		self.can_scale_lerp = false
		self.prev_scale = self.main_camera:getScale()
		self.target_scale = self.prev_scale + inc
		self.flux = Flux.to(self.main_camera, dur, {scale = self.target_scale})
			:oncomplete(function()
				self.can_scale_lerp = true
			end)
	end
end

function Camera:get_follow_coords(target)
	@@assert(target.__isEntity)
	local pos = target.pos
	local x = pos.x
	local y = pos.y

	if target.camera_follow_offset then
		local offset = target.camera_follow_offset
		x = x + offset.x
		y = y + offset.y
	end

	return x, y
end

function Camera:camera_follow(target, dur)
	@@assert(target.__isEntity)
	@@assert(type(dur) == "number")
	local x, y = self:get_follow_coords(target)

	Flux.to(self.main_camera, dur or 1, {x = x, y = y})
		:oncomplete(function()
			self.to_follow = target
		end)
end

function Camera:update(dt)
	if self.to_follow then
		local x, y = self:get_follow_coords(self.to_follow)
		self.main_camera:setPosition(x, y)
	end
end

function Camera:draw_clip()
	for _, e in ipairs(self.pool_clip) do
		local cam = e.camera.camera
		local cx, cy, cw, ch = cam:getWindow()
		local scale = cam:getScale()
		local diff = (ch - e.camera_clip.h * scale)/2

		love.graphics.setColor(e.camera_clip.color)
		love.graphics.rectangle("fill", cx, cy, cw, diff)
		love.graphics.rectangle("fill", cx, ch - diff, cw, diff)
	end
end

!if _DEV then
local Slab = require("modules.slab")
local flags = {
}

function Camera:debug_update(dt)

end

!end
return Camera

local Concord = require("modules.concord.concord")
local Timer = require("modules.hump.timer")

local Blur = require("blur")
local Inputs = require("inputs")
local Resources = require("resources")
local Palette = require("palette")

local floor = math.floor

local Inventory = Concord.system({
	pool_camera = {"camera"},
	pool_bg = {"cell_bg", "nf_render_sprite"},
	pool_item = {"item", "nf_render_sprite"},
	pool_cell_line = {"cell_line"},
	pool_cell_fill = {"cell_fill"},
	pool_hovered = {"hovered_cell"},
})

local ROWS, COLS = 2, 3
local alpha = 0.75
local alpha2 = alpha - 0.5
local c_l_h = Palette.get("inventory_line_hovered", alpha2)
local c_l_u = Palette.get("inventory_line_unhovered", alpha2)
local c_f_h = Palette.get("inventory_fill_hovered", alpha2)
local c_f_u = Palette.get("inventory_fill_unhovered", alpha2)

function Inventory:init(world)
	self.world = world
	self.can_open = true
	self.is_open = false
	self.pool_camera.onAdded = function(pool, e)
		local camera = e.camera
		if camera.is_main then
			self.main_camera = camera.camera
		end
	end
end

function Inventory:open_inventory()
	if not self.can_open then return end
	self.world:emit("on_interact_or_inventory")
	self.world:emit("set_sys_dialogues", false)
	self.is_open = true
	Blur.flag_process = true
	self:show_inventory()
end

function Inventory:close_inventory()
	self.world:emit("on_leave_interact_or_inventory")
	self.world:emit("set_sys_dialogues", true)
	self.is_open = false
	self.can_open = false
	Blur.flag_process = false
	self:hide_inventory()
	for _, e in ipairs(self.pool_cell_line) do
		e:destroy()
	end
	for _, e in ipairs(self.pool_cell_fill) do
		e:destroy()
	end
end

function Inventory:update(dt)
	if self.can_open and not self.is_open and Inputs.pressed("inventory") then
		self:open_inventory()
	elseif self.is_open and Inputs.pressed("cancel") then
		self:close_inventory()
	end

	if self.is_open then
		local dx, dy = 0, 0
		if Inputs.pressed("left") then
			dx = -1
		elseif Inputs.pressed("right") then
			dx = 1
		end
		if Inputs.pressed("up") then
			dy = -1
		elseif Inputs.pressed("down") then
			dy = 1
		end
		if dx ~= 0 or dy ~= 0 then
			self:update_inventory_cells(dx, dy)
		end
		self:update_cell_color()
	end
end

function Inventory:draw_inventory()
	if not self.is_open then return end
	for _, e in ipairs(self.pool_bg) do
		if e.sprite then
			self.world:emit("draw_sprite_ex", e)
		elseif e.rect then
			self.world:emit("draw_rect_ex", e)
		end
	end
	for _, e in ipairs(self.pool_cell_line) do
		self.world:emit("draw_rect_ex", e)
	end
	for _, e in ipairs(self.pool_cell_fill) do
		self.world:emit("draw_rect_ex", e)
	end
end

function Inventory:show_inventory()
	local _, _, w, h = self.main_camera:getWindow()
	local img = Resources.data.images.bg_item
	local iw, ih = img:getDimensions()
	local bar_h = self.pool_camera[1].bar_height.value
	local pad = 64
	local nw = w - pad * 2
	local nh = h - pad * 3 - bar_h * 2
	local scale = math.min(nw/iw, nh/ih)
	local x = w - pad * 0.5
	local y = h * 0.5

	Concord.entity(self.world)
		:give("id", "inventory_bg")
		:give("nf_render_sprite")
		:give("pos", x, y)
		:give("sprite", "bg_item")
		:give("cell_bg")
		:give("transform", 0, scale, scale, 1, 0.5)
		:give("color", {1, 1, 1, 0})
		:give("fade_in_target_alpha", alpha)
		:give("color_fade_in", 0.5)

	local rx = x - iw * scale * 0.5
	local ry = y
	local rs = scale * 0.7
	Concord.entity(self.world)
		:give("id", "inventory_rect")
		:give("nf_render_sprite")
		:give("pos", rx, ry)
		:give("rect", iw, ih)
		:give("line_width", 2)
		:give("draw_mode", "line")
		:give("cell_bg")
		:give("color", {1, 1, 1, 0})
		:give("fade_in_target_alpha", alpha2)
		:give("color_fade_in", 0.5)
		:give("transform", 0, rs, rs, 0.5, 0.5)

	local bx = rx - iw * rs * 0.5
	local by = y - ih * rs * 0.5
	local sw = floor(iw * rs)/COLS
	local sh = floor(ih * rs)/ROWS
	for y = 0, ROWS - 1 do
		for x = 0, COLS - 1 do
			local srx = bx + x * sw
			local sry = by + y * sh

			local i = y * COLS + x
			local a = Concord.entity(self.world)
				:give("id", "inventory_rect_fill_" .. i)
				:give("nf_render_sprite")
				:give("pos", srx, sry)
				:give("rect", sw, sh)
				:give("draw_mode", "fill")
				:give("cell_fill")
				:give("color", {1, 1, 1, alpha2})

			local b = Concord.entity(self.world)
				:give("id", "inventory_rect_" .. i)
				:give("nf_render_sprite")
				:give("pos", srx, sry)
				:give("rect", sw, sh)
				:give("line_width", 2)
				:give("draw_mode", "line")
				:give("cell_line")
				:give("color", {1, 1, 1, alpha2})

			if y == 0 and x == 0 then
				a:give("hovered_cell")
				b:give("hovered_cell")
			end
		end
	end
end

function Inventory:hide_inventory()
	for _, e in ipairs(self.pool_bg) do
		e:give("color_fade_out", 0.5)
		:give("color_fade_out_finish", "destroy_entity", 0, e)
	end
	Timer.after(0.5, function() self.can_open = true end)
end

function Inventory:update_inventory_cells(dx, dy)
	local index
	for i, e in ipairs(self.pool_cell_line) do
		if e.hovered_cell then
			e:remove("hovered_cell")
			index = i
			break
		end
	end
	self.pool_cell_fill[index]:remove("hovered_cell")

	local x = (index - 1) % COLS
	local y = floor((index - 1)/COLS)
	x = (x + dx) % COLS
	y = (y + dy) % ROWS
	index = (y * COLS) + x + 1

	local a = self.pool_cell_line[index]
	local b = self.pool_cell_fill[index]
	a:give("hovered_cell")
	b:give("hovered_cell")
end

function Inventory:update_cell_color()
	for _, e in ipairs(self.pool_cell_line) do
		local color
		if e.hovered_cell then
			color = c_l_h
		else
			color = c_l_u
		end
		local c = e.color.value
		c[1] = color[1]
		c[2] = color[2]
		c[3] = color[3]
		c[4] = color[4]
	end
	for _, e in ipairs(self.pool_cell_fill) do
		local color
		if e.hovered_cell then
			color = c_f_h
		else
			color = c_f_u
		end
		local c = e.color.value
		c[1] = color[1]
		c[2] = color[2]
		c[3] = color[3]
		c[4] = color[4]
	end
end

function Inventory:cleanup()
	for _, e in ipairs(self.pool_bg) do
		e:destroy()
	end
	for _, e in ipairs(self.pool_cell_line) do
		e:destroy()
	end
	for _, e in ipairs(self.pool_cell_fill) do
		e:destroy()
	end
end

return Inventory

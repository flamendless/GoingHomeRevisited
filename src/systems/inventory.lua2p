local Concord = require("modules.concord.concord")

local Palette = require("palette")
local ScreenInfo = require("screen_info")

local floor = math.floor

local Inventory = Concord.system({
	pool = {"id", "item"},
	pool_cell = {"id", "sprite", "inventory_cell"},
	pool_desc = {"id", "sprite", "inventory_desc"},
})

local Items = require("assemblages.items")

local scale = 1
local img_w, img_h = 64, 64
local item_size = vec2:new(img_w * scale, img_h * scale)

local line_width = 3
local color_outline = Palette.get("item_outline")
local color_outline_hovered = Palette.get("item_outline_hovered")

function Inventory:init(world)
	self.world = world

	self.dur_show = 0.5
	self.offset = 108
	self.cols = 3
	self.rows = 3

	self.pool.onEntityAdded = function(pool, e)
		local pos = self.pool_cell[#pool].position.pos:copy()

		e:give("position", pos)
		:give("bounding_box", pos:copy(), item_size:copy())
		:give("layer", "inventory", 3)
		:give("transform", 0, scale, scale, 0.5, 0.5)
		:give("on_click", 1, function()
			self.world:emit("item_clicked", e)
		end)
	end

	!if not _RELEASE and _ASSERT then
	self.pool_desc.onEntityAdded = function(pool, e)
		if #pool > 1 then error("There should only be one inventory_desc") end
	end
	!end
end

function Inventory:create_inventory_cell(spr_item, spr_desc, font)
	local limit = self.rows + self.cols
	local last_pos

	for n = 1, limit do
		local base_x = ScreenInfo.ww * 0.7
		local base_y = ScreenInfo.hh * 0.25
		local p = n - 1
		local i = p % self.cols
		local j = floor(p/self.rows)
		local x = base_x + (self.offset * scale * i)
		local y = base_y + (self.offset * scale * j)
		local pos = vec2:new(x, y)

		local bg_scale = scale + 0.25
		local ox, oy = 0.5, 0.5
		local e_cell = Concord.entity(self.world)
			:assemble(Items.inventory_cell, spr_item)
			:give("position", pos:copy())
			:give("transform", 0, bg_scale, bg_scale, ox, oy)
			:give("layer", "inventory", 1)

		if n == limit - 1 then
			local sprite = spr_item
			local lx = pos.x
			local ly = pos.y + (oy * 2 * sprite:getHeight() * bg_scale) + 32

			last_pos = vec2:new(lx, ly)
		end
	end

	local e_desc_bg = Concord.entity(self.world)
		:assemble(Items.inventory_desc, spr_desc)
		:give("position", last_pos)
		:give("transform", 0, 1, 1, 0.5, 0.5)
		:give("text", "")
		:give("textf", spr_desc:getWidth(), "center")
		:give("font", font)
end

function Inventory:item_clicked(e)
	local id = e.id.id
	print("item_clicked", id)
end

function Inventory:mouse_hovered_item(e)
	local desc = e.item.desc
	local e_desc_text = self.pool_desc[1].text

	e_desc_text.text = desc
end

function Inventory:mouse_unhovered_item(e)
	local e_desc_text = self.pool_desc[1].text

	e_desc_text.text = ""
end

function Inventory:action_interacted_bag(target_interactive, player)
	player:give("inventory_open")

	for _, e in ipairs(self.pool) do
		e:remove("hidden")
		:give("color_fade_in", self.dur_show)
	end

	for _, e in ipairs(self.pool_cell) do
		e:remove("hidden")
		:give("color_fade_in", self.dur_show)
	end

	local e_desc = self.pool_desc[1]
		:remove("hidden")
		:give("color_fade_in", self.dur_show)
end

function Inventory:keypressed_back(player)
	player:remove("inventory_open")

	for i, e in ipairs(self.pool) do
		e:give("color_fade_out", self.dur_show, nil, function()
			e:give("hidden")

			if i == #self.pool then
				self.world:emit("closed_inventory")
			end
		end)
	end

	for _, e in ipairs(self.pool_cell) do
		e:give("color_fade_out", self.dur_show, nil, function()
			e:give("hidden")
		end)
	end

	local e_desc
	e_desc = self.pool_desc[1]
		:give("color_fade_out", self.dur_show, nil, function()
			e_desc:give("hidden")
		end)
end

function Inventory:draw_ui_layer_ex(layer_n)
	if not (layer_n == 2) then return end

	for _, e in ipairs(self.pool) do
		if not e.hidden then
			local hoverable = e.hoverable
			local transform = e.transform
			local bbox = e.bounding_box
			local a = e.color.color[4]
			local x, y = bbox.screen_pos:unpack()
			local w, h = bbox.size:unpack()

			if transform then
				x = x - transform.ox * transform.sx
				y = y - transform.oy * transform.sy
			end

			if hoverable.is_hovered then
				love.graphics.setColor(
					color_outline_hovered[1],
					color_outline_hovered[2],
					color_outline_hovered[3], a)
			else
				love.graphics.setColor(
					color_outline[1],
					color_outline[2],
					color_outline[3], a)
			end

			love.graphics.setLineWidth(line_width)
			love.graphics.rectangle("line", x, y, w, h)
		end
	end
end

return Inventory

local Concord = require("modules.concord.concord")
local Timer = require("modules.hump.timer")

local Inputs = require("inputs")
local ListByID = require("ctor.list_by_id")
local Palette = require("palette")
local Resources = require("resources")

local min = math.min

local Inventory = Concord.system({
	pool_camera = {"camera"},
	pool_item = {
		constructor = ListByID,
		id = "inventory_item",
		"list_item", "list_group", "item_id"
	},
})

local AssemInventory = require("assemblages.inventory")
local c_f_u = Palette.get("inventory_fill_unhovered")

function Inventory:init(world)
	self.world = world
	self.can_open = true
	self.is_open = false

	self.pool_camera.onAdded = function(pool, e)
		local camera = e.camera
		if camera.is_main then
			self.main_camera = camera.camera
		end
	end
end

function Inventory:open_inventory()
	if not self.can_open then return end
	self.world:emit("on_interact_or_inventory")
	self.world:emit("set_system_to", "dialogues", false)
	self.world:emit("set_post_process_effect", "Blur", true)
	self:create_inventory()
	self.world:emit("create_inventory_key")
	self.world:emit("create_items")
	self.is_open = true
end

function Inventory:close_inventory(not_close)
	@@sassert(not_close, type(not_close) == "boolean")
	self.world:emit("set_system_to", "dialogues", true)
	if not not_close then
		self.world:emit("on_leave_interact_or_inventory")
	end
	self.is_open = false
	self.can_open = false
	self.e_bg:destroy()
	self.e_rect:destroy()
	self.world:emit("destroy_items")
	self.world:emit("set_post_process_effect", "Blur", false)
	self.world:emit("destroy_key", "inventory")
	Timer.after(!(_INPUT_DELAY), function() self.can_open = true end)
end

function Inventory:update(dt)
	if self.can_open and not self.is_open and Inputs.pressed("inventory") then
		!if _DEV then
		local Items = require("items")
		Items.add("flashlight")
		local Notes = require("notes")
		Notes.add("test1")
		Notes.add("test2")
		Notes.add("test3")
		Notes.add("test4")
		Notes.add("test5")
		Notes.add("test6")
		Notes.add("test7")
		Notes.add("test8")
		Notes.add("test9")
		Notes.add("test10")
		!end
		self:open_inventory()
	elseif self.is_open then
		if Inputs.pressed("inventory") then
			Inputs.flush()
			self:close_inventory(true)
			self.world:emit("inventory_to_notes")
			self.world:emit("open_notes")
		elseif Inputs.pressed("cancel") then
			self:close_inventory()
		elseif Inputs.pressed("interact") then
			self.world:emit("show_key", "inventory", false)
		end
	end
end

function Inventory:draw_inventory()
	if not self.is_open then return end
	self.world:emit("draw_sprite_ex", self.e_bg)
	self.world:emit("draw_rect_ex", self.e_rect)

	for _, e in ipairs(self.pool_item) do
		local pos = e.pos
		local rect = e.rect
		love.graphics.setColor(c_f_u)
		love.graphics.rectangle("fill", pos.x, pos.y, rect.w, rect.h)

		self.world:emit("draw_rect_ex", e)
	end
end

function Inventory:create_inventory()
	local _, _, w, h = self.main_camera:getWindow()
	local img = Resources.data.images.bg_item
	local iw, ih = img:getDimensions()
	local bar_h = self.pool_camera[1].bar_height.value

	local pad = 32
	local nh = h - pad * 2 - bar_h * 2
	local scale = min(w/iw, nh/ih)
	local x = w * 0.5
	local y = h * 0.5
	local rows, cols = 2, 3

	self.e_bg = Concord.entity(self.world):assemble(AssemInventory.bg, x, y, scale)
	self.world:emit("create_list_group", "inventory", false, rows * cols)

	local bg_w = iw * scale
	local bg_h = ih * scale
	local orig_x = x - bg_w * 0.5
	local orig_y = y - bg_h * 0.5

	local rx = orig_x + bg_w * 0.4
	local ry = orig_y + pad * 0.5
	local rw = bg_w - orig_x
	local rh = bg_h * 0.4
	self.e_rect = Concord.entity(self.world)
		:give("id", "inventory_rect")
		:give("draw_mode", "line")
		:give("rect", rw, rh)
		:give("pos", rx, ry)
		:give("color", Palette.get("inventory_line_hovered"))

	local w = rw/cols
	local h = rh/rows
	for r = 1, rows do
		for c = 1, cols do
			local x = rx + (c - 1) * w
			local y = ry + (r - 1) * h
			local index = (r - 1) * cols + c
			local e = Concord.entity(self.world)
				:give("id", "cell_" .. index)
				:give("item_id", "inventory_item")
				:give("list_item")
				:give("list_group", "inventory")
				:give("pos", x, y)
				:give("rect", w, h)
				:give("draw_mode", "line")
				:give("color", Palette.get("inventory_line_hovered"))
		end
	end
end

function Inventory:cleanup()
end

return Inventory

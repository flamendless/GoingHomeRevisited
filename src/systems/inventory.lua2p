local Concord = require("modules.concord.concord")
local Timer = require("modules.hump.timer")

local Blur = require("blur")
local Inputs = require("inputs")
local Resources = require("resources")
local Palette = require("palette")

local floor = math.floor

local Inventory = Concord.system({
	pool_camera = {"camera"},
	pool_bg = {"cell_bg", "nf_render_sprite"},
	pool_item = {"item", "nf_render_sprite"},
	pool_cell_line = {"cell_line"},
	pool_cell_fill = {"cell_fill"},
	pool_hovered = {"hovered_cell"},
	pool_text = {"text", "nf_render_text"},
})

local Assemblages = {
	Inventory = require("assemblages.inventory"),
}

local ROWS, COLS = 3, 3
local alpha = 0.75
local alpha2 = alpha - 0.5
local c_l_h = Palette.get("inventory_line_hovered", alpha2)
local c_l_u = Palette.get("inventory_line_unhovered", alpha2)
local c_f_h = Palette.get("inventory_fill_hovered", alpha2)
local c_f_u = Palette.get("inventory_fill_unhovered", alpha2)

function Inventory:init(world)
	self.world = world
	self.can_open = true
	self.is_open = false
	self.pool_camera.onAdded = function(pool, e)
		local camera = e.camera
		if camera.is_main then
			self.main_camera = camera.camera
		end
	end

	self.pool_item.onAdded = function(pool, e)
		self:add_item(e)
	end
end

function Inventory:open_inventory()
	if not self.can_open then return end
	self.world:emit("on_interact_or_inventory")
	self.world:emit("set_sys_dialogues", false)
	self.is_open = true
	Blur.flag_process = true
	self:create_inventory()
	self.world:emit("create_items")
end

function Inventory:close_inventory(not_close)
	@@sassert(not_close, type(not_close) == "boolean")
	if not not_close then
		self.world:emit("on_leave_interact_or_inventory")
	end
	self.world:emit("set_sys_dialogues", true)
	self.is_open = false
	self.can_open = false
	Blur.flag_process = false
	self:hide_inventory()
	self:cleanup()
end

function Inventory:update(dt)
	if self.can_open and not self.is_open and Inputs.pressed("inventory") then
		self:open_inventory()
	elseif self.is_open then
		if Inputs.pressed("cancel") then
			self:close_inventory()
		elseif Inputs.pressed("interact") then
			self:item_interact()
		end
	end

	if self.is_open then
		local dx, dy = 0, 0
		if Inputs.pressed("left") then
			dx = -1
		elseif Inputs.pressed("right") then
			dx = 1
		end
		if Inputs.pressed("up") then
			dy = -1
		elseif Inputs.pressed("down") then
			dy = 1
		end
		if dx ~= 0 or dy ~= 0 then
			self:update_inventory_cells(dx, dy)
		end
		self:update_cell_color()
		self:update_inventory_text()
	end
end

function Inventory:draw_inventory()
	if not self.is_open then return end
	for _, e in ipairs(self.pool_bg) do
		if e.sprite then
			self.world:emit("draw_sprite_ex", e)
		elseif e.rect then
			self.world:emit("draw_rect_ex", e)
		end
	end
	for _, e in ipairs(self.pool_cell_line) do
		self.world:emit("draw_rect_ex", e)
	end
	for _, e in ipairs(self.pool_cell_fill) do
		self.world:emit("draw_rect_ex", e)
	end
	for _, e in ipairs(self.pool_item) do
		self.world:emit("draw_sprite_ex", e)
	end
	for _, e in ipairs(self.pool_text) do
		self.world:emit("draw_text_ex", e)
	end
end

function Inventory:create_inventory()
	local _, _, w, h = self.main_camera:getWindow()
	local img = Resources.data.images.bg_item
	local iw, ih = img:getDimensions()
	local bar_h = self.pool_camera[1].bar_height.value
	local pad = 64
	local pad2 = pad * 0.5
	local nw = w - pad * 2
	local nh = h - pad * 2 - bar_h * 2
	local scale = math.min(nw/iw, nh/ih)
	local x = w - pad2
	local y = h * 0.5

	Concord.entity(self.world):assemble(Assemblages.Inventory.bg,
		x, y, scale, alpha)

	local rx = x - iw * scale * 0.5
	local ry = y - pad2
	local rs = scale * 0.5
	Concord.entity(self.world):assemble(Assemblages.Inventory.rect,
		rx, ry, iw, ih, rs, alpha2)

	local bx = rx - iw * rs * 0.5
	local by = ry - ih * rs * 0.5
	local sw = floor(iw * rs)/COLS
	local sh = floor(ih * rs)/ROWS
	for y = 0, ROWS - 1 do
		for x = 0, COLS - 1 do
			local srx = bx + x * sw
			local sry = by + y * sh
			local i = y * COLS + x
			local a = Concord.entity(self.world):assemble(Assemblages.Inventory.cell,
					srx, sry, sw, sh, alpha2)
				:give("id", "inventory_cell_fill_" .. i)
				:give("cell_fill")
				:give("draw_mode", "fill")
			local b = Concord.entity(self.world):assemble(Assemblages.Inventory.cell,
					srx, sry, sw, sh, alpha2)
				:give("id", "inventory_cell_line_" .. i)
				:give("cell_line")
				:give("draw_mode", "line")
			if y == 0 and x == 0 then
				a:give("hovered_cell")
				b:give("hovered_cell")
			end
		end
	end

	local font = Resources.data.fonts.item_name
	local pad4 = pad2 * 0.5
	local iix = x - iw * scale * 0.5
	local base_y = by + sh * ROWS
	local iiy = base_y + pad4
	local iiy2 = iiy + font:getHeight("") + pad4
	Concord.entity(self.world):assemble(Assemblages.Inventory.text,
		"inventory_name_text", iix, iiy, alpha, "item_name", (iw - 16) * scale)
	Concord.entity(self.world):assemble(Assemblages.Inventory.text,
		"inventory_desc_text", iix, iiy2, alpha, "item_desc", (iw - 16) * scale)
end

function Inventory:hide_inventory()
	for _, e in ipairs(self.pool_bg) do
		e:give("color_fade_out", 0.5)
		:give("color_fade_out_finish", "destroy_entity", 0, e)
	end
	Timer.after(0.5, function() self.can_open = true end)
end

function Inventory:update_inventory_cells(dx, dy)
	local index
	for i, e in ipairs(self.pool_cell_line) do
		if e.hovered_cell then
			e:remove("hovered_cell")
			index = i
			break
		end
	end
	local e_fill = self.pool_cell_fill[index]
	e_fill:remove("hovered_cell")

	local x = (index - 1) % COLS
	local y = floor((index - 1)/COLS)
	x = (x + dx) % COLS
	y = (y + dy) % ROWS
	index = (y * COLS) + x + 1

	local a = self.pool_cell_line[index]
	local b = self.pool_cell_fill[index]
	a:give("hovered_cell")
	b:give("hovered_cell")
end

function Inventory:update_cell_color()
	for _, e in ipairs(self.pool_cell_line) do
		local color
		if e.hovered_cell then
			color = c_l_h
		else
			color = c_l_u
		end
		local c = e.color.value
		c[1] = color[1]
		c[2] = color[2]
		c[3] = color[3]
		c[4] = color[4]
	end
	for _, e in ipairs(self.pool_cell_fill) do
		local color
		if e.hovered_cell then
			color = c_f_h
		else
			color = c_f_u
		end
		local c = e.color.value
		c[1] = color[1]
		c[2] = color[2]
		c[3] = color[3]
		c[4] = color[4]
	end
end

function Inventory:update_inventory_text()
	if #self.pool_text == 0 then return end
	local txt_name = self.pool_text[1]
	local txt_desc = self.pool_text[2]
	txt_name.text.value = ""
	txt_desc.text.value = ""

	for _, e in ipairs(self.pool_item) do
		e:remove("hovered_item")
	end

	for _, e in ipairs(self.pool_cell_fill) do
		if e.hovered_cell and e.cell_item then
			local item_e = e.cell_item.item_e
			txt_name.text.value = item_e.item.name
			txt_desc.text.value = item_e.item.desc
			item_e:give("hovered_item")
			break
		end
	end
end

function Inventory:add_item(item_e)
	@@assert(item_e.__isEntity and item_e.item)
	for _, e in ipairs(self.pool_cell_fill) do
		if not e.cell_item then
			local pos = e.pos
			local rect = e.rect
			e:give("cell_item", item_e)

			local img = item_e.sprite.image
			local iw, ih = img:getDimensions()
			local sx = rect.w/iw
			local sy = rect.h/ih
			item_e:give("pos", pos.x, pos.y)
				:give("transform", 0, sx, sy)
			break
		end
	end
end

function Inventory:item_interact()
	for _, e in ipairs(self.pool_item) do
		if e.hovered_item then
			self.world:emit("on_item_use", e)
			break
		end
	end
end

function Inventory:cleanup()
	for _, e in ipairs(self.pool_bg) do
		e:destroy()
	end
	for _, e in ipairs(self.pool_cell_line) do
		e:destroy()
	end
	for _, e in ipairs(self.pool_cell_fill) do
		e:destroy()
	end
	for _, e in ipairs(self.pool_item) do
		e:destroy()
	end
	for _, e in ipairs(self.pool_text) do
		e:destroy()
	end
end

return Inventory

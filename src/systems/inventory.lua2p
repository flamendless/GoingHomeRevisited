local Concord = require("modules.concord.concord")
local Timer = require("modules.hump.timer")

local Blur = require("blur")
local Inputs = require("inputs")
local Resources = require("resources")
local Palette = require("palette")

local floor = math.floor
local min = math.min

local Inventory = Concord.system({
	pool_camera = {"camera"},
	pool_bg = {"cell_bg", "nf_render_sprite"},
	pool_item = {"item", "sprite", "nf_render_sprite"},
	pool_cell_line = {"cell_line"},
	pool_cell_fill = {"cell_fill"},
	pool_hovered = {"hovered_cell"},
	pool_text = {"text", "nf_render_text", "!item_choice"},
	pool_choices = {"text", "nf_render_text", "item_choice"},
	pool_preview = {"sprite", "item_preview", "nf_render_sprite"},
})

local Assemblages = {
	Inventory = require("assemblages.inventory"),
}

local ROWS, COLS = 3, 3
local PAD_ITEM_CELL = 8
local alpha = 0.75
local alpha2 = alpha - 0.5
local c_l_h = Palette.get("inventory_line_hovered", alpha2)
local c_l_u = Palette.get("inventory_line_unhovered", alpha2)
local c_f_h = Palette.get("inventory_fill_hovered", alpha2)
local c_f_u = Palette.get("inventory_fill_unhovered", alpha2)
local c_h_c = Palette.get("hovered_choice", alpha)
local c_u_c = {1, 1, 1, alpha}

function Inventory:init(world)
	self.world = world
	self.can_open = true
	self.is_open = false
	self.pool_camera.onAdded = function(pool, e)
		local camera = e.camera
		if camera.is_main then
			self.main_camera = camera.camera
		end
	end

	self.pool_item.onAdded = function(pool, e)
		self:add_item(e)
	end
end

function Inventory:open_inventory()
	if not self.can_open then return end
	self.world:emit("on_interact_or_inventory")
	self.world:emit("set_sys_dialogues", false)
	self.is_open = true
	Blur.flag_process = true
	self:create_inventory()
	self.world:emit("create_items")
end

function Inventory:close_inventory(not_close)
	@@sassert(not_close, type(not_close) == "boolean")
	if #self.pool_choices ~= 0 then
		self:on_item_cancel()
		return
	end
	if not not_close then
		self.world:emit("on_leave_interact_or_inventory")
	end
	self.world:emit("set_sys_dialogues", true)
	self.is_open = false
	self.can_open = false
	Blur.flag_process = false
	self:hide_inventory()
	self:cleanup()
end

function Inventory:update(dt)
	if self.can_open and not self.is_open and Inputs.pressed("inventory") then
		self:open_inventory()
	elseif self.is_open then
		if Inputs.pressed("cancel") then
			self:close_inventory()
		elseif Inputs.pressed("interact") then
			self:item_interact()
		end
	end

	if self.is_open then
		local dx, dy = 0, 0
		if Inputs.pressed("left") then
			dx = -1
		elseif Inputs.pressed("right") then
			dx = 1
		end
		if Inputs.pressed("up") then
			dy = -1
		elseif Inputs.pressed("down") then
			dy = 1
		end

		if dx ~= 0 or dy ~= 0 then
			if #self.pool_choices == 0 then
				self:update_inventory_cells(dx, dy)
			else
				self:update_inventory_choices(dy)
			end
		end

		self:update_cell_color()
		self:update_inventory_text()
		self:update_inventory_choices_color()
	end
end

function Inventory:draw_inventory()
	if not self.is_open then return end
	for _, e in ipairs(self.pool_bg) do
		if e.sprite then
			self.world:emit("draw_sprite_ex", e)
		elseif e.rect then
			self.world:emit("draw_rect_ex", e)
		end
	end
	for _, e in ipairs(self.pool_cell_line) do
		self.world:emit("draw_rect_ex", e)
	end
	for _, e in ipairs(self.pool_cell_fill) do
		self.world:emit("draw_rect_ex", e)
	end
	for _, e in ipairs(self.pool_item) do
		self.world:emit("draw_sprite_ex", e)
	end
	for _, e in ipairs(self.pool_text) do
		self.world:emit("draw_text_ex", e)
	end
	for _, e in ipairs(self.pool_choices) do
		self.world:emit("draw_text_ex", e)
	end
	for _, e in ipairs(self.pool_preview) do
		self.world:emit("draw_sprite_ex", e)
	end
end

function Inventory:create_inventory()
	local _, _, w, h = self.main_camera:getWindow()
	local img = Resources.data.images.bg_item
	local iw, ih = img:getDimensions()
	local bar_h = self.pool_camera[1].bar_height.value
	local pad = 48
	local pad2 = pad * 0.5
	local nw = w - pad * 2
	local nh = h - pad * 2 - bar_h * 2
	local scale = min(nw/iw, nh/ih)
	local x = w - pad2
	local y = h * 0.5

	Concord.entity(self.world):assemble(Assemblages.Inventory.bg,
		x, y, scale, alpha)

	local rx = x - iw * scale * 0.5
	local ry = y - pad
	local rs = scale * 0.5
	Concord.entity(self.world):assemble(Assemblages.Inventory.rect,
		rx, ry, iw, ih, rs, alpha2)

	local bx = rx - iw * rs * 0.5
	local by = ry - ih * rs * 0.5
	local sw = iw * rs / COLS
	local sh = ih * rs / ROWS
	for y = 0, ROWS - 1 do
		for x = 0, COLS - 1 do
			local srx = bx + x * sw
			local sry = by + y * sh
			local i = y * COLS + x
			local a = Concord.entity(self.world):assemble(Assemblages.Inventory.cell,
					srx, sry, sw, sh, alpha2)
				:give("id", "inventory_cell_fill_" .. i)
				:give("cell_fill")
				:give("draw_mode", "fill")
			local b = Concord.entity(self.world):assemble(Assemblages.Inventory.cell,
					srx, sry, sw, sh, alpha2)
				:give("id", "inventory_cell_line_" .. i)
				:give("cell_line")
				:give("draw_mode", "line")
			if y == 0 and x == 0 then
				a:give("hovered_cell")
				b:give("hovered_cell")
			end
		end
	end

	local font = Resources.data.fonts.item_name
	local pad4 = pad2 * 0.5
	local iix = x - iw * scale * 0.5
	local base_y = by + sh * ROWS
	local iiy = base_y + pad2
	local iiy2 = iiy + font:getHeight("") + pad4
	Concord.entity(self.world):assemble(Assemblages.Inventory.text,
		"inventory_name_text", iix, iiy, alpha, "item_name", (iw - 16) * scale)
	Concord.entity(self.world):assemble(Assemblages.Inventory.text,
		"inventory_desc_text", iix, iiy2, alpha, "item_desc", (iw - 16) * scale)
end

function Inventory:hide_inventory()
	for _, e in ipairs(self.pool_bg) do
		e:give("color_fade_out", 0.5)
		:give("color_fade_out_finish", "destroy_entity", 0, e)
	end
	Timer.after(0.5, function() self.can_open = true end)
end

function Inventory:update_inventory_cells(dx, dy)
	local index
	for i, e in ipairs(self.pool_cell_line) do
		if e.hovered_cell then
			e:remove("hovered_cell")
			index = i
			break
		end
	end
	local e_fill = self.pool_cell_fill[index]
	e_fill:remove("hovered_cell")

	local x = (index - 1) % COLS
	local y = floor((index - 1)/COLS)
	x = (x + dx) % COLS
	y = (y + dy) % ROWS
	index = (y * COLS) + x + 1

	local a = self.pool_cell_line[index]
	local b = self.pool_cell_fill[index]
	a:give("hovered_cell")
	b:give("hovered_cell")
end

function Inventory:update_inventory_choices(dy)
	local index
	for i, e in ipairs(self.pool_choices) do
		if e.hovered_item then
			index = i
			e:remove("hovered_item")
			break
		end
	end
	index = mathx.wrap(index + dy, 1, #self.pool_choices + 1)
	self.pool_choices[index]:give("hovered_item")
end

function Inventory:update_cell_color()
	for _, e in ipairs(self.pool_cell_line) do
		local color
		if e.hovered_cell then
			color = c_l_h
		else
			color = c_l_u
		end
		local c = e.color.value
		c[1] = color[1]
		c[2] = color[2]
		c[3] = color[3]
		c[4] = color[4]
	end
	for _, e in ipairs(self.pool_cell_fill) do
		local color
		if e.hovered_cell then
			color = c_f_h
		else
			color = c_f_u
		end
		local c = e.color.value
		c[1] = color[1]
		c[2] = color[2]
		c[3] = color[3]
		c[4] = color[4]
	end
end

function Inventory:update_inventory_text()
	if #self.pool_text == 0 then return end
	local txt_name = self.pool_text[1]
	local txt_desc = self.pool_text[2]
	txt_name.text.value = ""
	txt_desc.text.value = ""

	for _, e in ipairs(self.pool_item) do
		e:remove("hovered_item")
	end

	for _, e in ipairs(self.pool_cell_fill) do
		if e.hovered_cell and e.cell_item then
			local item_e = e.cell_item.item_e
			txt_name.text.value = item_e.item.name
			txt_desc.text.value = item_e.item.desc
			item_e:give("hovered_item")
			break
		end
	end
end

function Inventory:update_inventory_choices_color()
	if #self.pool_choices == 0 then return end
	for _, e in ipairs(self.pool_choices) do
		local color
		if e.hovered_item then
			color = c_h_c
		else
			color = c_u_c
		end
		local c = e.color.value
		c[1] = color[1]
		c[2] = color[2]
		c[3] = color[3]
		c[4] = color[4]
	end
end

function Inventory:add_item(item_e)
	@@assert(item_e.__isEntity and item_e.item)
	for _, e in ipairs(self.pool_cell_fill) do
		if not e.cell_item then
			local pos = e.pos
			local rect = e.rect
			e:give("cell_item", item_e)
			item_e:give("pos", pos.x + rect.w * 0.5, pos.y + rect.h * 0.5)
				:give("transform", 0, 1, 1, 0.5, 0.5)
				:give("auto_scale", rect.w - PAD_ITEM_CELL, rect.h - PAD_ITEM_CELL, true)
			break
		end
	end
end

function Inventory:item_interact()
	if #self.pool_choices ~= 0 then
		for _, e in ipairs(self.pool_choices) do
			if e.hovered_item then
				local str = e.text.value
				local signal = "on_item_" .. str
				self.world:emit(signal, e.item_choice.entity)
				break
			end
		end
		return
	end

	for _, e in ipairs(self.pool_item) do
		if e.hovered_item then
			local txt_name = self.pool_text[1]
			local txt_desc = self.pool_text[2]
			txt_name:give("hidden")
			txt_desc:give("hidden")

			local pos = txt_name.pos
			local limit = txt_name.textf.limit
			local font = txt_name.font.value
			local fh = font:getHeight("")
			for i, str in ipairs(e.item_choices.value) do
				local x = pos.x
				local y = pos.y + fh * (i - 1)
				local e_c = Concord.entity(self.world):assemble(Assemblages.Inventory.text,
					"choice_" .. str, x, y, alpha, "item_name", limit)
				:give("item_choice", e)
				:give("text", str)
				if i == 1 then
					e_c:give("hovered_item")
				end
			end
			self.world:emit("create_item_preview", self.pool_bg[1], e)
			break
		end
	end
end

function Inventory:on_item_cancel()
	for _, e in ipairs(self.pool_choices) do
		e:destroy()
	end
	for _, e in ipairs(self.pool_text) do
		e:remove("hidden")
	end
	for _, e in ipairs(self.pool_preview) do
		e:destroy()
	end
end

function Inventory:cleanup()
	for _, e in ipairs(self.pool_bg) do
		e:destroy()
	end
	for _, e in ipairs(self.pool_cell_line) do
		e:destroy()
	end
	for _, e in ipairs(self.pool_cell_fill) do
		e:destroy()
	end
	for _, e in ipairs(self.pool_item) do
		e:destroy()
	end
	for _, e in ipairs(self.pool_text) do
		e:destroy()
	end
	for _, e in ipairs(self.pool_choices) do
		e:destroy()
	end
	for _, e in ipairs(self.pool_preview) do
		e:destroy()
	end
end

return Inventory

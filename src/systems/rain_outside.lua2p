local Concord = require("modules.concord.concord")

local random = love.math.random

local RainOutside = Concord.system({
	pool_empty = {"empty_rain"},
	pool_data = {"rain_data", "screen_size"},
	pool_drop = {"rain_drop", "position", "acceleration", "collider3d", "bump3d"},
	pool_splash = {"rain_splash", "position"}
})

function RainOutside:init(world)
	self.world = world
	self.data = nil

	self.pool_data.onEntityAdded = function(pool, e)
		self.data = e.rain_data.data
		self.metadata = e.rain_data.data.metadata
		self.max_width = e.screen_size.width * 1.5
		self.max_height = e.screen_size.height

		for i = 1, e.rain_data.buffer do
			local empty = Concord.entity(self.world)
				:give("empty_rain")
		end
	end
end

function RainOutside:emit_rain(amount, max_amount, x_start, max_width)
	if (#self.pool_drop > max_amount) or (amount > #self.pool_empty) then
		return
	end

	local drop = self.data.drop
	local random_amount = random(amount/2, amount * 1.5)
	local x_start = x_start or 0
	local max_width = x_start + (max_width or self.max_width)

	for i = 1, random_amount do
		local r = random(1, #drop)
		local img = drop[r]
		local x = random(x_start, max_width)
		local pos = vec2:new(x, -64)
		local anim_data = {}

		table.copy(self.metadata.drop, anim_data)
		anim_data.spritesheet = img

		-- local ay = random(320, 1280)
		local ay = 128
		local accel = vec2:new(0, ay)
		local alpha = random(10, 100)/100
		local z = random(1, 10)
		local scale = random(20, 70)/100 + (z/10)

		local e = self.pool_empty[i]
		if e then
			e:give("animation_data", anim_data)
			:give("position", pos)
			:give("animation")
			:give("rain_drop")
			:give("acceleration", accel)
			:give("z_index", z)
			:give("color", {1, 1, 1, alpha})
			:give("transform", 0, scale, scale, 9, 24)
			:give("collider3d", vec3:new(4, 4, 4))
			:give("bump3d")
			:give("body")
			:remove("empty_rain")
		end
	end
end

function RainOutside:emit_splash(e)
	local splash = self.data.splash
	local r = random(1, #splash)
	local img = splash[r]
	local anim_data = {}

	table.copy(self.metadata.splash, anim_data)
	anim_data.spritesheet = img

	e:give("rain_splash")
	:give("animation_on_complete", function()
		e:remove("animation_data")
		:remove("animation")
		:remove("rain_splash")
		:remove("position")
		:remove("transform")
		:remove("z_index")
		:remove("color")
		:remove("collider3d")
		:remove("bump3d")
		:remove("body")
		:give("empty_rain")
	end, "pauseAtEnd", true)
	self.world:emit("update_animation_data", e, anim_data)
end

function RainOutside:update(dt)
	for _, e in ipairs(self.pool_drop) do
		local pos = e.position.pos
		local accel = e.acceleration.accel
		local z_index = e.z_index.z

		local dy = accel.y * dt
		e.body.vel_y = dy
		e.body.dy = 1
	end
	self:post_update(dt)
end

function RainOutside:post_update(dt)
	for _, e in ipairs(self.pool_drop) do
		local pos = e.position.pos
		if e.collider3d.is_hit or (pos.y > self.max_height) then
			e:remove("rain_drop")
			:remove("acceleration")
			self:emit_splash(e)
		end
	end
end

return RainOutside

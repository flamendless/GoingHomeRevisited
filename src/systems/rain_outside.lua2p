local Concord = require("modules.concord.concord")

local random = love.math.random

local RainOutside = Concord.system({
	pool_empty = {"empty_rain"},
	pool_data = {"rain_data", "screen_size"},
	pool_drop = {"rain_drop", "position", "acceleration", "collider_circle"},
	pool_splash = {"rain_splash", "position"}
})

function RainOutside:init(world)
	self.world = world
	self.data = nil

	self.pool_data.onEntityAdded = function(pool, e)
		self.data = e.rain_data.data
		self.metadata = e.rain_data.data.metadata
		self.max_width = e.screen_size.width * 1.5
		self.max_height = e.screen_size.height

		for i = 1, e.rain_data.buffer do
			local empty = Concord.entity(self.world)
				:give("empty_rain")
		end
	end
end

function RainOutside:emit_rain(amount, max_amount)
	if (#self.pool_drop > max_amount) or (amount > #self.pool_empty) then
		return
	end

	local drop = self.data.drop
	local random_amount = random(amount/2, amount * 1.5)

	for i = 1, random_amount do
		local r = random(1, #drop)
		local img = drop[r]
		local x = random(1, self.max_width)
		local pos = vec2:new(x, -64)
		local anim_data = {}

		table.copy(self.metadata.drop, anim_data)
		anim_data.spritesheet = img

		local ay = random(320, 1280)
		local accel = vec2:new(0, ay)
		local alpha = random(10, 100)/100
		local z = random(1, 10)
		local scale = random(20, 70)/100 + (z/10)

		local e = self.pool_empty[i]
		if e then
			e:give("animation_data", anim_data)
			:give("position", pos)
			:give("animation")
			:give("rain_drop")
			:give("acceleration", accel)
			:give("z_index", z)
			:give("color", {1, 1, 1, alpha})
			:give("transform", 0, scale, scale)
			:give("collider_circle", 4, vec2:new(9, 32))
			:remove("empty_rain")
		end
	end
end

function RainOutside:emit_splash(e)
	local splash = self.data.splash
	local r = random(1, #splash)
	local img = splash[r]
	local anim_data = {}

	table.copy(self.metadata.splash, anim_data)
	anim_data.spritesheet = img

	e:give("rain_splash")
	:give("animation_on_complete", function()
		e:remove("animation_data")
		:remove("animation")
		:remove("rain_splash")
		:remove("position")
		:remove("transform")
		:remove("z_index")
		:remove("color")
		:remove("collider_circle")
		:give("empty_rain")
	end, "pauseAtEnd", true)
	self.world:emit("update_animation_data", e, anim_data)
end

function RainOutside:update(dt)
	for _, e in ipairs(self.pool_drop) do
		local pos = e.position.pos
		local accel = e.acceleration.accel
		local col = e.collider_circle
		local z_index = e.z_index.z

		local dy = pos.y + accel.y * dt

		pos.y = dy

		self.world:emit("check_collision", e)

		if col.is_hit or (pos.y > self.max_height) then
			e:remove("rain_drop")
			:remove("acceleration")
			self:emit_splash(e)
		end
	end
end

return RainOutside

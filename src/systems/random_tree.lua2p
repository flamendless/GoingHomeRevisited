local Concord = require("modules.concord.concord")
local Lume = require("modules.lume.lume")

local floor = math.floor
local max = math.max

local RandomTree = Concord.system({
	pool_data = {"tree_data"},
	pool_tree = {"tree", "position", "sprite"}
})
local Assemblages = {
	Intro = require("assemblages.intro")
}

local c = { yes = 0.4, no = 0.6 }

function RandomTree:computer_max_n(data)
	for _, img in ipairs(data.tree_data.images) do
		data.largest_w = max(data.largest_w, img:getWidth())
	end
	data.max_n = floor(data.tree_data.max_width/data.largest_w)
end

function RandomTree:init()
	self.world = self:getWorld()

	self.data_map = unique_mapping:new()
	self.data = {}

	self.pool_data.onEntityAdded = function(pool_data, e)
		local data = e:get("tree_data")
		local i = self.data_map:map(e)
		self.data[i] = {
			tree_data = data.data,
			chance = data.data.chance,
			largest_w = 0,
			max_n = 0,
		}
		self:computer_max_n(self.data[i])
	end
end

function RandomTree:generate_tree(e)
	local index = self.data_map:map(e)
	local data = self.data[index]
	local images = data.tree_data.images

	local i = 0
	while (i < data.max_n) do
		local chance = Lume.weightedchoice(data.chance)
		if chance == "yes" then
			local r = love.math.random(1, #images)
			local img = images[r]
			local x = i * data.largest_w
			local y = 0
			local tree = Concord.entity(self.world)
				:assemble(Assemblages.Intro.tree, img, vec2:new(x, y), index, data.tree_data.parallax, data.tree_data.z_index)
		end
		i = i + 1
	end
end

function RandomTree:append_tree(index, e)
	local data = self.data[index]
	local images = data.tree_data.images

	local r = love.math.random(1, #images)
	local img = images[r]
	local x = data.tree_data.max_width + love.math.random(32, 128)
	local y = 0
	e:give("sprite", img)
	:give("position", vec2:new(x, y))
end

function RandomTree:update(dt)
	for _, e in ipairs(self.pool_tree) do
		local tree = e:get("tree").index
		local pos = e:get("position").pos
		local sprite = e:get("sprite").sprite

		if (pos.x + sprite:getWidth() < 0) then
			e:remove("sprite")
			:remove("position")
			self:append_tree(tree, e)
		end
	end
end

return RandomTree

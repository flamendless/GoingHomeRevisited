local Concord = require("modules.concord.concord")
local Lume = require("modules.lume.lume")

local floor = math.floor
local max = math.max

local RandomTree = Concord.system({
	pool_data = {"tree_data"},
	pool_bg_tree = {"bg_tree", "position"},
	pool_tree = {"tree", "position", "sprite"}
})

local Intro = require("assemblages.intro")

local c = {yes = 0.4, no = 0.6}

function RandomTree:computer_max_n(data)
	for _, img in ipairs(data.tree_data.images) do
		data.largest_w = max(data.largest_w, img:getWidth())
	end

	data.max_n = floor(data.tree_data.max_width/data.largest_w)
end

function RandomTree:init()
	self.world = self:getWorld()
	self.data_map = unique_mapping:new()
	self.data = {}

	self.pool_data.onEntityAdded = function(pool, e)
		local data = e.tree_data
		local i = self.data_map:map(e)

		self.data[i] = {
			tree_data = data.data,
			chance = data.data.chance,
			largest_w = 0,
			max_n = 0,
		}
		self:computer_max_n(self.data[i])
	end
end

function RandomTree:validate_tree(e)
	!if _ASSERT then
	local index = self.data_map:map(e)
	local data = self.data[index]

	Assert.should_table(data)
	!end
end

function RandomTree:start_bg_trees(dur)
	for _, e in ipairs(self.pool_bg_tree) do
		e:give("move_to_x", 0, dur)
			:give("move_on_complete", function()
				e:remove("parallax_stop")

				local bg_tree = e.bg_tree

				if bg_tree.is_cover then
					e:destroy()
				end
			end)
	end
end

function RandomTree:generate_tree(e)
	local index = self.data_map:map(e)
	local data = self.data[index]
	local images = data.tree_data.images
	local i = 0

	while (i < data.max_n) do
		local chance = Lume.weightedchoice(data.chance)

		if chance == "yes" then
			local r = love.math.random(1, #images)
			local img = images[r]
			local x = i * data.largest_w
			local y = 0
			local tree = Concord.entity(self.world)
				:assemble(Intro.tree, img, vec2:new(x, y),
					index, data.tree_data.parallax, data.tree_data.z_index)
		end

		i = i + 1
	end
end

function RandomTree:append_tree(index, e)
	local data = self.data[index]
	local images = data.tree_data.images

	local r = love.math.random(1, #images)
	local img = images[r]
	local x = data.tree_data.max_width + love.math.random(32, 128)
	local y = 0

	e:give("sprite", img)
	:give("position", vec2:new(x, y))
end

function RandomTree:update(dt)
	for _, e in ipairs(self.pool_tree) do
		local tree = e.tree.index
		local pos = e.position.pos
		local sprite = e.sprite.sprite

		if (pos.x + sprite:getWidth() < 0) then
			e:remove("sprite")
			:remove("position")
			self:append_tree(tree, e)
		end
	end
end

return RandomTree

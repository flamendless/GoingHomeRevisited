local Concord = require("modules.concord.concord")

local Task = Concord.system({
	pool_task = {"task"},
	pool_subtask = {"subtask"},
	pool_task_update = {"task_on_update"},
	pool_task_await = {"task_await"},
	pool_subtask_reliance = {"subtask_reliance"},
})

function Task:init(world)
	self.world = world
	self.active_task = nil
	self.active_subtask = nil
	self.waiting_task = false
	self.waiting_subtask = false

	self.pool_task.onAdded = function(pool, e)
		if self.waiting_task then
			self.world:emit("show_text_paint", e, 1.25)
			self.active_task = e
			self.waiting_task = false
		end
	end
	self.pool_subtask.onAdded = function(pool, e)
		if self.waiting_subtask then
			self.world:emit("show_text_paint", e, 1.25)
			self.active_subtask = e
			self.waiting_subtask = false
		end
	end
end

function Task:show_next_task(dur)
	@@assert(type(dur) == "number")
	self.active_task = self.pool_task[1]
	if self.active_task then
		self.world:emit("show_text_paint", self.active_task, dur)
	else
		self.waiting_task = true
	end
end

function Task:show_next_subtask(dur)
	@@assert(type(dur) == "number")
	self.active_subtask = self.pool_subtask[1]
	if self.active_subtask then
		self.world:emit("show_text_paint", self.active_subtask, dur)
	else
		self.waiting_subtask = true
	end
end

function Task:on_complete_task(timeline, dur)
	@@assert(self.active_task, "Can not complete a non-existing task")
	@@sassert(timeline, timeline._type == "TLE")
	@@assert(type(dur) == "number")
	self.world:emit("fade_text_paint", self.active_task, dur,
		function()
			for _, e in ipairs(self.pool_task_await) do
				e:destroy()
			end
			self.active_task:remove("task")
			self.active_task = nil
			if timeline then
				timeline:Unpause()
			end
		end)
end

function Task:on_complete_subtask(timeline, dur)
	@@assert(self.active_subtask, "Can not complete non-existing subtask")
	@@sassert(timeline, timeline._type == "TLE")
	@@assert(type(dur) == "number")
	self.world:emit("fade_text_paint", self.active_subtask, dur,
		function()
			self.active_subtask:remove("subtask")
			self.active_subtask = nil
			if timeline then
				timeline:Unpause()
			end
		end)
end

function Task:fade_out_task_await(dur)
	@@assert(type(dur) == "number")
	for _, e in ipairs(self.pool_task_await) do
		e:give("color_fade_out", dur)
	end
end

function Task:update(dt)
	for _, e in ipairs(self.pool_task_update) do
		local on_update = e.task_on_update
		self.world:emit(on_update.signal, dt, e, unpack(on_update.args))
	end

	local completed = 0
	for _, e in ipairs(self.pool_subtask_reliance) do
		local sr = e.subtask_reliance
		if not sr.completed then
			local count = 0
			for _, v in ipairs(sr.list) do
				if v.subtask_completed then
					count = count + 1
				end
			end

			if count == #sr.list then
				sr.completed = true
			end
		end

		if sr.completed then
			completed = completed + 1
		end

		if completed == #self.pool_subtask_reliance then
			self.world:emit("on_subtasks_finish")
		end
	end
end

function Task:clear_subtasks()
	for _, e in ipairs(self.pool_subtask_reliance) do
		e:remove("subtask_reliance")
	end
end

return Task

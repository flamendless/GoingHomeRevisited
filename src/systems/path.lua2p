local Concord = require("modules.concord.concord")
local Flux = require("modules.flux.flux")

local insert = table.insert
local random = love.math.random

local Path = Concord.system({
	pool = {"path", "pos"},
	pool_camera = {"camera"},
})

function Path:init(world)
	self.world = world

	self.pool_camera.onAdded = function(pool, e)
		self.camera = e.camera.camera
	end
end

function Path:move_to_next_point(e, event)
	if not self.pool:has(e) then return end
	@@assert(e.__isEntity)
	local path = e.path
	local pos = e.pos
	local low = path.current_point
	local dur = random(2, 8)
	local high = low + dur
	local points = {}

	if high > path.n_points then
		high = path.n_points
	end

	for i = low, high do
		local p = path.points[i]
		insert(points, p.x)
		insert(points, p.y)
	end

	local b = love.math.newBezierCurve(unpack(points))
	local state = {time = 0}
	local f = Flux.to(state, dur, {time = 1})

	f:onupdate(function()
		local dx, dy = b:evaluate(state.time)
		pos.x = dx
		pos.y = dy

		if event then
			self.world:emit(event, e)
		end
	end)

	f:oncomplete(function()
		path.current_point = high
		if path.current_point >= path.n_points then
			path.current_point = 1
			tablex.reverse(path.points)
		end

		if e.path_loop then
			self:move_to_next_point(e, event)
		end
	end)
end

!if _DEV then
local Slab = require("modules.slab")
local flags = {
	path = false,
	bezier = false,
}
local component_filter = "path"
local alpha = 0.3

function Path:debug_toggle_path(bool, filter)
	@@assert(type(bool) == "boolean")
	@@sassert(filter, type(filter) == "string")
	self.debug_show = bool
	flags.path = bool
	component_filter = filter
end

function Path:debug_update(dt)
	if not self.debug_show then return end
	self.debug_show = Slab.BeginWindow("Path", {Title = "Path", IsOpen = self.debug_show})

	if Slab.CheckBox(flags.path, "Path") then
		flags.path = not flags.path
	end

	if Slab.CheckBox(flags.bezier, "Bezier") then
		flags.bezier = not flags.bezier
	end

	Slab.EndWindow()
end

function Path:debug_draw()
	if not self.debug_show then return end
	if flags.path then
		local scale = 1
		if self.camera then
			scale = 1/self.camera:getScale()
		end
		love.graphics.setLineWidth(scale)
		for _, e in ipairs(self.pool) do
			if component_filter and e[component_filter] then
				local path = e.path
				if not flags.bezier then
					for i = 1, path.n_points - 1 do
						local a = path.points[i]
						local b = path.points[i + 1]
						if i < path.current_point then
							love.graphics.setColor(1, 0, 0, alpha)
						else
							love.graphics.setColor(1, 1, 0, alpha)
						end
						love.graphics.line(a.x, a.y, b.x, b.y)
					end
				else
					for i = 1, path.n_points - 2, 2 do
						local a = path.points[i]
						local b = path.points[i + 1]
						local c = path.points[i + 2]
						local bc = love.math.newBezierCurve({
								a.x, a.y,
								b.x, b.y,
								c.x, c.y,
							})
						if i < path.current_point then
							love.graphics.setColor(1, 0, 0, alpha)
						else
							love.graphics.setColor(1, 1, 0, alpha)
						end
						love.graphics.line(bc:render())
					end
				end
			end
		end
	end
end
!end

return Path

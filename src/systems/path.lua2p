local Concord = require("modules.concord.concord")
local Flux = require("modules.flux.flux")

local insert = table.insert
local random = love.math.random

local Path = Concord.system({
	pool = {"path", "pos"},
	pool_camera = {"camera"},
})

function Path:init(world)
	self.world = world

	self.pool_camera.onAdded = function(pool, e)
		self.camera = e.camera.camera
	end
end

function Path:move_to_next_point(e, event)
	@@assert(e.__isEntity)
	if not self.pool:has(e) then return end
	local path = e.path
	local pos = e.pos
	local bezier_curve = e.apply_bezier_curve
	local dur = e.path_dur and e.path_dur.value or random(2, 8)
	local low = path.current_point
	local high = low + (path.max or dur)

	if high > path.n_points then
		high = path.n_points
	end

	local points = {}
	for i = low, high do
		local p = path.points[i]
		if bezier_curve then
			insert(points, p.x)
			insert(points, p.y)
		else
			insert(points, {x = p.x, y = p.y})
		end
	end

	local dp
	if bezier_curve then
		dp = love.math.newBezierCurve(unpack(points))
	end

	local state = {time = 0}
	local f

	if bezier_curve then
		f = Flux.to(state, dur, {time = 1})
	else
		local cp = points[1]
		local ep = points[#points]
		state.x, state.y = cp.x, cp.y
		f = Flux.to(state, dur, {
			x = ep.x,
			y = ep.y,
		})
	end

	f:onupdate(function()
		local dx, dy
		if bezier_curve then
			dx, dy = dp:evaluate(state.time)
		else
			dx, dy = state.x, state.y
		end

		pos.x = dx
		pos.y = dy
		if event then
			self.world:emit(event, e)
		end
	end)

	f:oncomplete(function()
		path.current_point = high

		if path.current_point >= path.n_points then
			path.current_point = 1

			if e.path_loop then
				tablex.reverse(path.points)
			end

			local on_end = e.on_path_reached_end
			if on_end then
				self.world:emit(on_end.signal, unpack(on_end.args))
			end

			if e and (not e.path_loop) and (not e.path_repeat) then
				return
			end
		end

		self:move_to_next_point(e, event)
	end)
end

!if _DEV then
local Slab = require("modules.slab")
local flags = {
	path = false,
	bezier = false,
}
local component_filter = "path"
local alpha = 0.3

function Path:debug_toggle_path(bool, filter)
	@@assert(type(bool) == "boolean")
	@@sassert(filter, type(filter) == "string")
	self.debug_show = bool
	flags.path = bool
	component_filter = filter
end

function Path:debug_update(dt)
	if not self.debug_show then return end
	self.debug_show = Slab.BeginWindow("Path", {Title = "Path", IsOpen = self.debug_show})

	if Slab.CheckBox(flags.path, "Path") then
		flags.path = not flags.path
	end

	if Slab.CheckBox(flags.bezier, "Bezier") then
		flags.bezier = not flags.bezier
	end

	Slab.EndWindow()
end

function Path:debug_draw()
	if not self.debug_show then return end
	if flags.path then
		local scale = 1
		if self.camera then
			scale = 1/self.camera:getScale()
		end
		love.graphics.setLineWidth(scale)
		for _, e in ipairs(self.pool) do
			if component_filter and e[component_filter] then
				local path = e.path
				if not flags.bezier then
					for i = 1, path.n_points - 1 do
						local a = path.points[i]
						local b = path.points[i + 1]
						if i < path.current_point then
							love.graphics.setColor(1, 0, 0, alpha)
						else
							love.graphics.setColor(1, 1, 0, alpha)
						end
						love.graphics.line(a.x, a.y, b.x, b.y)
					end
				else
					for i = 1, path.n_points - 2, 2 do
						local a = path.points[i]
						local b = path.points[i + 1]
						local c = path.points[i + 2]
						local bc = love.math.newBezierCurve({
								a.x, a.y,
								b.x, b.y,
								c.x, c.y,
							})
						if i < path.current_point then
							love.graphics.setColor(1, 0, 0, alpha)
						else
							love.graphics.setColor(1, 1, 0, alpha)
						end
						love.graphics.line(bc:render())
					end
				end
			end
		end
	end
end
!end

return Path

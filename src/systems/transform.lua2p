local Concord = require("modules.concord.concord")

local min = math.min

local Transform = Concord.system({
	pool = {"transform"},
	pool_quad = {"quad_transform"},
	pool_anchor = {"pos", "anchor"},
	pool_camera = {"pos", "camera"},
	pool_attach = {"pos", "attach_to"},
	pool_auto_scale = {"transform", "auto_scale"},
	pool_spawn = {"pos", "attach_to_spawn_point"}
})

function Transform:init()
	self.pool_anchor.onAdded = function(pool, e)
		self:update_anchor(e)
	end

	self.pool_attach.onAdded = function(pool, e)
		local attach = e.attach_to
		local target = attach.target_e

		!if _DEV then
		if not target:has("pos") then
			error("Target entity must have a pos component")
		end
		!end
	end

	self.pool_auto_scale.onAdded = function(pool, e)
		local auto_scale = e.auto_scale
		local transform = e.transform
		local anim_data = e.animation_data

		if anim_data then
			local dsx = auto_scale.target_width/anim_data.frame_width
			local dsy = auto_scale.target_height/anim_data.frame_height

			if auto_scale.is_proportion then
				local scale = min(dsx, dsy)

				transform.sx = transform.sx * scale
				transform.sy = transform.sy * scale
			else
				transform.sx = transform.sx * dsx
				transform.sy = transform.sy * dsy
			end
		end
	end
end

function Transform:update_anchor(e)
	local anchor = e.anchor
	local pos = e.pos
	local target_pos = anchor.entity.pos
	local target_sprite = anchor.entity.sprite

	@@assert(target_sprite.image:type() == "Image")

	local target_transform = anchor.entity.transform
	local sx = target_transform.sx or 1
	local sy = target_transform.sy or 1
	local ox = target_transform.ox or 0
	local oy = target_transform.oy or 0

	local w = target_sprite.image:getWidth() * sx
	local h = target_sprite.image:getHeight() * sy
	local x = target_pos.x - ox * sx
	local y = target_pos.y - oy * sy

	if anchor.anchor_x == "left" then
	elseif anchor.anchor_x == "center" then
		x = x + w/2
	elseif anchor.anchor_y == "right" then
		x = x + w
	end

	if anchor.anchor_y == "top" then
	elseif anchor.anchor_y == "center" then
		y = y + h/2
	elseif anchor.anchor_y == "bottom" then
		y = y + h
	end

	if anchor.padding_x then
		x = x + anchor.padding_x
	end
	if anchor.padding_y then
		y = y + anchor.padding_y
	end

	pos.x = x
	pos.y = y
	pos.orig_x = pos.x
	pos.orig_y = pos.y
end

function Transform:canvas_resize(ww, wh, scale)
	for _, e in ipairs(self.pool) do
		local transform = e.transform

		if transform then
			transform.sx = scale
			transform.sy = scale
		end
	end
end

function Transform:update_position(l, t)
	for _, e in ipairs(self.pool_camera) do
		local pos = e.pos

		pos.x = pos.x + l
		pos.y = pos.y + t
		pos.orig_x = pos.x
		pos.orig_y = pos.y
	end
end

function Transform:update_attachment(e)
	local attach = e.attach_to
	local pos = e.pos
	local offset = e.attach_to_offset
	local target = attach.target_e
	local tx, ty = target.pos.x, target.pos.y

	if offset then
		tx = tx + offset.ox
		ty = ty + offset.oy
	end

	pos.x = tx
	pos.y = ty
end

function Transform:update(dt)
	for _, e in ipairs(self.pool_anchor) do
		self:update_anchor(e)
	end

	for _, e in ipairs(self.pool_attach) do
		self:update_attachment(e)
	end

	for _, e in ipairs(self.pool_spawn) do
		local pos = e.pos
		local sp = e.attach_to_spawn_point.pos

		pos.x = sp.x
		pos.y = sp.y
	end
end

return Transform

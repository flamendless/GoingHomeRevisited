local Concord = require("modules.concord.concord")
local Log = require("modules.log.log")

local min = math.min
local floor = math.floor

local Transform = Concord.system({
	pool = {"transform", "!auto_scale"},
	pool_pos = {"pos", "!pos_vec2"},
	pool_pos_vec2 = {"pos", "pos_vec2"},
	pool_atlas = {"quad_transform", "atlas"},
	pool_anchor = {"pos", "anchor"},
	pool_camera = {"pos", "camera"},
	pool_attach = {"pos", "attach_to"},
	pool_auto_scale = {"transform", "auto_scale"},
	pool_spawn = {"pos", "attach_to_spawn_point"},
})

function Transform:init()
	self.pool.onAdded = function(pool, e)
		!if _DEV then
			if e.quad and e.atlas then
				Log.warn(e.id.value .. " has quad but uses transform, maybe you want quad_transform?")
			end
		!end
		local t = e.transform
		local w, h
		local sprite = e.sprite
		local quad = e.quad
		local text = e.text
		local s_text = e.static_text

		if sprite then
			w, h = sprite.iw, sprite.ih
		elseif text then
			local font = e.font.value
			local target_text = e.target_text
			if target_text then
				w = font:getWidth(target_text.value)
				h = font:getHeight(" ")
			else
				w = font:getWidth(text.value)
				h = font:getHeight(" ")
			end
		elseif s_text then
			w, h = s_text.obj:getDimensions()
		end

		if t.ox == 0.5 then
			t.ox = w * 0.5
		elseif t.ox == 1 then
			t.ox = w
		end

		if t.oy == 0.5 then
			t.oy = h * 0.5
		elseif t.oy == 1 then
			t.oy = h
		end
	end

	self.pool_atlas.onAdded = function(pool, e)
		local frame = e.atlas.value.frame
		local qt = e.quad_transform
		if qt.ox == 0.5 then
			qt.ox = frame.w * 0.5
		elseif qt.ox == 1 then
			qt.ox = frame.w
		end

		if qt.oy == 0.5 then
			qt.oy = frame.h * 0.5
		elseif qt.oy == 1 then
			qt.oy = frame.h
		end
	end

	self.pool_anchor.onAdded = function(pool, e)
		self:update_anchor(e)
	end

	self.pool_pos_vec2.onAdded = function(pool, e)
		local pos = e.pos
		e.pos_vec2.value = vec2(pos.x, pos.y)
	end

	!if _DEV then
	self.pool_attach.onAdded = function(pool, e)
		local attach = e.attach_to
		local target = attach.target_e
		if not target.pos then
			error("Target entity must have a pos component")
		end
	end
	!end

	self.pool_auto_scale.onAdded = function(pool, e)
		local auto_scale = e.auto_scale
		local transform = e.transform
		local anim_data = e.animation_data
		local sprite = e.sprite
		local dsx, dsy = 1, 1

		if anim_data then
			dsx = auto_scale.tw/anim_data.frame_width
			dsy = auto_scale.th/anim_data.frame_height
		elseif sprite then
			dsx = auto_scale.tw/sprite.iw
			dsy = auto_scale.th/sprite.ih
		end
		if auto_scale.is_proportion then
			local scale = min(dsx, dsy)
			transform.sx = transform.sx * scale
			transform.sy = transform.sy * scale
		else
			transform.sx = transform.sx * dsx
			transform.sy = transform.sy * dsy
		end
		if auto_scale.is_floored then
			transform.sx = floor(transform.sx)
			transform.sy = floor(transform.sy)
		end
	end
end

function Transform:update_anchor(e)
	local anchor = e.anchor
	local pos = e.pos
	local target_pos = anchor.entity.pos
	local target_sprite = anchor.entity.sprite
	local sx, sy, ox, oy = 1, 1, 0, 0

	@@assert(target_sprite.image:type() == "Image")

	local target_transform = anchor.entity.transform
	if target_transform then
		sx = target_transform.sx or sx
		sy = target_transform.sy or sy
		ox = target_transform.ox or ox
		oy = target_transform.oy or oy
	end

	local target_qt = anchor.entity.quad_transform
	if target_qt then
		sx = target_qt.sx or sx
		sy = target_qt.sy or sy
		ox = target_qt.ox or ox
		oy = target_qt.oy or oy
	end

	local w, h = target_sprite.iw * sx, target_sprite.ih * sy
	local x = target_pos.x - ox * sx
	local y = target_pos.y - oy * sy

	if anchor.anchor_x == "center" then
		x = x + w * 0.5
	elseif anchor.anchor_y == "right" then
		x = x + w
	end

	if anchor.anchor_y == "center" then
		y = y + h * 0.5
	elseif anchor.anchor_y == "bottom" then
		y = y + h
	end

	if anchor.padding_x then
		x = x + anchor.padding_x
	end
	if anchor.padding_y then
		y = y + anchor.padding_y
	end

	pos.x = x
	pos.y = y
	pos.orig_x = pos.x
	pos.orig_y = pos.y
end

function Transform:canvas_resize(ww, wh, scale)
	for _, e in ipairs(self.pool) do
		local transform = e.transform

		if transform then
			transform.sx = scale
			transform.sy = scale
		end
	end
end

function Transform:update_position(l, t)
	for _, e in ipairs(self.pool_camera) do
		local pos = e.pos

		pos.x = pos.x + l
		pos.y = pos.y + t
		pos.orig_x = pos.x
		pos.orig_y = pos.y
	end
end

function Transform:update_attachment(e)
	local attach = e.attach_to
	local pos = e.pos
	local offset = e.attach_to_offset
	local target = attach.target_e
	local tx, ty = target.pos.x, target.pos.y

	if offset then
		tx = tx + offset.ox
		ty = ty + offset.oy
	end

	pos.x = tx
	pos.y = ty
end

function Transform:update(dt)
	for _, e in ipairs(self.pool_pos_vec2) do
		local pv = e.pos_vec2.value
		local pos = e.pos
		pv.x = pos.x
		pv.y = pos.y
	end

	for _, e in ipairs(self.pool_anchor) do
		self:update_anchor(e)
	end

	for _, e in ipairs(self.pool_attach) do
		self:update_attachment(e)
	end

	for _, e in ipairs(self.pool_spawn) do
		local pos = e.pos
		local sp = e.attach_to_spawn_point.pos
		pos.x = sp.x
		pos.y = sp.y
	end
end

!if _DEV then
local Slab = require("modules.slab")
local UIWrapper = require("ui_wrapper")

function Transform:debug_update(dt)
	if not self.debug_show then return end
	self.debug_show = Slab.BeginWindow("transform", {
		Title = "Transform",
		IsOpen = self.debug_show,
	})
	for _, e in ipairs(self.pool_pos) do
		local id = e.id.value
		if Slab.BeginTree(id, {Title = id}) then
			Slab.Indent()
			local pos = e.pos
			local t = e.transform or e.quad_transform
			pos.x = UIWrapper.edit_number("x", pos.x, true)
			pos.y = UIWrapper.edit_number("y", pos.y, true)
			if t then
				t.r = UIWrapper.edit_number("r", t.r)
				t.sx = UIWrapper.edit_number("sx", t.sx)
				t.sy = UIWrapper.edit_number("sy", t.sy)
			end
			Slab.EndTree()
			Slab.Unindent()
		end
	end
	Slab.EndWindow()
end
!end

return Transform

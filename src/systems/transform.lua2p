local Concord = require("modules.concord.concord")

local min = math.min

local Transform = Concord.system({
	pool = {"transform"},
	pool_quad = {"quad_transform"},
	pool_anchor = {"pos", "anchor"},
	pool_camera = {"pos", "camera"},
	pool_attach = {"pos", "attach_to"},
	pool_auto_scale = {"transform", "auto_scale"},
	pool_spawn = {"pos", "attach_to_spawn_point"}
})

function Transform:init()
	self.pool_anchor.onAdded = function(pool, e)
		self:update_anchor(e)
	end

	self.pool_attach.onAdded = function(pool, e)
		local attach = e.attach_to
		local target = attach.target_e

		!if _ASSERT then
		if not target:has("pos") then
			error("Target entity must have a pos component")
		end
		!end
	end

	self.pool_auto_scale.onAdded = function(pool, e)
		local auto_scale = e.auto_scale
		local transform = e.transform
		local anim_data = e.animation_data

		if anim_data then
			local dsx = auto_scale.target_width/anim_data.frame_width
			local dsy = auto_scale.target_height/anim_data.frame_height

			if auto_scale.is_proportion then
				local scale = min(dsx, dsy)

				transform.sx = transform.sx * scale
				transform.sy = transform.sy * scale
			else
				transform.sx = transform.sx * dsx
				transform.sy = transform.sy * dsy
			end
		end
	end
end

function Transform:update_anchor(e)
	local anchor = e.anchor
	local pos = e.pos
	local target_pos = anchor.entity.pos
	local target_sprite = anchor.entity.sprite

	!if _ASSERT then
	Assert.must(target_sprite.sprite, Types.T_IMAGE)
	!end

	local target_transform = anchor.entity.transform
	local sx = target_transform.sx or 1
	local sy = target_transform.sy or 1
	local ox = target_transform.ox or 0
	local oy = target_transform.oy or 0

	local w = target_sprite.sprite:getWidth() * sx
	local h = target_sprite.sprite:getHeight() * sy
	local x = target_pos.pos.x - ox * sx
	local y = target_pos.pos.y - oy * sy

	if anchor.anchor_x == "left" then
	elseif anchor.anchor_x == "center" then
		x = x + w/2
	elseif anchor.anchor_y == "right" then
		x = x + w
	end

	if anchor.anchor_y == "top" then
	elseif anchor.anchor_y == "center" then
		y = y + h/2
	elseif anchor.anchor_y == "bottom" then
		y = y + h
	end

	if anchor.padding_x then
		x = x + anchor.padding_x
	end
	if anchor.padding_y then
		y = y + anchor.padding_y
	end

	pos.pos.x = x
	pos.pos.y = y
	pos.original_pos = pos.pos:copy()
end

function Transform:canvas_resize(ww, wh, scale)
	for _, e in ipairs(self.pool) do
		local transform = e.transform

		if transform then
			transform.sx = scale
			transform.sy = scale
		end
	end
end

function Transform:update_position(l, t)
	for _, e in ipairs(self.pool_camera) do
		local pos = e.pos

		pos.pos.x = pos.pos.x + l
		pos.pos.y = pos.pos.y + t
		pos.original_pos = pos.pos:copy()
	end
end

function Transform:update_attachment(e)
	local attach = e.attach_to
	local pos = e.pos
	local offset = e.attach_to_offset
	local target = attach.target_e
	local tx, ty = target.pos.pos:unpack()

	if offset then
		tx = tx + offset.offset.x
		ty = ty + offset.offset.y
	end

	pos.pos.x = tx
	pos.pos.y = ty
end

function Transform:update(dt)
	for _, e in ipairs(self.pool_anchor) do
		self:update_anchor(e)
	end

	for _, e in ipairs(self.pool_attach) do
		self:update_attachment(e)
	end

	for _, e in ipairs(self.pool_spawn) do
		local pos = e.pos.pos
		local sp = e.attach_to_spawn_point.pos

		pos.x = sp.x
		pos.y = sp.y
	end
end

!if not _RELEASE then
local Slab = require("modules.slab")
local DebugFlags = require("debug_flags")
local views = DebugFlags.views
local is_open_transform = false
local t_comp
local selected_e

function Transform:draw_debug()
	views.transform = Slab.BeginWindow("transform", {
		Title = "Transform List", IsOpen = views.transform})

	for _, e in ipairs(self.pool) do
		local id = e.id

		Slab.Text(id and id.id or _)
		Slab.SameLine()

		if Slab.Button("Modify") then
			is_open_transform = true
			selected_e = e
			t_comp = e.transform

			break
		end
	end
	Slab.EndWindow()

	views.quad_transform = Slab.BeginWindow("quad_transform", {
		Title = "Quad Transform List", IsOpen = views.quad_transform})

	for _, e in ipairs(self.pool_quad) do
		local id = e.id

		Slab.Text(id and id.id or _)
		Slab.SameLine()

		if Slab.Button("Modify") then
			is_open_transform = true
			selected_e = e
			t_comp = e.quad_transform

			break
		end
	end
	Slab.EndWindow()

	if not is_open_transform then return end

	self:debug_modify()
end

function Transform:debug_modify()
	is_open_transform = Slab.BeginWindow("transform_e", {
			Title = "Transform", IsOpen = is_open_transform
		})

	local sprite = selected_e.sprite

	if sprite then
		local id = selected_e.id.id
		Slab.Image("Sprite " .. id, {Image = sprite.sprite})
	end

	local pos = selected_e.pos

	if pos then
		pos = pos.pos
		Slab.Text("Position:")
		Slab.SameLine()

		if Slab.Input("input_x", {
				Text = tostring(pos.x), ReturnOnText = false, NumbersOnly = true
			}) then
			pos.x = Slab.GetInputNumber()
		end

		Slab.SameLine()

		if Slab.Input("input_y", {
				Text = tostring(pos.y), ReturnOnText = false, NumbersOnly = true
			}) then
			pos.y = Slab.GetInputNumber()
		end
	end

	Slab.Text("Rotation:")
	Slab.SameLine()

	if Slab.Input("input_rotation", {
			Text = tostring(t_comp.rotation), ReturnOnText = false, NumbersOnly = true
		}) then
		t_comp.rotation = Slab.GetInputNumber()
	end

	Slab.Text("Scale:")
	Slab.SameLine()

	if Slab.Input("input_sx", {
			Text = tostring(t_comp.sx), ReturnOnText = false, NumbersOnly = true
		}) then
		t_comp.sx = Slab.GetInputNumber()
	end

	Slab.SameLine()

	if Slab.Input("input_sy", {
			Text = tostring(t_comp.sy), ReturnOnText = false, NumbersOnly = true
		}) then
		t_comp.sy = Slab.GetInputNumber()
	end

	Slab.Text("Offset:")
	Slab.SameLine()

	if Slab.Input("input_ox", {
			Text = tostring(t_comp.ox), ReturnOnText = false, NumbersOnly = true
		}) then
		t_comp.ox = Slab.GetInputNumber()
	end

	Slab.SameLine()

	if Slab.Input("input_oy", {
			Text = tostring(t_comp.oy), ReturnOnText = false, NumbersOnly = true
		}) then
		t_comp.oy = Slab.GetInputNumber()
	end

	Slab.Text("Shear:")
	Slab.SameLine()

	if Slab.Input("input_kx", {
			Text = tostring(t_comp.kx), ReturnOnText = false, NumbersOnly = true
		}) then
		t_comp.kx = Slab.GetInputNumber()
	end

	Slab.SameLine()

	if Slab.Input("input_ky", {
			Text = tostring(t_comp.ky), ReturnOnText = false, NumbersOnly = true
		}) then
		t_comp.ky = Slab.GetInputNumber()
	end
	Slab.EndWindow()
end
!end

return Transform

local Concord = require("modules.concord.concord")

local min = math.min
local floor = math.floor

local Transform = Concord.system({
	pool = {"transform"},
	pool_pos = {"pos"},
	pool_quad = {"quad_transform"},
	pool_anchor = {"pos", "anchor"},
	pool_camera = {"pos", "camera"},
	pool_attach = {"pos", "attach_to"},
	pool_auto_scale = {"transform", "auto_scale"},
	pool_spawn = {"pos", "attach_to_spawn_point"},
})

function Transform:init()
	self.pool_anchor.onAdded = function(pool, e)
		self:update_anchor(e)
	end

	!if _DEV then
	self.pool_attach.onAdded = function(pool, e)
		local attach = e.attach_to
		local target = attach.target_e
		if not target.pos then
			error("Target entity must have a pos component")
		end
	end
	!end

	self.pool_auto_scale.onAdded = function(pool, e)
		local auto_scale = e.auto_scale
		local transform = e.transform
		local anim_data = e.animation_data
		local sprite = e.sprite
		local dsx, dsy = 1, 1

		if anim_data then
			dsx = auto_scale.tw/anim_data.frame_width
			dsy = auto_scale.th/anim_data.frame_height
		elseif sprite then
			dsx = auto_scale.tw/sprite.iw
			dsy = auto_scale.th/sprite.ih
		end
		if auto_scale.is_proportion then
			local scale = min(dsx, dsy)
			transform.sx = transform.sx * scale
			transform.sy = transform.sy * scale
		else
			transform.sx = transform.sx * dsx
			transform.sy = transform.sy * dsy
		end
		if auto_scale.is_floored then
			transform.sx = floor(transform.sx)
			transform.sy = floor(transform.sy)
		end
	end
end

function Transform:update_anchor(e)
	local anchor = e.anchor
	local pos = e.pos
	local target_pos = anchor.entity.pos
	local target_sprite = anchor.entity.sprite

	@@assert(target_sprite.image:type() == "Image")

	local target_transform = anchor.entity.transform
	local sx = target_transform.sx or 1
	local sy = target_transform.sy or 1
	local ox = target_transform.ox or 0
	local oy = target_transform.oy or 0

	local w = target_sprite.image:getWidth() * sx
	local h = target_sprite.image:getHeight() * sy
	local x = target_pos.x - ox * sx
	local y = target_pos.y - oy * sy

	if anchor.anchor_x == "center" then
		x = x + w * 0.5
	elseif anchor.anchor_y == "right" then
		x = x + w
	end

	if anchor.anchor_y == "center" then
		y = y + h * 0.5
	elseif anchor.anchor_y == "bottom" then
		y = y + h
	end

	if anchor.padding_x then
		x = x + anchor.padding_x
	end
	if anchor.padding_y then
		y = y + anchor.padding_y
	end

	pos.x = x
	pos.y = y
	pos.orig_x = pos.x
	pos.orig_y = pos.y
end

function Transform:canvas_resize(ww, wh, scale)
	for _, e in ipairs(self.pool) do
		local transform = e.transform

		if transform then
			transform.sx = scale
			transform.sy = scale
		end
	end
end

function Transform:update_position(l, t)
	for _, e in ipairs(self.pool_camera) do
		local pos = e.pos

		pos.x = pos.x + l
		pos.y = pos.y + t
		pos.orig_x = pos.x
		pos.orig_y = pos.y
	end
end

function Transform:update_attachment(e)
	local attach = e.attach_to
	local pos = e.pos
	local offset = e.attach_to_offset
	local target = attach.target_e
	local tx, ty = target.pos.x, target.pos.y

	if offset then
		tx = tx + offset.ox
		ty = ty + offset.oy
	end

	pos.x = tx
	pos.y = ty
end

function Transform:update(dt)
	for _, e in ipairs(self.pool_anchor) do
		self:update_anchor(e)
	end

	for _, e in ipairs(self.pool_attach) do
		self:update_attachment(e)
	end

	for _, e in ipairs(self.pool_spawn) do
		local pos = e.pos
		local sp = e.attach_to_spawn_point.pos
		pos.x = sp.x
		pos.y = sp.y
	end
end

!if _DEV then
local Slab = require("modules.slab")
local UIWrapper = require("ui_wrapper")

function Transform:debug_update(dt)
	if not self.debug_show then return end
	self.debug_show = Slab.BeginWindow("transform", {
		Title = "Transform",
		IsOpen = self.debug_show,
	})
	for _, e in ipairs(self.pool_pos) do
		local id = e.id.value
		if Slab.BeginTree(id, {Title = id}) then
			Slab.Indent()
			local pos = e.pos
			local t = e.transform or e.quad_transform
			pos.x = UIWrapper.edit_number("x", pos.x, true)
			pos.y = UIWrapper.edit_number("y", pos.y, true)
			if t then
				t.r = UIWrapper.edit_number("r", t.r)
				t.sx = UIWrapper.edit_number("sx", t.sx)
				t.sy = UIWrapper.edit_number("sy", t.sy)
			end
			Slab.EndTree()
			Slab.Unindent()
		end
	end
	Slab.EndWindow()
end
!end

return Transform

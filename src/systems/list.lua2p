local Concord = require("modules.concord.concord")

local Inputs = require("inputs")

local insert = table.insert

local List = Concord.system({
	pool = {"list_item", "list_group"},
})

function List:init(world)
	self.world = world
	self.groups = {}
	self.focused = nil

	self.pool.onAdded = function(pool, e)
		local group_id = e.list_group.value
		local group = self.groups[group_id]
		insert(group.entities, e)
		self.focused = group_id
	end
end

function List:update(dt)
	if not self.focused then return end
	local group = self.groups[self.focused]
	local e_new_cursor = self:update_list(group)

	for _, e in ipairs(group.entities) do
		if e ~= e_new_cursor then
			e:remove("list_cursor")
		end
	end
end

function List:create_list_group(id, per_page, max_page)
	@@assert(type(id) == "string")
	@@assert(type(per_page) == "number" and per_page > 0)
	@@assert(type(max_page) == "number" and max_page > 0)
	@@assert(self.groups[id] == nil, id .. " was already added")
	self.groups[id] = {
		entities = {},
		cursor = 1,
		offset = 0,
		per_page = per_page,
		max_page = max_page
	}
end

function List:update_list(group)
	local dy = 0
	if Inputs.pressed("interact") then
	elseif Inputs.pressed("up") then
		dy = -1
	elseif Inputs.pressed("down") then
		dy = 1
	end

	if dy == 0 then return end
	group.cursor = group.cursor + dy

	if group.cursor > group.per_page then
		group.cursor = 1
		group.offset = group.offset + 1
	elseif group.cursor <= 0 then
		group.cursor = group.per_page
		group.offset = group.offset - 1
	end

	if group.offset * group.per_page > group.max_page - 1 then
		group.cursor = 1
		group.offset = 0
	elseif group.offset < 0 then
		group.cursor = group.per_page
		group.offset = group.max_page/group.per_page - 1
	end

	local cursor_new_index = group.per_page * group.offset + group.cursor
	local e_hovered = group.entities[cursor_new_index]
	if e_hovered then
		e_hovered:give("list_cursor", cursor_new_index, group.max_page)
		self.world:emit("on_item_cursor_on", e_hovered)
		return e_hovered
	end
end

function List:draw_list(group_id, i)
	local group = self.groups[group_id]
	local index = group.per_page * group.offset + i
	local e = group.entities[index]
	if e then
		self.world:emit("draw_text_ex", e)
	end
end

function List:cleanup()
	for _, group in pairs(self.groups) do
		for _, e in ipairs(group.entities) do
			e:destroy()
		end
	end
	tablex.clear(self.groups)
	self.focused = nil
end

return List

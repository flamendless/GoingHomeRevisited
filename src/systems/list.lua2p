local Concord = require("modules.concord.concord")
local Log = require("modules.log.log")

local Inputs = require("inputs")

local abs = math.abs
local insert = table.insert

local List = Concord.system({
	pool = {"list_item", "list_group"},
})

function List:init(world)
	self.world = world
	self.groups = {}
	self.focused = nil

	self.pool.onAdded = function(pool, e)
		local group_id = e.list_group.value
		local group = self.groups[group_id]
		insert(group.entities, e)
		self.focused = group_id
		if #pool == 1 then
			self:update_cursor(1)
		end
	end
end

function List:update(dt)
	if not self.focused then return end
	local group = self.groups[self.focused]
	local delta
	if group.is_grid then
		delta = self:update_list_grid(group)
	else
		delta = self:update_list(group)
	end
	local cursor_new_index
	if delta then
		cursor_new_index = self:update_cursor()
	end

	if not group.entities then return end
	for i, e in ipairs(group.entities) do
		local min = group.per_page * group.offset
		local max = group.per_page * (group.offset + 1)
		e.list_item.on_current_page = (i > min) and (i <= max)
		if cursor_new_index and i ~= cursor_new_index then
			e:remove("list_cursor")
			self.world:emit("on_list_cursor_remove", e)
		end
	end
end

function List:create_list_group(id, vertical_only, per_page, use_max_threshold, limit)
	@@assert(type(id) == "string")
	@@assert(type(vertical_only) == "boolean")
	@@assert(type(per_page) == "number" and per_page > 0)
	@@assert(self.groups[id] == nil, id .. " was already added")
	@@sassert(use_max_threshold, type(use_max_threshold) == "boolean")
	@@sassert(limit, use_max_threshold and type(limit) == "number" and limit > 0)
	self.groups[id] = {
		entities = {},
		cursor = 1,
		offset = 0,
		vertical_only = vertical_only,
		per_page = per_page,
		limit = limit,
		use_max_threshold = use_max_threshold,
	}
end

function List:create_list_group_grid(id, rows, cols)
	@@assert(type(id) == "string")
	@@assert(self.groups[id] == nil, id .. " was already added")
	@@assert(type(rows) == "number" and rows > 0)
	@@assert(type(cols) == "number" and cols > 0)
	self.groups[id] = {
		entities = {},
		cursor = 1,
		offset = 0,
		rows = rows,
		cols = cols,
		is_grid = true,
		per_page = rows * cols,
	}
end

function List:update_list(group)
	local delta = 0
	local up = group.vertical_only and "up" or "left"
	local down = group.vertical_only and "down" or "right"

	if Inputs.pressed("interact") then
		local index = group.per_page * group.offset + group.cursor
		@@assert(group.entities[index])
		self.world:emit("on_list_item_interact", group.entities[index])
	elseif Inputs.pressed(up) then
		delta = -1
	elseif Inputs.pressed(down) then
		delta = 1
	end

	if delta == 0 then return false end
	group.cursor = group.cursor + delta

	if group.cursor > group.per_page then
		group.cursor = 1
		group.offset = group.offset + 1
	elseif group.cursor <= 0 then
		group.cursor = group.per_page
		group.offset = group.offset - 1
	end

	if not group.use_max_threshold then
		local index = group.offset * group.per_page + group.cursor
		local limit = #group.entities
		if index > limit then
			group.cursor = 1
			group.offset = 0
		elseif index <= 0 then
			if limit == group.per_page then
				group.cursor = limit
				group.offset = 0
			else
				group.cursor = limit % group.per_page
				group.offset = limit % group.cursor
			end
		end
	else
		if group.offset * group.per_page > group.limit - 1 then
			group.cursor = 1
			group.offset = 0
		elseif group.offset < 0 then
			group.cursor = group.per_page
			group.offset = group.limit/group.per_page - 1
		end
	end

	return true
end

function List:update_list_grid(group)
	local dx, dy = 0, 0
	if Inputs.pressed("interact") then
		local index = group.per_page * group.offset + group.cursor
		@@assert(group.entities[index])
		self.world:emit("on_list_item_interact", group.entities[index])
	elseif Inputs.pressed("left") then
		dx = -1
	elseif Inputs.pressed("right") then
		dx = 1
	elseif Inputs.pressed("up") then
		dy = -1
	elseif Inputs.pressed("down") then
		dy = 1
	end

	if dx == 0 and dy == 0 then return false end
	if dx ~= 0 then
		group.cursor = group.cursor + dx
	elseif dy ~= 0 then
		group.cursor = group.cursor + dy * group.cols
	end

	if group.cursor > group.per_page then
		group.cursor = group.cursor - group.per_page
	elseif group.cursor <= 0 then
		group.cursor = group.per_page - abs(group.cursor)
	end

	return true
end

function List:update_cursor(index)
	@@sassert(index, type(index) == "number" and index > 0)
	local group = self.groups[self.focused]
	local cursor_new_index = index or (group.per_page * group.offset + group.cursor)
	local e_hovered = group.entities[cursor_new_index]
	if e_hovered then
		e_hovered:give("list_cursor", cursor_new_index)
		self.world:emit("on_list_cursor_update", e_hovered)
		return cursor_new_index
	end
end

function List:set_focus_list(group_id)
	@@sassert(group_id, type(group_id) == "string" and self.groups[group_id])
	self.focused = group_id
	Log.trace("focused list: " .. group_id)
end

function List:destroy_list(group_id)
	if not self.groups[group_id] then return end
	local group = self.groups[group_id]
	for _, e in ipairs(group.entities) do
		e:destroy()
	end
	tablex.clear(group)
	self.groups[group_id] = nil
	self.focused = nil
	Log.trace("deleted list: " .. group_id)
end

function List:cleanup()
	for _, group in pairs(self.groups) do
		for _, e in ipairs(group.entities) do
			e:destroy()
		end
	end
	tablex.clear(self.groups)
	self.focused = nil
end

return List

local Concord = require("modules.concord.concord")
local Bump3D = require("modules.bump3d.bump-3dpd")
local Timer = require("modules.hump.timer")

local Bump3DCollision = Concord.system({
	pool = {"collider3d", "position", "bump3d"}
})

local filter = function(item, other)
	local other_col = other.collider3d

	return other_col.filter or "slide"
end

function Bump3DCollision:init(world)
	self.world = world
	self.bump3d_world = Bump3D.newWorld()

	!if not _RELEASE then
	self.bump3d_bodies = {}
	!end

	self.pool.onEntityAdded = function(pool, e)
		local x = e.position.pos.x
		local y = e.position.pos.y

		self.bump3d_world:add(e, x, y, 0,
			e.collider3d.size.x, e.collider3d.size.y, e.collider3d.size.z)

		!if not _RELEASE then
		local id = e.bump3d.id

		if id then
			self.bump3d_bodies[id] = e
		end
		!end
	end

	self.pool.onEntityRemoved = function(pool, e)
		self.bump3d_world:remove(e)
	end
end

function Bump3DCollision:preupdate(dt)
	for _, e in ipairs(self.pool) do
		e.collider3d.is_hit = false
	end
end

function Bump3DCollision:update(dt)
	for _, e in ipairs(self.pool) do
		if e.body then
			if e.body.vel_x ~= 0 or e.body.vel_y ~= 0 then
				local pos = e.position.pos
				local cols, len

				pos.x, pos.y, z, cols, len = self.bump3d_world:move(e,
					pos.x + e.body.vel_x,
					pos.y + e.body.vel_y,
					0, filter)

				for i = 1, len do
					local c = cols[i]
					local other = c.other
					local other_col = other.collider3d
					local other_id = other.bump3d.id

					other_col.is_hit = true
					other_col.normal.x = c.normalX
					other_col.normal.y = c.normalY

					local item = c.item
					local item_col = item.collider3d

					item_col.is_hit = true
					item_col.normal.x = c.normalX
					item_col.normal.y = c.normalY
				end

				if e.z_index.sortable then
					self.world:emit("sort_z")
				end

				self.bump3d_world.freeCollisions(cols)
			end
		end
	end
end

!if not _RELEASE then
local Slab = require("modules.slab")
local DebugFlags = require("debug_flags")

local format = string.format
local win_col3d = false
local current_item, current_item_id

function Bump3DCollision:draw_slab(dt)
	DebugFlags.b3d_list = Slab.BeginWindow("b3d", {
		Title = "Bump3DCollision", IsOpen = DebugFlags.b3d_list})

	local items, len = self.bump3d_world:getItems()

	Slab.Text("number:")
	Slab.SameLine()
	Slab.Text(len)

	for id, e in pairs(self.bump3d_bodies) do
		Slab.BeginLayout("b3d_layout", {Columns = 2})
		Slab.SetLayoutColumn(1)
		Slab.Text(id)
		Slab.SameLine()
		Slab.SetLayoutColumn(2)

		if Slab.Button("edit") then
			win_col3d = true
			current_item = e
			current_item_id = id
		end

		Slab.SameLine()

		if Slab.Button("highlight") then
			e.collider3d.highlight = true
			Timer.after(1, function()
				e.collider3d.highlight = false
			end)
		end

		Slab.EndLayout()
	end

	Slab.EndWindow()

	if win_col3d then
		local e = current_item
		local id = current_item_id

		Slab.BeginWindow("EditCollider", {Title = "Collider3d"})
		Slab.Text(id)
		Slab.Indent()

		local x = e.position.pos.x
		local y = e.position.pos.y
		local w = e.collider3d.size.x
		local h = e.collider3d.size.y
		local d = e.collider3d.size.z

		Slab.Text("x: ")
		Slab.SameLine()

		if Slab.Input("input_x", {
				Text = tostring(x), ReturnOnText = false, NumbersOnly = true}) then
			x = Slab.GetInputNumber()
		end

		Slab.Text("y: ")
		Slab.SameLine()

		if Slab.Input("input_y", {
				Text = tostring(y), ReturnOnText = false, NumbersOnly = true}) then
			y = Slab.GetInputNumber()
		end

		Slab.Text("w: ")
		Slab.SameLine()

		if Slab.Input("input_w", {
				Text = tostring(w), ReturnOnText = false, NumbersOnly = true}) then
			w = Slab.GetInputNumber()
		end

		Slab.Text("h: ")
		Slab.SameLine()

		if Slab.Input("input_h", {
				Text = tostring(h), ReturnOnText = false, NumbersOnly = true}) then
			h = Slab.GetInputNumber()
		end

		Slab.Text("d: ")
		Slab.SameLine()

		if Slab.Input("input_d", {
				Text = tostring(d), ReturnOnText = false, NumbersOnly = true}) then
			d = Slab.GetInputNumber()
		end

		local ox, oy

		if e.transform then
			ox = e.transform.ox
			oy = e.transform.oy

			Slab.Text("ox: ")
			Slab.SameLine()

			if Slab.Input("input_ox", {
					Text = tostring(ox), ReturnOnText = false, NumbersOnly = true}) then
				ox = Slab.GetInputNumber()
			end

			Slab.Text("oy: ")
			Slab.SameLine()

			if Slab.Input("input_oy", {
					Text = tostring(oy), ReturnOnText = false, NumbersOnly = true}) then
				oy = Slab.GetInputNumber()
			end

			e.transform.ox = ox
			e.transform.oy = oy
		end

		e.position.pos.x = x
		e.position.pos.y = y
		e.collider3d.size.x = w
		e.collider3d.size.y = h
		e.collider3d.size.z = d

		self.bump3d_world:update(e, x, y, 0, w, h, d)

		if Slab.Button("print") then
			print(id, "position:", x, y)
			print(id, "collider3d: ", w, h, d)

			if ox or oy then
				print(id, "offset:", ox, oy)
			end
		end

		Slab.Unindent()
		Slab.EndWindow()
	end
end

function Bump3DCollision:draw_debug()
	if not DebugFlags.b3d_bounds then return end

	local items, len = self.bump3d_world:getItems()
	for i = 1, len do
		local e = items[i]
		local x, y, z, w, h, d = self.bump3d_world:getCube(e)

		if e.collider3d.highlight then
			love.graphics.setColor(1, 0, 1, 1)
		elseif e.collider3d.is_hit then
			love.graphics.setColor(1, 0, 0, 0.8)
		else
			love.graphics.setColor(0, 1, 0, 0.3)
		end

		love.graphics.rectangle("line", x, y + z + h, w, d)
		love.graphics.rectangle("line", x, y + z, w, h)
	end
end
!end

return Bump3DCollision

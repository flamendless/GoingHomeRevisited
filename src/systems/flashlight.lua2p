local Concord = require("modules.concord")

local AnimationData = require("animation_data")
local Inputs = require("inputs")

local Flashlight = Concord.system({
	pool = {"id", "light_id", "point_light", "pos", "diffuse", "flashlight"},
	pool_player = {"player_controller", "body", "collider"},
})

local Light = require("assemblages.light")

local consumption_rate = 0.1

function Flashlight:init(world)
	self.world = world
	self.player = nil

	self.pool.onAdded = function(pool, e)
		@@assert(self.flashlight == nil, "Flashlight was already added")
		self.flashlight = e
	end

	self.pool_player.onAdded = function(pool, e)
		@@assert(self.player == nil, "Player was already added")
		self.player = e
		self:create_flashlight()
	end
end

function Flashlight:create_flashlight()
	Concord.entity(self.world):assemble(Light.fl_spot,
			self.player, AnimationData.get_sync_data("flashlight"))
		:give("d_light_flicker", 0.5, 0.75, 0.25)
		:give("on_d_light_flicker_during", "flicker_flashlight")
		:give("d_light_flicker_repeat", -1, 7)
	!if _DEV then
		:give("battery", 100)
	!end
	self.start_l = Concord.entity(self.world):assemble(Light.fl_start)
	self.end_l = Concord.entity(self.world):assemble(Light.fl_end)
end

function Flashlight:update(dt)
	if self.flashlight == nil or self.player == nil then return end
	self:update_flashlight()
	self:update_battery(dt)

	self.world:emit("update_light_dir", self.flashlight)
	self.world:emit("update_light_pos", self.flashlight)
	self.world:emit("update_light_pos", self.start_l)
	self.world:emit("update_light_pos", self.end_l)

	if Inputs.released("flashlight") then
		if self.flashlight.light_disabled then
			self.flashlight:remove("light_disabled")
		else
			self.flashlight:give("light_disabled")
		end
	end
end

function Flashlight:update_flashlight()
	local body = self.player.body
	local p_pos = self.player.pos
	local col = self.player.collider
	local offset = self.player.fl_spawn_offset
	local f_pos = self.flashlight.pos
	local ldir = self.flashlight.light_dir
	local fd = ldir.value

	local bx = p_pos.x + col.w_h
	local by = p_pos.y + col.h_h
	fd[1] = ldir.orig_value[1] * body.dir
	f_pos.x = bx + offset.x * fd[1]
	f_pos.y = by + offset.y

	local strength = self.flashlight.point_light.value
	local s_pos = self.start_l.pos
	s_pos.x = f_pos.x
	s_pos.y = f_pos.y

	local e_pos = self.end_l.pos
	e_pos.x = f_pos.x + strength * fd[1] * fd[4]
	e_pos.y = f_pos.y
end

function Flashlight:flicker_flashlight()
	local main_diff = self.flashlight.diffuse.value
	local d_start = self.start_l.diffuse.value
	local d_end = self.end_l.diffuse.value
	d_start[1] = main_diff[1]
	d_start[2] = main_diff[2]
	d_start[3] = main_diff[3]
	d_end[1] = main_diff[1]
	d_end[2] = main_diff[2]
	d_end[3] = main_diff[3]
	self.world:emit("update_light_diffuse", self.start_l)
	self.world:emit("update_light_diffuse", self.end_l)
end

function Flashlight:update_battery(dt)
	local battery = self.flashlight and self.flashlight.battery
	if not battery then return end
	battery.pct = battery.pct - dt * consumption_rate
	local pct = battery.pct/100

	if pct <= 0.75 then
		if not self.flashlight.d_light_flicker then
			self.flashlight:give("d_light_flicker", 2, 0.75, 0.25)
				:give("on_d_light_flicker_during", "flicker_flashlight")
				:give("d_light_flicker_repeat")
		end
	end

	if pct <= 0 then
		self.start_l:give("light_disabled")
		self.end_l:give("light_disabled")
		return
	end

	local f_pl = self.flashlight.point_light
	f_pl.value = f_pl.orig_value * pct
	local s_pl = self.start_l.point_light
	s_pl.value = s_pl.orig_value * pct
end

!if _DEV then
local Slab = require("modules.slab")
local UIWrapper = require("ui_wrapper")
local flags = {
	pos = false,
}

function Flashlight:debug_update(dt)
	if not self.debug_show then return end
	self.debug_show = Slab.BeginWindow("fl", {
		Title = "Flashlight",
		IsOpen = self.debug_show,
	})
	if Slab.CheckBox(flags.pos, "draw") then
		flags.pos = not flags.pos
	end

	local battery = self.flashlight and self.flashlight.battery
	if battery then
		Slab.Text("battery")
		Slab.SameLine()
		UIWrapper.edit_range("battery", battery.pct, 0, 100)
		consumption_rate = UIWrapper.edit_range("consumption rate", consumption_rate, 0, 10)
		local pl = self.flashlight.point_light
		UIWrapper.edit_range("power", pl.value, 0, pl.orig_value)
	end
	Slab.EndWindow()
end

function Flashlight:debug_draw()
	if not flags.pos then return end
	local p_pos = self.player.pos
	local col = self.player.collider
	local offset = self.player.fl_spawn_offset
	local ldir = self.flashlight.light_dir
	local fd = ldir.value
	local bx = p_pos.x + col.w_h
	local by = p_pos.y + col.h_h
	local fx = bx + offset.x * fd[1]
	local fy = by + offset.y
	love.graphics.setColor(1, 0, 0, 1)
	love.graphics.circle("fill", fx, fy, 2)
end
!end

return Flashlight

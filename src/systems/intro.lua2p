local Concord = require("modules.concord.concord")
local Gamera = require("modules.gamera.gamera")
local Flux = require("modules.flux.flux")
local Lume = require("modules.lume.lume")
local TLE = require("modules.tle.timeline")

local AnimationData = require("animation_data")
local Canvas = require("canvas")
local Fade = require("fade")
local Inputs = require("inputs")
local NGrading = require("ngrading")
local Resources = require("resources")
local Save = require("save")
local Settings = require("settings")

local min = math.min

local Assemblages = {
	Common = require("assemblages.common"),
	Intro = require("assemblages.intro"),
	UI = require("assemblages.ui"),
}

local ParticleSystems = {
	RainIntro = require("particle_systems/rain_intro"),
}

local Intro = Concord.system({
	pool_intro_text = {"intro_text"},
	pool_light = {"intro_light"},
})

local ngrading = {dt = 0, dt2 = 0, status = 1}
local fade_duration = 4
local current_ngrading
local is_raining = false
local is_switching = false
local rain_amount = {16, 32, 96}
local should_fade = false
local intro_text_n = 1
local img_bg

function Intro:enable_next_intro_text()
	local e = self.pool_intro_text[intro_text_n]
	self.world:emit("fade_text", e, fade_duration,
		function()
			self.timeline:Unpause()
			intro_text_n = intro_text_n + 1
		end)
end

function Intro:car_reflection_flicker()
	local chance = Lume.randomchoice({true, false})
	if chance then
		self.e_car_reflect:remove("hidden")
	else
		self.e_car_reflect:give("hidden")
	end
end

function Intro:update_rain(i)
	@@assert(type(i) == "number")
	@@assert(rain_amount[i])
	local amount = rain_amount[i]
	is_raining = true
	self.ps1.system:setEmissionRate(amount)
	self.ps2.system:setEmissionRate(amount)
end

function Intro:init(world)
	self.world = world
end

function Intro:state_setup()
	img_bg = Resources.data.images.bg
	local w, h = img_bg:getDimensions()
	self.canvases = {}
	self.canvases.main = Canvas.create_main({})

	local ssx, ssy = love.graphics.getDimensions()
	local ssx2 = ssx * 2
	self.scale = min(ssx/w, ssy/h)

	self.camera = Gamera.new(0, 0, w, h)
	self.camera:setWindow(0, 0, ssx, ssy)
	self.camera:setScale(self.scale)

	Concord.entity(self.world):assemble(Assemblages.Common.camera,
		self.camera, self.scale, w, h)

	self.world:emit("create_light_map", self.canvases.main.x, self.canvases.main.y, w, h)
	self.ps1 = ParticleSystems.RainIntro(Resources.data.images.rain_drop_tilted, 128, w)
	self.ps2 = ParticleSystems.RainIntro(Resources.data.images.rain_drop_tilted2, 128, w)

	for i = 1, 2 do
		Concord.entity(self.world):assemble(Assemblages.Intro.parallax, "clouds")
		Concord.entity(self.world):assemble(Assemblages.Intro.parallax, "buildings")
		Concord.entity(self.world):assemble(Assemblages.Intro.parallax, "road")
		Concord.entity(self.world):assemble(Assemblages.Intro.parallax, "grass")
		Concord.entity(self.world):assemble(Assemblages.Intro.parallax, "grass2")
		Concord.entity(self.world):assemble(Assemblages.Intro.parallax, "grass_back")
		Concord.entity(self.world):assemble(Assemblages.Intro.parallax, "grass_front")
		local e_tree = Concord.entity(self.world):assemble(Assemblages.Intro.parallax, "trees_bg")
		if i == 1 then
			Concord.entity(self.world):assemble(Assemblages.Intro.bg_tree_cover, "bg_tree_cover")
				:give("attach_to", e_tree)
		end
		Concord.entity(self.world):assemble(Assemblages.Intro.parallax, "trees_fg", 4)
		local e = Concord.entity(self.world):assemble(Assemblages.Intro.post_light, "post_light", 2)
			:give("parallax_gap", w)
		Concord.entity(self.world):assemble(Assemblages.Intro.parallax, "post", 2)
			:give("attach_to", e)
			:give("attach_to_offset", 108, 0)
	end

	self.e_car = Concord.entity(self.world):assemble(Assemblages.Intro.car)
	Concord.entity(self.world):assemble(Assemblages.Intro.car_light, self.e_car)
		:give("light_disabled")
		:give("intro_light")

	self.e_car_reflect = Concord.entity(self.world):assemble(Assemblages.Intro.car_reflect,
			self.e_car)
		:give("animation_on_loop", "car_reflection_flicker")

	local fw, fh = 512, 128
	local fsx = ssx2 * 4/fw
	local fsy = 2
	Concord.entity(self.world):assemble(Assemblages.Intro.fog,
		"fog1", fw, fh, {0.6, 0.6, 0.6, 1}, 0, 250, fsx, fsy * 0.45, 0.05)
	Concord.entity(self.world):assemble(Assemblages.Intro.fog,
		"fog2", fw, fh, {0.75, 0.75, 0.75, 0.55}, 0, 290, fsx, fsy * 0.35, 3)
	Concord.entity(self.world):assemble(Assemblages.Intro.fog,
			"fog3", fw, fh, {0.9, 0.9, 0.9, 0}, 0, 340, fsx, fsy * 0.5, 4)
		:give("fade_in_target_alpha", 0.45)
		:give("hidden")
	Concord.entity(self.world):assemble(Assemblages.Intro.fog,
			"fog4", fw, fh, {0.6, 0.6, 0.6, 0}, 0, 290, fsx, fsy * 0.35, 2)
		:give("fade_in_target_alpha", 0.45)
		:give("hidden")

	local lut_size, lut_afternoon, lut_dusk
	if Settings.current.graphics_quality == "low" then
		lut_size = 16
		lut_afternoon = Resources.data.image_data.lut_afternoon_16
		lut_dusk = Resources.data.image_data.lut_dusk_16
	else
		lut_size = 64
		lut_afternoon = Resources.data.image_data.lut_afternoon_64
		lut_dusk = Resources.data.image_data.lut_dusk_64
	end

	ngrading.single = NGrading(lut_afternoon, lut_size)
	ngrading.multi = NGrading(lut_afternoon, lut_dusk, lut_size)
	current_ngrading = ngrading.single

	Concord.entity(self.world):assemble(Assemblages.UI.ui_text,
			"flamendless studio presents", "ui", 32, 32)
		:give("intro_text")
		:give("animation_data", AnimationData.get("splat"))

	Concord.entity(self.world):assemble(Assemblages.UI.ui_text,
			!("a game by " .. _NAME_DEVELOPER), "ui", 32, 32)
		:give("intro_text")
		:give("animation_data", AnimationData.get("splat"))

	Concord.entity(self.world):assemble(Assemblages.UI.ui_text,
			!("arts by " .. _NAME_ARTIST), "ui", 32, 32)
		:give("intro_text")
		:give("animation_data", AnimationData.get("splat"))

	Concord.entity(self.world):assemble(Assemblages.UI.ui_text,
			!("music by " .. _NAME_MUSICIAN), "ui", 32, 32)
		:give("intro_text")
		:give("animation_data", AnimationData.get("splat"))

	self.e_title_light = Concord.entity(self.world):assemble(Assemblages.Intro.title_light,
			ssx * 0.5, ssy * 0.5)
		:give("intro_text")

	self.e_title = Concord.entity(self.world):assemble(Assemblages.Intro.title,
			ssx * 0.5, ssy * 0.5)
		:give("intro_text")

	if Save.data.intro_done or !(_DEV) then
		self.world:emit("show_skip")
	end
end

function Intro:state_init()
	local ssx = love.graphics.getWidth()
	local w, h = img_bg:getDimensions()

	self.timeline = TLE.Do(function()
		!if _DEV then
		self.world:emit("set_ambient_light", {0.5, 0.5, 0.5})
		self.timeline:Pause()
		!end

		--how many times we will scale/move the camera for this cutscene
		local max_n_cam_t = 4
		local ambient_color = {0.9, 0.9, 0.9}
		self.world:emit("set_ambient_light", ambient_color)
		self.world:emit("set_camera_transform", self.camera, {x = 53, y = 544, scale = 15})

		TLE.Event.Wait(2)
		self.world:emit("fade_in_fog", "fog3", 32)
		self.world:emit("tween_depth_zoom", 5, 1/max_n_cam_t, "cubicinout")
		self.world:emit("tween_camera_pos_rel", self.camera, 5, 0, -64, "cubicinout")
		self.world:emit("tween_camera_scale", self.camera, 5, 10, "cubicinout")

		TLE.Event.Wait(2)
		self:enable_next_intro_text()
		self.timeline:Pause()

		local car_pos = self.e_car.pos
		self.world:emit("tween_depth_zoom", 5, 2/max_n_cam_t, "circout")
		self.world:emit("tween_camera_scale", self.camera, 5, 5, "circout")
		self.world:emit("tween_camera_pos_rel", self.camera, 5, 160, -32, "circout")
		Flux.to(car_pos, 5, {x = 128})

		self:update_rain(1)
		self:enable_next_intro_text()
		self.timeline:Pause()

		--Enter forest
		self.world:emit("fade_out_fog", "fog1", 3)
		self.world:emit("fade_out_fog", "fog2", 3)
		-- self.world:emit("fade_out_fog", "fog3", 2)
		self.world:emit("fade_in_fog", "fog4", 3)
		self.world:emit("start_trees")
		for _, e in ipairs(self.pool_light) do
			e:remove("light_disabled")
		end
		Flux.to(ambient_color, 15, {
			[1] = 0.3, [2] = 0.3, [3] = 0.3,
		}):onupdate(function()
			self.world:emit("set_ambient_light", ambient_color)
		end)

		ngrading.status = 2
		current_ngrading = ngrading.multi
		Flux.to(ngrading, 15, {dt = 1})
		self.world:emit("tween_depth_zoom", 5, 3/max_n_cam_t, "backout")
		self.world:emit("tween_camera_scale", self.camera, 5, 3, "backout")
		self.world:emit("tween_camera_pos_rel", self.camera, 5, 72, -32, "backout")
		Flux.to(car_pos, 3, {x = 160})

		self:enable_next_intro_text()
		self.timeline:Pause()

		self:enable_next_intro_text()
		self.timeline:Pause()

		TLE.Event.Wait(2)
		self:update_rain(2)

		TLE.Event.Wait(1)
		self.world:emit("slow_parallax", 0.75)
		Flux.to(car_pos, 3, {x = ssx * 0.5})

		TLE.Event.Wait(2)
		self.world:emit("tween_depth_zoom", 5, 4/max_n_cam_t)
		self.world:emit("tween_camera_scale", self.camera, 5, self.scale)
		self.world:emit("tween_camera_pos", self.camera, 5, w * 0.5, h * 0.5)
		self.world:emit("destroy_key", "skip")

		TLE.Event.Wait(1)
		self.e_title_light:remove("hidden")
		self.e_title_light:remove("light_disabled")
		self.e_title:remove("hidden")
			:give("color_fade_in", 4)
			:give("color_fade_in_finish", "resume_tle")
		self.timeline:Pause()

		TLE.Event.Wait(2)
		self.world:emit("stop_parallax")
		Flux.to(car_pos, 5, {x = ssx * 1.5})

		-- TODO implement lightning to quickly black out scene
		if not is_switching then
			should_fade = true
			Fade.fade_out(function()
				Save.toggle_flag("intro_done", true)
				is_raining = false
				is_switching = true
				self.ps1.system:stop()
				self.ps2.system:stop()
				self.world:emit("switch_state", "Outside")
			end, 2)
		end
	end)
end

function Intro:state_update(dt)
	@@profb("intro_update")
	!if _DEV then
	if Inputs.pressed("play") then
		self.timeline:Unpause()
	end
	!end

	if Save.data.intro_done or !(_DEV) then
		if not is_switching then
			if Inputs.pressed("interact") then
				self.world:emit("destroy_key", "skip")
				should_fade = true
				Fade.fade_out(function()
					Save.toggle_flag("intro_done", true)
					is_raining = false
					is_switching = true
					self.ps1.system:stop()
					self.ps2.system:stop()
					self.world:emit("switch_state", "Outside")
				end, 2)
			end
		end
	end

	if is_raining then
		@@profb("intro_rain_update")
		self.ps1:update(dt)
		self.ps2:update(dt)
		@@profe("intro_rain_update")
	end

	self.world:emit("parallax_move_x", dt, -1)

	if ngrading.status == 2 then
		@@profb("intro_ngrading_multi")
		ngrading.multi:set_dt(ngrading.dt)
		@@profe("intro_ngrading_multi")
	end

	self.world:emit("update", dt)
	self.world:emit("update_light", dt)
	@@profe("intro_update")
end

function Intro:state_draw()
	@@profb("intro_draw")
	@@profb("draw_light")
	self.world:emit("draw_light_start")
	self.world:emit("draw_light")

	love.graphics.setBlendMode("alpha")
	love.graphics.setColor(1, 1, 1, 1)
	love.graphics.setCanvas(self.canvases.main.canvas)

	@@profb("intro_camera_draw")
	self.camera:attach()
		if current_ngrading then
			current_ngrading:apply()
		end

		love.graphics.draw(img_bg)
		self.world:emit("draw")
		self.world:emit("draw_z")

		if is_raining then
			@@profb("intro_rain_draw")
			self.ps1:draw(0, -16)
			self.ps2:draw(0, -16)
			@@profe("intro_rain_draw")
		end

		love.graphics.setShader()
		self.world:emit("draw_light_end", self.canvases.main.x, self.canvases.main.y)
	self.camera:detach()
	@@profe("intro_camera_draw")
	@@profe("draw_light")

	self.world:emit("draw_clip")
	self.world:emit("draw_ui")
	if should_fade then Fade.draw() end

	love.graphics.setCanvas()
	self.canvases.main:render()
	@@profe("intro_draw")
end

function Intro:state_keypressed(key)
	if key == "space" then
		self.world:emit("start_trees")
	end
end

function Intro:cleanup()
	self.timeline:Die()
	self.ps1.system:stop()
	self.ps2.system:stop()
	ngrading = {dt = 0, dt2 = 0, status = 1}
	fade_duration = 4
	current_ngrading = nil
	is_raining = false
	is_switching = false
	rain_amount = {16, 32, 96}
	should_fade = false
	intro_text_n = 1
	img_bg = nil
end

function Intro:resume_tle()
	self.timeline:Unpause()
end

return Intro

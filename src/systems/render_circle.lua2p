local Concord = require("modules.concord.concord")

local pi = math.pi

local RenderCircle = Concord.system({
	pool = {"pos", "circle", "draw_mode", "!ui_element"},
	pool_arc = {"pos", "arc", "draw_mode", "!ui_element"},
	pool_ui = {"pos", "circle", "draw_mode"},
	pool_arc_ui = {"pos", "arc", "draw_mode"},
})

function RenderCircle:internal_draw(e)
	local pos = e.pos.pos
	local circle = e.circle
	local color = e.color
	local line_width = e.line_width
	local mode = e.draw_mode.draw_mode

	if color then
		love.graphics.setColor(color.color)
	end

	if line_width then
		love.graphics.setLineWidth(line_width.line_width)
	end

	love.graphics.circle(mode, pos.x, pos.y, circle.radius, circle.segments)
end

function RenderCircle:internal_draw_arc(e)
	local pos = e.pos.pos
	local arc = e.arc
	local arc_type = e.arc_type
	local hold = e.hold
	local color = e.color
	local line_width = e.line_width
	local mode = e.draw_mode.draw_mode
	local temp_line_width = love.graphics.getLineWidth()

	if color then
		love.graphics.setColor(color.color)
	end

	if line_width then
		love.graphics.setLineWidth(line_width.line_width)
	end

	local a = arc.start_angle
	local b = arc.end_angle

	if hold then
		b = a + (hold.current_time * 2 * pi/hold.max_time)
	end

	if arc_type then
		love.graphics.arc(mode, arc_type.arc_type,
			pos.x, pos.y, arc.radius, a, b, arc.segments)
	else
		love.graphics.arc(mode, pos.x, pos.y, arc.radius, a, b, arc.segments)
	end

	love.graphics.setLineWidth(temp_line_width)
end

function RenderCircle:draw()
	for _, e in ipairs(self.pool) do
		self:internal_draw(e)
	end

	for _, e in ipairs(self.pool_arc) do
		self:internal_draw_arc(e)
	end
end

function RenderCircle:draw_ui()
	for _, e in ipairs(self.pool_ui) do
		self:internal_draw(e)
	end

	for _, e in ipairs(self.pool_arc_ui) do
		self:internal_draw_arc(e)
	end
end

return RenderCircle

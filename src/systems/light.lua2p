local Concord = require("modules.concord.concord")

local Light = Concord.system({
	pool_normal = {"id", "position", "transform", "color",
		"light", "light_type", "sprite",
	},
	pool_flicker = {"id", "position", "transform", "color",
		"light", "light_type", "light_flicker", "light_timer", "sprite"
	},
	pool_flash = {"id", "position", "transform", "color",
		"light", "light_type", "light_flashing", "light_timer", "sprite"
	},
})

local function randomf(min, max)
	return min + love.math.random() * (max - min)
end

local function generate_flicker(e)
	local light = e.light
	local color = e.color
	local range = e.light_flicker.color_range
	local power_range = e.light_flicker.power_range
	local timer = e.light_timer
	local speed_range = e.light_flicker.speed_range

	color[1] = randomf(range.min[1], range.max[1])
	color[2] = randomf(range.min[2], range.max[2])
	color[3] = randomf(range.min[3], range.max[3])

	light.power = randomf(power_range.x, power_range.y)
	timer.timer = randomf(speed_range.x, speed_range.y)
end

function Light:init(world)
	self.world = world
	self.ambient = {0.3, 0.3, 0.3}
end

function Light:set_light_resources(res)
    !if _ASSERT then
    Assert.must(res, Types.T_TABLE)
    Assert.must(res.round, Types.T_IMAGE)
    Assert.must(res.rectangle, Types.T_IMAGE)
    Assert.must(res.cone, Types.T_IMAGE)
    !end

    self.resources = res
end

function Light:create_light_map(w, h)
	!if _ASSERT then
	Assert.must(w, Types.T_NUMBER)
	Assert.must(h, Types.T_NUMBER)
	!end

    self.w = w
    self.h = h
	self.light_map = love.graphics.newCanvas(w, h)
end

function Light:camera_on_scale(scale)
	!if _ASSERT then
	Assert.must(scale, Types.T_NUMBER)
	!end

	self.scale = scale
end

function Light:update_light(dt)
	for _, e in ipairs(self.pool_flicker) do
		local light = e.light
		local timer = e.timer

		if light.enabled then
			if (timer.timer > 0) then
				timer.timer = timer.timer - dt
			else
				generate_flicker(e)
			end
		end
	end

	for _, e in ipairs(self.pool_flash) do
		local light = e.light
		local timer = e.timer
		local flash = e.light_flashing
		local max_power = flash.max_power
		local speed = flash.speed

		if light.enabled then
			timer.timer = timer.timer + dt
			if (light.power < max_power) then
				light.power = (max_power * timer.timer)/speed
			else
				e:remove()
			end
		end
	end
end

function Light:draw_light_start()
	love.graphics.setCanvas(self.light_map)
	love.graphics.setBlendMode("add")
	love.graphics.clear(self.ambient)
end

function Light:draw_light()
	local _r, _g, _b, _a = love.graphics.getColor()

	for _, e in ipairs(self.pool_normal) do
		local light = e.light

		if (light.enabled) then
			local color = e.color.color
			local sprite = e.sprite.sprite
			local power = light.power
			local pos = e.position.pos
			local transform = e.transform

			love.graphics.setColor(color)
			love.graphics.draw(sprite, pos.x, pos.y, transform.rot,
				transform.sx * power, transform.sy * power,
				transform.ox, transform.oy)
		end
	end

	for _, e in ipairs(self.pool_flicker) do
		local light = e.light

		if (light.enabled) then
			local color = e.color.color
			local sprite = light.sprite
			local power = light.power
			local pos = e.position.pos
			local transform = e.transform

			love.graphics.setColor(color)
			love.graphics.draw(sprite, pos.x, pos.y, transform.rot,
				transform.sx * power, transform.sy * power,
				transform.ox, transform.oy)
		end
	end

	for _, e in ipairs(self.pool_flash) do
		local light = e.light

		if (light.enabled) then
			local color = e.color.color
			local sprite = light.sprite
			local power = light.power
			local pos = e.position.pos
			local transform = e.transform

			love.graphics.setColor(color)
			love.graphics.draw(sprite, pos.x, pos.y, transform.rot,
				transform.sx * power, transform.sy * power,
				transform.ox, transform.oy)
		end
	end

	love.graphics.setColor(_r, _g, _b, _a)
	love.graphics.setBlendMode("alpha")
	-- love.graphics.setCanvas()
end

function Light:draw_light_end(x, y, scale)
	love.graphics.setBlendMode("multiply", "premultiplied")
	love.graphics.draw(self.light_map, x, y, 0, scale, scale)
	love.graphics.setBlendMode("alpha")
end

function Light:cleanup()
	self.world:clear()
	self.light_map:release()
end

!if not _RELEASE then
local Slab = require("modules.slab")
local DebugFlags = require("debug_flags")
local views = DebugFlags.views
local light_types = {"normal", "flicker", "flash"}
local selected
local selected_pool
local is_open
local selected_e
local mouse_light = false
local e_mouse_light

function Light:draw_debug()
	views.light = Slab.BeginWindow("Light", {
		Title = "Light", IsOpen = views.light})

	if Slab.CheckBox(mouse_light, "Mouse Light") then
		if (not mouse_light) and (not e_mouse_light) then
			e_mouse_light = Concord.entity(self.world)
				:give("id", "mouse_light")
				:give("position", vec2:new(0, 0))
				:give("transform", 0, 1, 1)
				:give("color", {1, 1, 1})
				:give("light", "round", 1)
				:give("sprite", self.resources.round)
				:give("light_type", "normal")
				:give("follow_mouse")
		end

		mouse_light = not mouse_light
	end

	if mouse_light then
		local mx, my = e_mouse_light.position.pos:unpack()
		Slab.Indent()
		Slab.Text("x: " .. mx)
		Slab.Text("y: " .. my)
		Slab.Unindent()
	end

	if Slab.Button("Add Light") then
		local e = Concord.entity(self.world)
			:give("id", "test_light")
			:give("position", vec2:new(self.w/2, self.h/2))
			:give("transform", 0, 1, 1)
			:give("color", {1, 1, 1, 1})
			:give("light", "round", 1)
			:give("sprite", self.resources.round)
			:give("light_type", "normal")
	end

	if Slab.BeginComboBox("Lights", {Selected = selected}) then
		for i, v in ipairs(light_types) do
			if Slab.TextSelectable(v) then
				selected = v

				if i == 1 then
					selected_pool = self.pool_normal
				elseif i == 2 then
					selected_pool = self.pool_flicker
				else
					selected_pool = self.pool_flash
				end
			end
		end
		Slab.EndComboBox()
	end

	if selected_pool then
		for _, e in ipairs(selected_pool) do
			local id = e.id.id

			Slab.Text(id)
			Slab.SameLine()

			if Slab.Button("edit") then
				selected_e = e
			end
		end
	end
	Slab.EndWindow()

	if selected_e then
		self:edit_light()
	end
end

function Light:edit_light()
	local e = selected_e
	local id = e.id.id
	local pos = e.position.pos
	local light = e.light

	is_open = Slab.BeginWindow("LightEdit", {
	Title = id, IsOpen = is_open})
	Slab.Text("Position: ")
	Slab.SameLine()

	if Slab.Input("x", {
		Text = tostring(pos.x), ReturnOnText = false, NumbersOnly = true}) then
		pos.x = Slab.GetInputNumber()
	end

	Slab.SameLine()

	if Slab.Input("y", {
		Text = tostring(pos.y), ReturnOnText = false, NumbersOnly = true}) then
		pos.y = Slab.GetInputNumber()
	end

	Slab.Text("Power:")
	Slab.SameLine()

	if Slab.Input("power", {
		Text = tostring(light.power), ReturnOnText = false,
		NumbersOnly = true}) then
		light.power = Slab.GetInputNumber()
	end

	Slab.EndWindow()
end
!end

return Light

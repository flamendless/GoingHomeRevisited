local Concord = require("modules.concord.concord")

local Light = Concord.system({
	pool_camera = {"camera"},
	pool_p = {"id", "point_light", "pos", "diffuse"},
})

local shader_geometry = "shaders/geometry_pass.glsl"
local shader_lighting = "shaders/lighting_pass.glsl"
local lvfp = {{"lpos", "float", 4}} -- pos.xyz, scale
local lvft = {{"ldir", "float", 4}} -- dir.xyz, angle
local lvfd = {{"diffuse", "float", 3}} -- color
local r = !({math.cos(math.pi/32), math.sin(math.pi/32)})
local MAX_LIGHTS = 32

function Light:init(world)
	self.world = world
	self.lighting_pass = love.graphics.newShader(shader_lighting)

	self.m_point = self:create_mesh_p()

	self.pool_camera.onAdded = function(pool, e)
		self.camera = e.camera.camera
	end

	self.pool_p.onAdded = function(pool, e)
		local pos = e.pos
		local pl = e.point_light
		local diffuse = e.diffuse
		local ld = e.light_dir
		local dir = ld and ld.value or {1, 0, 0, -2}

		self.m_point.pos:setVertex(#pool, {pos.x, pos.y, pos.z, pl.size})
		self.m_point.diffuse:setVertex(#pool, diffuse.value)
		self.m_point.dir:setVertex(#pool, dir)
	end
end

function Light:create_light_shaders_ngrading(ngrading)
	@@assert(ngrading:type() == "NGrading")
	local str_ngrading = ngrading:get_shader()
	local geometry = love.filesystem.read(shader_geometry)
	self.geometry_pass = love.graphics.newShader(str_ngrading .. geometry)
	ngrading:setup_data(self.geometry_pass)
end

function Light:update_lights(dt)
	local mx, my = love.mouse.getPosition()
	for i, e in ipairs(self.pool_p) do
		if e.debug_follow_mouse then
			local pl = e.point_light
			local pos = e.pos
			local wx, wy = self.camera:toWorld(mx, my)
			self.m_point.pos:setVertex(i, {wx, wy, pos.z, pl.size})
			pos.x = wx
			pos.y = wy
		end
	end
end

function Light:begin_geometry_pass()
	love.graphics.setShader(self.geometry_pass)
end

function Light:begin_light_pass(buffers)
	@@assert(type(buffers) == "table" and #buffers == 2)
	love.graphics.setShader(self.lighting_pass)
	self.lighting_pass:send("cb", buffers[1].canvas)
	self.lighting_pass:send("nb", buffers[2].canvas)
end

function Light:draw_lights()
	love.graphics.drawInstanced(self.m_point.light, #self.pool_p)
end

function Light:create_mesh_p()
	local v = {{0,0, 0,0, 0,0,0,1}, {0,1, 0,0, 1,1,1,1}}
	for _ = 1, 64 do
		local t = v[#v]
		v[#v+1] = {t[1]*r[1] - t[2]*r[2], t[1]*r[2] + t[2]*r[1], 0,0, 1,1,1,1}
	end
	local light = love.graphics.newMesh(v, nil, "static")
	local m_position = love.graphics.newMesh(lvfp, MAX_LIGHTS)
	local m_diffuse =  love.graphics.newMesh(lvfd, MAX_LIGHTS)
	local m_direction = love.graphics.newMesh(lvft, MAX_LIGHTS)
	light:attachAttribute("lpos", m_position, "perinstance")
	light:attachAttribute("diffuse", m_diffuse, "perinstance")
	light:attachAttribute("ldir", m_direction, "perinstance")
	return {
		light = light,
		pos = m_position,
		diffuse = m_diffuse,
		dir = m_direction,
	}
end

return Light

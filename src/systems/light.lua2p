local Concord = require("modules.concord.concord")

local Light = Concord.system({
	pool_camera = {"camera"},
	pool_u = {"id", "uniform_light", "light_mesh", "light_pos", "diffuse"},
	pool_p = {"id", "point_light", "light_mesh", "light_pos", "diffuse", "pos"},
	pool_light = {"id", "light_mesh", "light_pos", "diffuse"},
})

local shader_geometry = "shaders/geometry_pass.glsl"
local shader_lighting = "shaders/lighting_pass.glsl"

function Light:init(world)
	self.world = world
	self.lighting_pass = love.graphics.newShader(shader_lighting)

	self.pool_camera.onAdded = function(pool, e)
		self.camera = e.camera.camera
	end
end

function Light:create_light_shaders_ngrading(ngrading)
	@@assert(ngrading:type() == "NGrading")
	local str_ngrading = ngrading:get_shader()
	local geometry = love.filesystem.read(shader_geometry)
	self.geometry_pass = love.graphics.newShader(str_ngrading .. geometry)
	ngrading:setup_data(self.geometry_pass)
end

function Light:update_lights(dt)
	local mx, my = love.mouse.getPosition()
	for _, e in ipairs(self.pool_p) do
		local pl = e.point_light
		local pos = e.pos
		local wx, wy = self.camera:toWorld(mx, my)
		e.light_pos.value:setVertex(1, {wx, wy, pl.z, pl.size})
		pos.x = wx
		pos.y = wy
	end
end

function Light:begin_geometry_pass()
	love.graphics.setShader(self.geometry_pass)
end

function Light:begin_light_pass(buffers)
	@@assert(type(buffers) == "table" and #buffers == 2)
	love.graphics.setShader(self.lighting_pass)
	self.lighting_pass:send("cb", buffers[1].canvas)
	self.lighting_pass:send("nb", buffers[2].canvas)
end

function Light:draw_lights()
	for _, e in ipairs(self.pool_light) do
		local l_mesh = e.light_mesh
		love.graphics.drawInstanced(l_mesh.value, 1)
	end
end

return Light

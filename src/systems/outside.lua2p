local Concord = require("modules.concord.concord")
local Flux = require("modules.flux.flux")
local Gamera = require("modules.gamera.gamera")
local Log = require("modules.log.log")
local Timer = require("modules.hump.timer")
local TLE = require("modules.tle.timeline")

local AnimationData = require("animation_data")
local Blur = require("blur")
local Canvas = require("canvas")
local Fade = require("fade")
local Inputs = require("inputs")
local Items = require("items")
local NGrading = require("ngrading")
local Resources = require("resources")
local Palette = require("palette")
local ScreenInfo = require("screen_info")
local Settings = require("settings")

local format = string.format
local min = math.min
local floor = math.floor
local insert = table.insert

local Assemblages = {
	Common = require("assemblages.common"),
	Inventory = require("assemblages.inventory"),
	Outside = require("assemblages.outside"),
	Player = require("assemblages.player"),
	UI = require("assemblages.ui"),
}

local ParticleSystems = {
	RainOutside = require("particle_systems/rain_outside"),
}

local tasks = {
	"Get out of the car",
	"Check inventory",
	"Get inside the house",
}
local subtasks = {}

local Outside = Concord.system({
	pool_splashes = {"splashes"},
	pool_interactive = {"interactive"},
	pool_item = {"item"},
})

local function tle_log(msg)
	local str = format("TLE: %s", msg)
	Log.debug(str)
end

function Outside:init(world)
	self.world = world
	self.is_raining = false
	self.rain_state = {current = 128}
	self.fireflies_flag = false
	self.overlay = {0, 0, 0, 1}
end

function Outside:state_setup()
	local w, h = Resources.data.images.bg_house:getDimensions()
	local ww, hh = love.graphics.getDimensions()
	local ambient_color = {0.3, 0.3, 0.3}

	Blur.new()
	self.main_canvas = Canvas.create_main({})
	self.scale = min(ww/w, hh/h)

	self.camera = Gamera.new(0, 0, w, h)
	self.camera:setWindow(0, 0, ww, hh)
	Concord.entity(self.world):assemble(Assemblages.Common.camera,
		self.camera, self.scale, w, h)

	ScreenInfo.set(w, h, w, h)
	self.world:emit("create_light_map", self.main_canvas.x, self.main_canvas.y, w, h)
	self.world:emit("set_ambient_light", ambient_color)

	local _, _, cw, _ = self.camera:getVisible()
	self.ps1 = ParticleSystems.RainOutside:new(Resources.data.images.rain_drop, 128, cw)
	self.ps2 = ParticleSystems.RainOutside:new(Resources.data.images.rain_drop2, 128, cw)

	local bg_house = Resources.data.images.bg_house
	local bg_house_w, bg_house_h = bg_house:getDimensions()
	local div = 4
	local qw = bg_house_w/div
	local qh = bg_house_h

	for i = 1, div do
		local x = bg_house_w * ((i - 1) % div)/div
		local y = bg_house_h * floor((i - 1)/div)/div
		local quad = love.graphics.newQuad(x, y, qw, qh, bg_house_w, bg_house_h)
		Concord.entity(self.world):assemble(Assemblages.Outside.bg_house,
			x, y, quad)
	end

	Concord.entity(self.world):assemble(Assemblages.Outside.house_light)

	--setup colliders
	for _, v in pairs(Assemblages.Outside.colliders) do
		Concord.entity(self.world):assemble(v, w, h)
	end

	local rev_map = Inputs.rev_map
	insert(subtasks, format("Press '%s' to interact", rev_map.interact))
	insert(subtasks, format("Press '%s' to open inventory", rev_map.inventory))
	insert(subtasks, format("Press '%s' or '%s' to move", rev_map.left, rev_map.right))

	Concord.entity(self.world):assemble(Assemblages.Outside.splashes)
	self.world:emit("generate_fireflies")

	local lut_size, lut_dusk
	if Settings.current.graphics_quality == "low" then
		lut_size = 16
		lut_dusk = Resources.data.image_data.lut_dusk_16
	else
		lut_size = 64
		lut_dusk = Resources.data.image_data.lut_dusk_64
	end
	self.effect = NGrading:new(lut_dusk, lut_size)
end

function Outside:state_init()
	--TEST
	!if _DEV then
	local e_player = self:spawn_player()
	self.camera:setScale(3)
	self.camera:setPosition(e_player.pos.x, e_player.pos.y)
	!end

	self.timeline = TLE.Do(function()
		-- self.world:emit("set_sys_inventory", false)
		!if _DEV then
		-- self:start_tasks()
		self.world:emit("player_can_move", true)
		self.world:emit("player_can_interact", true)
		self.world:emit("player_can_run", true)
		self.timeline:Pause()
		!end

		Fade.set_alpha(0)
		self.is_raining = true
		self.fireflies_flag = true
		self.overlay_flag = true
		self.ps1.system:setEmissionRate(self.rain_state.current)
		self.ps2.system:setEmissionRate(self.rain_state.current)

		tle_log("begin timeline")
		self.world:emit("set_camera_transform", self.camera, {x = 0, y = 0, scale = 6})

		tle_log("start fade in")
		Flux.to(self.overlay, 4, {[4] = 0})
			:oncomplete(function()
				self.overlay_flag = false
				tle_log("end fade in")
			end)

		tle_log("start camera pan and zoom")
		local dt_cam = {}
		dt_cam.x, dt_cam.y = self.camera:getPosition()
		dt_cam.scale = self.camera:getScale()
		Flux.to(dt_cam, 6, {x = 532, y = 235, scale = 5})
			:delay(2)
			:onupdate(function()
				self.world:emit("set_camera_transform", self.camera, {
					x = dt_cam.x,
					y = dt_cam.y,
					scale = dt_cam.scale,
				})
			end)
			:oncomplete(function()
				self.timeline:Unpause()
			end)
		self.timeline:Pause()

		Flux.to(dt_cam, 10, {x = 720, y = 263, scale = 3})
			:onupdate(function()
				self.camera:setPosition(dt_cam.x, dt_cam.y)
				self.camera:setScale(dt_cam.scale)
			end)

		tle_log("begin rain fade")
		TLE.Event.Wait(3)
		self:start_rain()
		self.timeline:Pause()
		self:start_tasks()
		self.timeline:Pause()
	end)
end

function Outside:state_update(dt)
	self.world:emit("preupdate", dt)
	!if _DEV then
	if Inputs.pressed("play") then
		self.timeline:Unpause()
	end
	!end
	self.world:emit("update", dt)
	self.world:emit("update_light", dt)
	self.world:emit("on_camera_move", self.camera)

	local mx, my = love.mouse.getPosition()
	local wmx, wmy = self.camera:toWorld(mx, my)

	self.world:emit("check_mouse_hover", wmx, wmy)
	self.world:emit("check_mouse_hover_ui", mx, my)
	self.world:emit("hover_effects")

	if self.is_raining then
		self.ps1:update(dt)
		self.ps2:update(dt)
	end
end

function Outside:state_draw()
	self.world:emit("draw_light_start")
	self.world:emit("draw_light")
	love.graphics.setBlendMode("alpha")
	love.graphics.setColor(1, 1, 1, 1)
	love.graphics.setCanvas(self.main_canvas.canvas)
	self.camera:attach()
		self.effect:apply()
		love.graphics.draw(Resources.data.images.bg_sky)
		self.world:emit("draw")
		self.world:emit("draw_z")
		if self.is_raining then
			self.ps1:draw(0, -16)
			self.ps2:draw(0, -16)
		end
		love.graphics.setShader()
		self.world:emit("draw_light_end")
		if self.overlay_flag then
			local l, t, w, h = self.camera:getVisible()
			love.graphics.setColor(self.overlay)
			love.graphics.rectangle("fill", l, t, w, h)
		end
	self.camera:detach()
	self.world:emit("draw_clip")
	self.world:emit("draw_ui")
	Fade.draw()

	love.graphics.setCanvas()
	Blur.draw()
	self.main_canvas:render()
	love.graphics.setShader()
	self.world:emit("draw_inventory")
end

function Outside:start_rain()
	local dur_fade_rain = 8
	for _, e in ipairs(self.pool_splashes) do
		e:give("color_fade_out", dur_fade_rain)
	end

	Flux.to(self.rain_state, dur_fade_rain, {current = 0})
		:onupdate(function()
			self.ps1.system:setEmissionRate(self.rain_state.current)
			self.ps2.system:setEmissionRate(self.rain_state.current)
			if self.rain_state.current <= 16 then
				if self.fireflies_flag then
					self.world:emit("move_fireflies")
					self.world:emit("show_fireflies", 5)
					self.fireflies_flag = false
					tle_log("fireflies start")
				end
			end
		end)
		:oncomplete(function()
			for _, e in ipairs(self.pool_splashes) do
				e:destroy()
			end
			tle_log("splashes stopped")
			self.is_raining = false
			self.ps1.system:stop()
			self.ps2.system:stop()
			self.timeline:Unpause()
			self.world:emit("cleanup_rain")
			tle_log("end rain fade")
		end)
end

function Outside:create_task(task, subtask)
	local ww, hh = love.graphics.getDimensions()
	local dur_fade_task = 1.25
	local str_task = tasks[task]
	local str_subtask = subtasks[subtask]
	tle_log("task: " .. str_task)
	tle_log("subtask: " .. str_subtask)
	Concord.entity(self.world):assemble(Assemblages.UI.ui_text_paint,
			str_task, "task", ww * 0.5, hh * 0.9)
		:give("animation_data", AnimationData.get("brush"))
		:give("task", Palette.get("ui_feedback"))
	Concord.entity(self.world):assemble(Assemblages.UI.ui_text_paint,
			str_subtask, "task", ww * 0.5, hh * 0.1)
		:give("animation_data", AnimationData.get("cloud"))
		:give("subtask", Palette.get("ui_feedback"))
	self.world:emit("show_next_task", dur_fade_task)
	self.world:emit("show_next_subtask", dur_fade_task)
end

function Outside:start_tasks()
	local timer_hold_key = 1
	local dur_fade_task = 1.25
	local interact_key = "interact"
	local key_id = Inputs.rev_map[interact_key]
	local ww, hh = love.graphics.getDimensions()
	local x = ww * 0.5
	local y = hh * 0.5
	local radius = 64

	self:create_task(1, 1)
	Concord.entity(self.world):assemble(Assemblages.UI.hold_progress_bg, x, y, radius)
		:give("target_color", Palette.get("ui_hold_progress", 0.3), dur_fade_task)
		:give("task_await")
	local e_progress = Concord.entity(self.world):assemble(Assemblages.UI.hold_progress,
			interact_key, x, y, timer_hold_key, radius)
		:give("color_fade_in", dur_fade_task)
		:give("task_await")
		:give("key")
		e_progress:give("hold_on_finish", "on_hold_finished", 0, e_progress.key.value)
	local e_key = Concord.entity(self.world):assemble(Assemblages.UI.key,
			key_id, x, y - 4, "ui")
		:give("color_fade_in", dur_fade_task)
		:give("layer", "hold_key", 3)
		:give("task_await")
	Concord.entity(self.world):assemble(Assemblages.UI.keypress,
			true, "sheet_keypress")
		:give("attach_to", e_progress)
		:give("target_key", e_key)
		:give("color_fade_in", dur_fade_task)
		:give("current_frame")
		:give("layer", "hold_key", 2)
		:give("animation_on_update", "sync_key")
		:give("task_await")
	self.timeline:Pause()

	self:spawn_player()
	self.world:emit("player_can_move", true)
	Flux.to(self.camera, 1, {scale = 3})

	TLE.Event.Wait(0.25)
	self:create_task(2, 2)

	local key_id_inv = Inputs.rev_map["inventory"]
	local e_key_inv = Concord.entity(self.world):assemble(Assemblages.UI.key,
			key_id_inv, x, y - 4, "ui")
		:give("color_fade_in", dur_fade_task)
		:give("layer", "hold_key", 3)
		:give("task_await")
	Concord.entity(self.world):assemble(Assemblages.UI.keypress,
			true, "sheet_keypress")
		:give("attach_to", e_key_inv)
		:give("target_key", e_key_inv)
		:give("color_fade_in", dur_fade_task)
		:give("current_frame")
		:give("layer", "hold_key", 2)
		:give("animation_on_update", "sync_key")
		:give("task_await")
		:give("on_keypressed", "on_inv_keypressed")
		:give("key_value", "inventory")
	self.timeline:Pause()

	TLE.Event.Wait(0.25)
	self:create_task(3, 3)
	self.world:emit("player_can_interact", true)

	local dur = 1.75
	local scale = 1.75
	local scale_sdf = scale - 0.75
	local ax = ww * 0.35
	local ay = hh * 0.5

	local sheet = Resources.data.images.sheet_arrows
	local offset = 16
	local size = sheet:getWidth()/4 + offset
	local e_left = Concord.entity(self.world):assemble(Assemblages.UI.arrow,
			"left", ax, ay)
		:give("quad_transform", 0, scale, scale, size, size * 0.5)
		:give("quad_size", size)
		:give("color_fade_in", dur)
		:give("task_await")
	local e_right = Concord.entity(self.world):assemble(Assemblages.UI.arrow,
			"right", ax, ay)
		:give("quad_transform", 0, scale, scale, 0, size * 0.5)
		:give("quad_size", size)
		:give("color_fade_in", dur)
		:give("task_await")

	local key_left = Inputs.rev_map.left
	local key_right = Inputs.rev_map.right
	local lt = e_left.quad_transform
	local rt = e_right.quad_transform
	local lx = ax - (lt.ox * lt.sx) * 0.65
	local ly = ay - (lt.oy * lt.sy) * 0.35
	local rx = ax + size * 0.8
	local ry = ay - (rt.oy * rt.sy) * 0.35
	local jamboree_fnt = "res/fonts/Jamboree.fnt"
	local jamboree_png = "res/fonts/Jamboree.png"
	local e_key_left = Concord.entity(self.world):assemble(Assemblages.UI.key_sdf,
			key_left, lx, ly, jamboree_fnt, jamboree_png)
		:give("sdf", scale_sdf, scale_sdf)
		:give("color_fade_in", dur)
	local e_key_right = Concord.entity(self.world):assemble(Assemblages.UI.key_sdf,
			key_right, rx, ry, jamboree_fnt, jamboree_png)
		:give("sdf", scale_sdf, scale_sdf)
		:give("color_fade_in", dur)

	e_key_left:give("subtask_reliance", {e_key_right})
		:give("task_on_update", "on_keypress_update", 0, "left", e_left)
	e_key_right:give("subtask_reliance", {e_key_left})
		:give("task_on_update", "on_keypress_update", 0, "right", e_right)
end

function Outside:on_hold_finished(e_key)
	@@assert(type(e_key) == "string")
	local e = self.world:getEntityByKey(e_key)
	@@assert(e.__isEntity)
	tle_log("interact hold key completed")
	self.world:emit("fade_out_task_await", 0.75)
	self.world:emit("on_complete_task", self.timeline, 1.25)
	self.world:emit("on_complete_subtask", nil, 1.25)
	e:remove("hold_on_finish")
end

function Outside:on_keypress_update(dt, e, key_id, e_key)
	@@assert(e.__isEntity)
	@@assert(e_key.__isEntity)
	local dur = 1.125
	local tc = e.subtask_completed
	if not tc and Inputs.pressed(key_id) then
		e:give("subtask_completed")
			:give("target_color", Palette.get("ui_feedback", 0), dur)
			:give("lerp_on_finish", "destroy_entity", 0, e)
		e_key:give("target_color", Palette.get("ui_feedback", 0), dur)
			:give("lerp_on_finish", "destroy_entity", 0, e_key)
	end
end

function Outside:on_inv_keypressed(e)
	@@assert(e.__isEntity)
	local dur = 1.125
	local e_key = e.target_key.target_key
	e:give("target_color", Palette.get("ui_feedback", 0), dur)
		:give("lerp_on_finish", "destroy_entity", 0, e)
		:remove("on_keypressed")
	e_key:give("target_color", Palette.get("ui_feedback", 0), dur)
		:give("lerp_on_finish", "destroy_entity", 0, e_key)
	self.world:emit("fade_out_task_await", 0.75)
	self.world:emit("on_complete_task", self.timeline, 1.25)
	self.world:emit("on_complete_subtask", nil, 1.25)
end

function Outside:on_subtasks_finish()
	self.world:emit("clear_subtasks")
	self.world:emit("on_complete_subtask", self.timeline, 1.25)
end

function Outside:sync_key(dt, e)
	@@assert(e.__isEntity)
	local key = e.target_key.target_key
	local pos = key.pos
	local current_frame = e.current_frame.value
	if current_frame == 1 then
		pos.y = pos.orig_y
	elseif current_frame == 2 then
		pos.y = pos.orig_y + 4
	elseif current_frame == 3 then
		pos.y = pos.orig_y + 8
	end

	local hold = e.attach_to.target_e.hold
	if hold then
		if hold.is_held then
			e.animation.anim8:gotoFrame(e.animation_data.n_frames)
		elseif hold.was_held then
			e.animation.anim8:gotoFrame(1)
		end
	end
end

function Outside:spawn_player()
	local dur_camera_follow = 1.5
	local e_player = Concord.entity(self.world)
		:assemble(Assemblages.Player.outside_house, false, false)
		:give("color_fade_in", 0.25)
	self.world:emit("face_left", e_player)
	self.world:emit("camera_follow", e_player, dur_camera_follow)
	return e_player
end

function Outside:check_backdoor(e, dialogues_t)
	@@assert(e.__isEntity and e.dialogue)
	@@assert(type(dialogues_t) == "table")
	self.world:emit("remove_choices")
	local id
	for _, e2 in ipairs(self.pool_item) do
		local item = e2.item
		if item.got and item.id == "backdoor_key" then
			id = "door_unlocked"
			break
		end
	end
	if not id then
		id = "door_locked"
	end
	local t = tablex.copy(dialogues_t[id])
	self.world:emit("update_dialogue", e, t)
end

function Outside:get_flashlight(e, dialogues_t)
	@@assert(e.__isEntity and e.dialogue)
	@@assert(type(dialogues_t) == "table")
	local has_flashlight = Items.has("flashlight")
	if not has_flashlight then
		Items.add("flashlight")
		self.world:emit("wait_dialogue", true)
		Timer.after(2, function()
			self.world:emit("wait_dialogue", false)
			local t = tablex.copy(dialogues_t.get_flashlight)
			self.world:emit("update_dialogue", e, t)
		end)
	else
		local t = tablex.copy(dialogues_t.has_flashlight_already)
		self.world:emit("update_dialogue", e, t)
	end
end

return Outside

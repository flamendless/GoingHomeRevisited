local Concord = require("modules.concord.concord")
local Flux = require("modules.flux.flux")
local Gamera = require("modules.gamera.gamera")
local Log = require("modules.log.log")
local Timer = require("modules.hump.timer")
local TLE = require("modules.tle.timeline")

local Blur = require("blur")
local Canvas = require("canvas")
local Fade = require("fade")
local Inputs = require("inputs")
local Items = require("items")
local NGrading = require("ngrading")
local Resources = require("resources")
local Save = require("save")
local Settings = require("settings")

local format = string.format
local min = math.min
local floor = math.floor

local Assemblages = {
	Common = require("assemblages.common"),
	Inventory = require("assemblages.inventory"),
	Light = require("assemblages.light"),
	Outside = require("assemblages.outside"),
	Player = require("assemblages.player"),
	UI = require("assemblages.ui"),
}

local ParticleSystems = {
	RainOutside = require("particle_systems/rain_outside"),
}

local Outside = Concord.system({
	pool_splashes = {"splashes"},
	pool_bump = {"bump"},
	pool_car_lights = {"car_lights"},
})

local function tle_log(msg)
	local str = format("TLE: %s", msg)
	Log.debug(str)
end

function Outside:init(world)
	self.world = world
	self.is_raining = false
	self.rain_state = {current = 128}
	self.overlay = {0, 0, 0, 1}
	self.main_car_light = nil
end

function Outside:state_setup()
	local bg_house = Resources.data.images.bg_house
	local w, h = bg_house:getDimensions()
	local ww, hh = love.graphics.getDimensions()

	Blur.new()
	self.buffers = {
		Canvas.create_main({}),
		Canvas.create_main({}),
	}
	self.canvas = Canvas.create_main({})
	self.scale = min(ww/w, hh/h)

	self.camera = Gamera.new(0, 0, w, h)
	self.camera:setWindow(0, 0, ww, hh)
	Concord.entity(self.world):assemble(Assemblages.Common.camera,
		self.camera, self.scale, w, h)
	Concord.entity(self.world):assemble(Assemblages.Outside.bg)

	local _, _, cw, _ = self.camera:getVisible()
	self.ps1 = ParticleSystems.RainOutside(Resources.data.images.rain_drop, 128, cw)
	self.ps2 = ParticleSystems.RainOutside(Resources.data.images.rain_drop2, 128, cw)

	local bg_house_w, bg_house_h = bg_house:getDimensions()
	local div = 4
	local qw = bg_house_w/div
	local qh = bg_house_h

	for i = 1, div do
		local x = bg_house_w * ((i - 1) % div)/div
		local y = bg_house_h * floor((i - 1)/div)/div
		local quad = love.graphics.newQuad(x, y, qw, qh, bg_house_w, bg_house_h)
		Concord.entity(self.world):assemble(Assemblages.Outside.bg_house,
			x, y, quad)
	end

	--setup colliders
	for _, v in pairs(Assemblages.Outside.colliders) do
		Concord.entity(self.world):assemble(v, w, h)
	end
	self.world:emit("parse_room_items", "atlas_outside_items", "outside_items")

	Concord.entity(self.world):assemble(Assemblages.Outside.splashes)
	self.world:emit("generate_fireflies")

	local lut_size, lut_dusk
	if Settings.current.graphics_quality == "low" then
		lut_size = 16
		lut_dusk = Resources.data.image_data.lut_dusk_16
	else
		lut_size = 64
		lut_dusk = Resources.data.image_data.lut_dusk_64
	end
	self.effect = NGrading(lut_dusk, lut_size, nil, false)
	self.world:emit("create_light_shaders_ngrading", self.effect)

	--setup lights
	for k, v in pairs(Assemblages.Outside.lights) do
		local e = Concord.entity(self.world):assemble(v, k)
		if e.id.value == "pl_car_headlight" then
			self.main_car_light = e
		end
	end

	--setup end of headlights
	local bx, by = 585, 323
	local r, s = 4, 64
	local color = {6, 6, 3}
	local ix, iy = 10, 1
	for i = 1, 4 do
		local d = i - 1
		Concord.entity(self.world):assemble(Assemblages.Light.point,
			bx + ix * d, by - iy * d, r, s, color)
		:give("id", "pl_headlight_end" .. i)
		:give("car_lights")
	end
end

function Outside:state_init()
	--TEST
	!if _DEV then
	local e_player = self:spawn_player()
	self.camera:setScale(3)
	self.camera:setPosition(e_player.pos.x, e_player.pos.y)
	!end
	if Save.data.outside_intro_done then return end

	self.timeline = TLE.Do(function()
		!if _DEV then
		self.world:emit("camera_follow", e_player, 0.25)
		self.world:emit("player_can_move", true)
		self.world:emit("player_can_interact", true)
		self.world:emit("player_can_run", true)
		self.timeline:Pause()
		!end

		Fade.set_alpha(0)
		self.is_raining = true
		self.overlay_flag = true
		self.ps1.system:setEmissionRate(self.rain_state.current)
		self.ps2.system:setEmissionRate(self.rain_state.current)

		tle_log("begin timeline")
		self.world:emit("set_camera_transform", self.camera, {x = 0, y = 0, scale = 6})

		tle_log("start fade in")
		Flux.to(self.overlay, 4, {[4] = 0})
			:oncomplete(function()
				self.overlay_flag = false
				tle_log("end fade in")
			end)

		tle_log("start camera pan and zoom")
		local dt_cam = {}
		dt_cam.x, dt_cam.y = self.camera:getPosition()
		dt_cam.scale = self.camera:getScale()
		Flux.to(dt_cam, 6, {x = 532, y = 235, scale = 5})
			:delay(2)
			:onupdate(function()
				self.world:emit("set_camera_transform", self.camera, {
					x = dt_cam.x,
					y = dt_cam.y,
					scale = dt_cam.scale,
				})
			end)
			:oncomplete(function()
				self.timeline:Unpause()
			end)
		self.timeline:Pause()

		Flux.to(dt_cam, 10, {x = 720, y = 263, scale = 3})
			:onupdate(function()
				self.camera:setPosition(dt_cam.x, dt_cam.y)
				self.camera:setScale(dt_cam.scale)
			end)
			:oncomplete(function()
				self.timeline:Unpause()
			end)
		self.timeline:Pause()

		tle_log("begin rain fade")
		self:start_rain_fade()
		self.timeline:Pause()

		tle_log("car light off")
		self.main_car_light:give("d_light_flicker", 2.5, 0.75, 0.25)
			:give("on_d_light_flicker_during", "on_car_light_flicker")
			:give("on_d_light_flicker_after", "on_car_light_flicker_after")
			:give("d_light_flicker_remove_after")
		self.timeline:Pause()

		tle_log("show player")
		local dur_camera_follow = 1.5
		local e_player = self:spawn_player()
		dt_cam.x, dt_cam.y = self.camera:getPosition()
		dt_cam.scale = self.camera:getScale()
		Flux.to(dt_cam, 3, {x = e_player.pos.x, y = e_player.pos.y, scale = 3})
			:onupdate(function()
				self.world:emit("set_camera_transform", self.camera, {
					x = dt_cam.x,
					y = dt_cam.y,
					scale = dt_cam.scale,
				})
			end)
			:oncomplete(function()
				self.world:emit("camera_follow", e_player, dur_camera_follow)
				self.world:emit("player_can_move", true)
				self.world:emit("player_can_interact", true)
				self.world:emit("player_can_run", true)
			end)
		self.timeline:Pause()
	end)
end

function Outside:state_update(dt)
	self.world:emit("preupdate", dt)
	!if _DEV then
	if Inputs.pressed("play") then
		self.timeline:Unpause()
	elseif Inputs.pressed("inventory") then
		if not Items.has("flashlight") then
			Items.add("flashlight")
		end
	end
	!end
	self.world:emit("update", dt)
	self.world:emit("update_light_fading", dt)

	if self.is_raining then
		self.ps1:update(dt)
		self.ps2:update(dt)
	end
end

function Outside:state_draw()
	self.camera:attach()
		love.graphics.setCanvas(self.buffers[1].canvas, self.buffers[2].canvas)
			love.graphics.clear()
			self.world:emit("begin_geometry_pass")
				love.graphics.setColor(1, 1, 1)
				self.world:emit("draw_bg")
				self.world:emit("draw")
				self.world:emit("draw_z")
			love.graphics.setShader() --unset geometry_pass

		love.graphics.setCanvas(self.canvas.canvas)
			self.world:emit("begin_light_pass", self.buffers)
				love.graphics.clear()
				love.graphics.setBlendMode("add")
				self.world:emit("draw_lights")
				love.graphics.setBlendMode("alpha")
			love.graphics.setShader() --unset lighting_pass
	self.camera:detach()
			--ambient light color
			love.graphics.setBlendMode("add")
			love.graphics.setColor(0.3, 0.3, 0.3, 0.6)
			love.graphics.draw(self.buffers[1].canvas)
			if self.is_raining then
				local l, t = self.camera:getVisible()
				local s = self.camera:getScale()
				love.graphics.push()
				love.graphics.translate(l, t)
				love.graphics.scale(s)
				self.ps1:draw(0, -16)
				self.ps2:draw(0, -16)
				love.graphics.pop()
			end
			love.graphics.setBlendMode("alpha")
			self.world:emit("draw_clip")
			self.world:emit("draw_ui")
		love.graphics.setCanvas() --unset canvas.canvas

	Blur.draw()
		self.canvas:render_n()
	love.graphics.setShader()

	self.world:emit("draw_inventory")
	self.world:emit("draw_dialogues")

	if self.overlay_flag then
		self.camera:attach()
		local l, t, w, h = self.camera:getVisible()
		love.graphics.setColor(self.overlay)
		love.graphics.rectangle("fill", l, t, w, h)
		self.camera:detach()
	end
	Fade.draw()
end

function Outside:start_rain_fade()
	local dur_fade_rain = 8
	for _, e in ipairs(self.pool_splashes) do
		e:give("color_fade_out", dur_fade_rain)
	end

	Flux.to(self.rain_state, dur_fade_rain, {current = 0})
		:onupdate(function()
			self.ps1.system:setEmissionRate(self.rain_state.current)
			self.ps2.system:setEmissionRate(self.rain_state.current)
		end)
		:oncomplete(function()
			for _, e in ipairs(self.pool_splashes) do
				e:destroy()
			end
			self.is_raining = false
			self.ps1.system:stop()
			self.ps2.system:stop()
			tle_log("splashes stopped")

			tle_log("fireflies start")
			self.world:emit("move_fireflies")
			self.world:emit("show_fireflies", 5)
			self.timeline:Unpause()

			self.world:emit("cleanup_rain")
			tle_log("end rain fade")
		end)
end

function Outside:on_car_light_flicker()
	local main_diff = self.main_car_light.diffuse.value
	for _, e in ipairs(self.pool_car_lights) do
		if e ~= self.main_car_light then
			local diff = e.diffuse.value
			diff[1] = main_diff[1]
			diff[2] = main_diff[2]
			diff[3] = main_diff[3]
			self.world:emit("update_light_diffuse", e)
		end
	end
end

function Outside:on_car_light_flicker_after()
	for _, e in ipairs(self.pool_car_lights) do
		local diff = e.diffuse
		diff.value[1] = diff.orig_value[1]
		diff.value[2] = diff.orig_value[2]
		diff.value[3] = diff.orig_value[3]
		self.world:emit("update_light_diffuse", e)
	end
	self.timeline:Unpause()
end

function Outside:spawn_player()
	local x, y
	!if _DEV then
	x, y = 800, 258
	!end
	if self.prev_id == "Menu" then
		x, y = 800, 258
	end
	local e_player = Concord.entity(self.world)
		:assemble(Assemblages.Player.outside_house, x, y)
		:give("color_fade_in", 0.25)
	self.world:emit("face_left", e_player)
	return e_player
end

function Outside:get_flashlight(e, dialogues_t)
	@@assert(e.__isEntity and e.dialogue)
	@@assert(type(dialogues_t) == "table")
	self.world:emit("player_open_locked_door")
	local has_flashlight = Items.has("flashlight")
	if not has_flashlight then
		Items.add("flashlight")
		self.world:emit("wait_dialogue", true)
		Timer.after(2, function()
			self.world:emit("wait_dialogue", false)
			local t = tablex.copy(dialogues_t.get_flashlight)
			self.world:emit("update_dialogue", e, t)
		end)
	else
		local t = tablex.copy(dialogues_t.has_flashlight_already)
		self.world:emit("update_dialogue", e, t)
	end
end

function Outside:toggle_car_power(ent)
	--TODO play sound
	self.world:emit("wait_dialogue", true)
	self.world:emit("remove_choices")
	local mcl = self.main_car_light.light_disabled
	for _, e in ipairs(self.pool_car_lights) do
		e:remove("light_disabled")
	end
	self.main_car_light:give("d_light_flicker", 2, 0.75, 0.25)
		:give("on_d_light_flicker_during", "on_car_light_flicker")
		:give("on_d_light_flicker_after", "toggle_car_power_after", 0, ent, mcl)
		:give("d_light_flicker_remove_after")
end

function Outside:toggle_car_power_after(ent, flag)
	for _, e in ipairs(self.pool_car_lights) do
		if flag then
			e:remove("light_disabled")
		else
			e:give("light_disabled")
		end
	end
	self.world:emit("wait_dialogue", false)
	self.world:emit("dialogue_reached_end", ent)
end

function Outside:check_frontdoor(e, dialogues_t)
	@@assert(e.__isEntity and e.dialogue)
	@@assert(type(dialogues_t) == "table")
	self.world:emit("remove_choices")
	local has_frontdoor_key = Items.has("frontdoor_key")
	if not has_frontdoor_key then
		local t = tablex.copy(dialogues_t.door_locked)
		self.world:emit("update_dialogue", e, t)
	end
end

function Outside:make_car_interactive(ent)
	for _, e in ipairs(self.pool_bump) do
		if e.id.value == "car" then
			e:give("interactive")
			break
		end
	end
	self.world:emit("dialogue_reached_end", ent)
end

function Outside:check_has_flashlight(e, dialogues_t)
	@@assert(e.__isEntity and e.dialogue)
	@@assert(type(dialogues_t) == "table")
	local has_flashlight = Items.has("flashlight")
	if not has_flashlight then
		local t = tablex.copy(dialogues_t.no_flashlight_yet)
		self.world:emit("player_open_locked_door")
		self.world:emit("update_dialogue", e, t)
	else
		self.world:emit("dialogue_reached_end", e)
		self.world:emit("player_can_move", false)
		self.world:emit("player_can_interact", false)
		self.world:emit("player_open_door")
		self.world:emit("switch_state", "StorageRoom", 3, 1)
	end
end

function Outside:on_item_use(item_e)
	@@assert(item_e.__isEntity and item_e.item)
	local item = item_e.item
	if item.id == "flashlight" then
		self.world:emit("set_sys_dialogues", true)
		self.world:emit("set_sys_inventory", false)
		self.world:emit("spawn_dialogue_ex", {
			"I can't use it here",
		}, nil, "dialogue_to_inventory")
	end
end

function Outside:on_item_equip(item_e)
	@@assert(item_e.__isEntity and item_e.item)
	local item = item_e.item
	if item.id == "flashlight" then
		self.world:emit("set_sys_dialogues", true)
		self.world:emit("set_sys_inventory", false)
		self.world:emit("spawn_dialogue_ex", {
			"It's not that dark yet",
			"No need to use it and waste power",
		}, nil, "dialogue_to_inventory")
	end
end

return Outside

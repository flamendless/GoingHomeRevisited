local Concord = require("modules.concord.concord")
local Bump = require("modules.bump.bump-niji")

local BumpCollision = Concord.system({
	pool = {"collider", "pos", "bump"},
})

local function filter(item, other)
	local other_col = other.collider
	return other_col.filter or "slide"
end

function BumpCollision:init(world)
	self.world = world
	self.bump_world = Bump.newWorld()

	self.pool.onAdded = function(pool, e)
		local x = e.pos.x + e.collider.ox
		local y = e.pos.y + e.collider.oy
		self.bump_world:add(e, x, y, e.collider.w, e.collider.h)
	end
end

function BumpCollision:preupdate(dt)
	for _, e in ipairs(self.pool) do
		e.collider.is_hit = false
	end
end

function BumpCollision:update(dt)
	for _, e in ipairs(self.pool) do
		if e.body then
			self:update_body(e)
		end
	end
end

function BumpCollision:update_body(e)
	local body = e.body
	local pos = e.pos
	local cols, len

	pos.x, pos.y, cols, len = self.bump_world:move(e,
		pos.x + body.vel_x,
		pos.y + body.vel_y,
		filter)

	for i = 1, len do
		local c = cols[i]

		local other = c.other
		local other_col = other.collider
		local other_id = other.bump.id

		other_col.is_hit = true
		other_col.normal.x = c.normalX
		other_col.normal.y = c.normalY

		if other.interactive then
			if not other_col.prev_hit then
				other_col.prev_hit = true
				self.world:emit("interactive_collided", e, other)
			end
		end
	end

	self.bump_world.freeCollisions(cols)
end

return BumpCollision

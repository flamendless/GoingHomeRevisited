local Concord = require("modules.concord.concord")
local Bump = require("modules.bump.bump-niji")
local BumpStorage = require("ctor.bump_storage")

local BumpCollision = Concord.system({
	pool = {
		constructor = BumpStorage,
		"collider", "pos", "bump"
	},
})

local function get_query_rect(self)
	if self.world.current_state.camera then
		return self.world.current_state.camera:getVisible()
	else
		return 0, 0, love.graphics.getDimensions()
	end
end

local function get_query_point(self)
	local mx, my = love.mouse.getPosition()
	local camera = self.world.current_state.camera
	if camera then
		mx, my = camera:toWorld(mx, my)
	end
	return mx, my
end

local function filter(item, other)
	local other_col = other.collider
	return other_col.filter or "slide"
end

function BumpCollision:init(world)
	self.world = world
end

function BumpCollision:preupdate(dt)
	for _, e in self.pool:ipairs() do
		e.collider.is_hit = false
		!if _DEV then
		e.bump.debug_hovered = false
		!end
	end
end

function BumpCollision:update(dt)
	local x, y, w, h = get_query_rect(self)
	local items, len = self.pool.bump_world:queryRect(x, y, w, h)
	for i = 1, len do
		local e = items[i]
		if e.body then
			!if _DEV then
			if e.bump.debug_clicked then
				return
			end
			!end
			self:update_body(e)
		end
	end
end

function BumpCollision:update_body(e)
	local body = e.body
	local pos = e.pos
	local cols, len

	pos.x, pos.y, cols, len = self.pool.bump_world:move(e,
		pos.x + body.vel_x,
		pos.y + body.vel_y,
		filter)

	for i = 1, len do
		local c = cols[i]

		local other = c.other
		local other_col = other.collider
		local other_id = other.bump.id

		other_col.is_hit = true
		other_col.normal.x = c.normalX
		other_col.normal.y = c.normalY

		if other.interactive then
			if not other_col.prev_hit then
				other_col.prev_hit = true
				self.world:emit("interactive_collided", e, other)
			end
		end
	end

	self.pool.bump_world.freeCollisions(cols)
end

!if _DEV then
local Slab = require("modules.slab")
local flags = {
	ids = false,
	bodies = true,
	drag = false,
	visible_only = true,
}

local function edit(id, value, t)
	Slab.Text(id .. ":")
	Slab.SameLine()
	if Slab.Input(id, {
		Text = tostring(value),
		ReturnOnText = false,
		NumbersOnly = true,
	}) then
		value = Slab.GetInputNumber()
		t[id] = value
	end
	return value
end

function BumpCollision:debug_update(dt)
	if not self.debug_show then return end
	self.debug_show = Slab.BeginWindow("BumpCollision", {
		Title = self.debug_title,
		IsOpen = self.debug_show
	})
	if Slab.CheckBox(flags.bodies, "Bodies") then
		flags.bodies = not flags.bodies
	end
	Slab.SameLine()
	if Slab.CheckBox(flags.ids, "IDs") then
		flags.ids = not flags.ids
	end
	Slab.SameLine()
	if Slab.CheckBox(flags.drag, "Drag") then
		flags.drag = not flags.drag
		self.world:emit("debug_on_drag", flags.drag)
	end
	if Slab.CheckBox(flags.visible_only, "Visible Only") then
		flags.visible_only = not flags.visible_only
	end

	if Slab.BeginTree("List", {Title = "List"}) then
		Slab.Indent()
		local items, len
		if flags.visible_only then
			local x, y, w, h = get_query_rect(self)
			items, len = self.pool.bump_world:queryRect(x, y, w, h)
		else
			items, len = self.pool.bump_world:getItems()
		end

		for i = 1, len do
			local e = items[i]
			local id = e.id.value
			if Slab.BeginTree(id, {Title = id, IsOpen = e.bump.debug_selected}) then
				Slab.Indent()
				local x, y, w, h = self.pool.bump_world:getRect(e)
				x = edit("x", x, e.pos)
				y = edit("y", y, e.pos)
				w = edit("w", w, e.collider)
				h = edit("h", h, e.collider)
				self.pool.bump_world:update(e, x, y, w, h)
				Slab.EndTree()
			end
		end
		Slab.EndTree()
	end

	local mx, my = get_query_point(self)
	local items, len = self.pool.bump_world:queryPoint(mx, my)
	for i = 1, len do
		local e = items[i]
		e.bump.debug_hovered = true
		e.bump.debug_selected = love.mouse.isDown(2)
	end
	Slab.EndWindow()
end

function BumpCollision:debug_draw()
	if flags.bodies then
		local x, y, w, h = get_query_rect(self)
		local items, len = self.pool.bump_world:queryRect(x, y, w, h)
		for i = 1, len do
			local e = items[i]
			local id = e.id.value
			local x, y, w, h = self.pool.bump_world:getRect(e)
			local scale = 1
			local camera = self.world.current_state.camera
			if camera then scale = camera:getScale() end

			love.graphics.setLineWidth(1/scale)
			if e.bump.debug_hovered then
				love.graphics.setColor(1, 1, 0, 0.7)
			else
				love.graphics.setColor(1, 0, 0, 0.7)
			end
			love.graphics.rectangle("line", x, y, w, h)
			if flags.ids then
				love.graphics.print(id, x, y)
			end
		end
	end
end

function BumpCollision:debug_mousemoved(mx, my, dx, dy)
	if flags.drag then
		mx, my = get_query_point(self)
		local x, y, w, h = get_query_rect(self)
		local items, len = self.pool.bump_world:queryRect(x, y, w, h)
		for i = 1, len do
			local e = items[i]
			if e.bump.debug_clicked then
				local x, y, w, h = self.pool.bump_world:getRect(e)
				e.pos.x = mx
				e.pos.y = my
				self.pool.bump_world:update(e, e.pos.x, e.pos.y, w, h)
			end
		end
	end
end

function BumpCollision:debug_mousepressed(mx, my, mb)
	if not flags.drag then return end
	if mb ~= 1 then return end
	mx, my = get_query_point(self)
	local items, len = self.pool.bump_world:queryPoint(mx, my)
	for i = 1, len do
		local e = items[i]
		if e.bump.debug_hovered then
			e.bump.debug_clicked = true
		end
	end
end

function BumpCollision:debug_mousereleased(mx, my, mb)
	if flags.drag and mb == 1 then
		mx, my = get_query_point(self)
		local x, y, w, h = get_query_rect(self)
		local items, len = self.pool.bump_world:queryRect(x, y, w, h)
		for i = 1, len do
			local e = items[i]
			if e.bump.debug_clicked then
				local x, y, w, h = self.pool.bump_world:getRect(e)
				e.pos.x = mx
				e.pos.y = my
				e.bump.debug_clicked = false
				self.pool.bump_world:update(e, e.pos.x, e.pos.y, w, h)
			end
		end
	end
end
!end

return BumpCollision

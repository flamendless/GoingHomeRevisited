local Concord = require("modules.concord.concord")

local Helper = require("helper")

local RenderSprite = Concord.system({
	pool = {"pos", "sprite",
		"!z_index", "!ui_element", "!light", "!nf_render_sprite", "!use_canvas"},
	pool_z = {"pos", "sprite", "z_index",
		"!ui_element", "!light", "!nf_render_sprite", "!use_canvas"},
	-- pool_outline = {"pos", "sprite", "outline"},
})

local function sort_z_ex(a, b)
	local a_z = a.z_index
	local b_z = b.z_index

	if a_z.sortable and b_z.sortable then
		local a_pos = a.pos
		local b_pos = b.pos
		return a_pos.y < b_pos.y
	elseif a_z.current and b_z.current then
		return a_z.current < b_z.current
	end

	return a_z.value < b_z.value
end

local function draw(e, ...)
	local outline = e.outline
	local outline_val = e.outline_val
	if outline and outline.outliner then
		outline.outliner:draw(outline_val.value, ...)
	else
		love.graphics.draw(...)
	end
end

function RenderSprite:init(world)
	self.world = world

	self.pool_z.onAdded = function(pool, e)
		self:sort_z()
	end

	self.pool_z.onRemoved = function(pool, e)
		self:sort_z()
	end
end

function RenderSprite:sort_z()
	self.pool_z:sort(sort_z_ex)
	for i, e in ipairs(self.pool_z) do
		local z = e.z_index
		z.current = i
	end
end

function RenderSprite:draw_sprite_ex(e)
	local hidden = e.hidden
	local culled = e.cullabl and e.cullable.value
	if hidden or culled then return end

	local pos = e.pos
	local quad = e.quad
	local color = e.color
	local sprite = e.sprite
	local transform = e.transform
	local quad_transform = e.quad_transform

	love.graphics.setColor(1, 1, 1, 1)
	if color then love.graphics.setColor(color.value) end

	local rot, sx, sy, ox, oy, kx, ky
	if transform then
		rot = transform.rotation
		ox, oy = Helper.get_offset(e)
		sx = transform.sx
		sy = transform.sy
		kx = transform.kx
		ky = transform.ky
	end

	local temp_shader
	if e.no_shader then
		temp_shader = love.graphics.getShader()
		love.graphics.setShader()
	end

	if quad then
		if quad_transform then
			rot = quad_transform.rotation
			sx = quad_transform.sx
			sy = quad_transform.sy
			ox = quad_transform.ox
			oy = quad_transform.oy
			kx = quad_transform.kx
			ky = quad_transform.ky
		end
		draw(e, sprite.image, quad.quad, pos.x, pos.y, rot, sx, sy, ox, oy, kx, ky)
	else
		draw(e, sprite.image, pos.x, pos.y, rot, sx, sy, ox, oy, kx, ky)
	end

	if e.no_shader then
		love.graphics.setShader(temp_shader)
	end
end

function RenderSprite:draw()
	@@profb("render_sprite")
	for _, e in ipairs(self.pool) do
		self:draw_sprite_ex(e)
	end
	@@profe("render_sprite")
end

function RenderSprite:draw_z()
	@@profb("render_sprite_z")
	local temp
	for _, e in ipairs(self.pool_z) do
		if e.fog and not e.hidden then
			temp = love.graphics.getShader()
			@@profb("draw_fog")
			self.world:emit("draw_fog", e)
			self:draw_sprite_ex(e)
			self.world:emit("end_draw_fog")
			@@profe("draw_fog")
		elseif e.outline and not e.hidden then
			temp = love.graphics.getShader()
			self:draw_sprite_ex(e)
		else
			if temp then
				love.graphics.setShader(temp)
			end
			self:draw_sprite_ex(e)
		end
	end
	@@profe("render_sprite_z")
end

-- function RenderSprite:draw_outline()
-- 	local cur_shader = love.graphics.getShader()
-- 	for _, e in ipairs(self.pool_outline) do
-- 		self:draw_sprite_ex(e)
-- 	end
-- 	love.graphics.setShader(cur_shader)
-- end

!if _DEV then
local Slab = require("modules.slab")

function RenderSprite:debug_update(dt)
	if not self.debug_show then return end
	self.debug_show = Slab.BeginWindow("z", {
		Title = "Z-Index",
		IsOpen = self.debug_show
	})
	for _, e in ipairs(self.pool_z) do
		local id = e.id.value
		local z = e.z_index
		Slab.Text(z.value)
		Slab.SameLine()
		Slab.Text(id)
		Slab.SameLine()
		Slab.Text(tostring(z.sortable))
	end
	Slab.EndWindow()
end
!end

return RenderSprite

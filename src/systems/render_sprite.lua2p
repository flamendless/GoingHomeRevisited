local Concord = require("modules.concord.concord")

local Helper = require("helper")

local RenderSprite = Concord.system({
	pool = {"pos", "sprite",
		"!z_index", "!ui_element", "!light"},
	pool_z = {"pos", "sprite", "z_index",
		"!ui_element", "!light"},
	pool_quad = {"pos", "sprite", "quad"},
})

local function sort_z_ex(a, b)
	local a_z = a.z_index
	local b_z = b.z_index

	if a_z.sortable and b_z.sortable then
		local a_pos = a.pos
		local b_pos = b.pos

		return a_pos.y < b_pos.y
	end

	return a_z.value < b_z.value
end

local function draw(sprite, ...)
	-- TODO implement camera_bounds drawing
	love.graphics.draw(sprite, ...)
end

function RenderSprite:init(world)
	self.world = world

	self.pool_z.onAdded = function(pool, e)
		self:sort_z()
	end

	self.pool_z.onRemoved = function(pool, e)
		self:sort_z()
	end
end

function RenderSprite:sort_z()
	self.pool_z:sort(sort_z_ex)
end

function RenderSprite:draw_sprite_ex(e)
	local hidden = e.hidden
	if not hidden then
		local pos = e.pos
		local quad = e.quad
		local color = e.color
		local sprite = e.sprite
		local transform = e.transform
		local quad_transform = e.quad_transform
		local animation_data = e.animation_data

		love.graphics.setColor(1, 1, 1, 1)

		if color then love.graphics.setColor(color.value) end

		local rot, sx, sy, ox, oy, kx, ky

		if transform then
			rot = transform.rotation
			ox, oy = Helper.get_offset(e)
			sx = transform.sx
			sy = transform.sy
			kx = transform.kx
			ky = transform.ky
		end

		local temp_shader

		if e.no_shader then
			temp_shader = love.graphics.getShader()
			love.graphics.setShader()
		end

		if quad then
			if quad_transform then
				rot = quad_transform.rotation
				sx = quad_transform.sx
				sy = quad_transform.sy
				ox = quad_transform.ox
				oy = quad_transform.oy
				kx = quad_transform.kx
				ky = quad_transform.ky
			end

			draw(sprite.image, quad.quad, pos.x, pos.y, rot, sx, sy, ox, oy, kx, ky)
		else
			draw(sprite.image, pos.x, pos.y, rot, sx, sy, ox, oy, kx, ky)
		end

		if e.no_shader then
			love.graphics.setShader(temp_shader)
		end
	end
end

function RenderSprite:draw()
	for _, e in ipairs(self.pool) do
		self:draw_sprite_ex(e)
	end
end

function RenderSprite:draw_z()
	for _, e in ipairs(self.pool_z) do
		self:draw_sprite_ex(e)
	end
end

return RenderSprite

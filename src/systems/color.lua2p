local Concord = require("modules.concord.concord")
local Flux = require("modules.flux.flux")

local Color = Concord.system({
	pool_fade_to_black = {"color", "fade_to_black"},
	pool_fade_in_out = {"color", "color_fade_in_out"},
	pool_colors = {"color", "lerp_colors"},
	pool_color = {"color", "target_color"},
})

function Color:init()
	self.pool_fade_in_out.onEntityAdded = function(pool, e)
		local color = e:get("color")
		local f_in_out = e:get("color_fade_in_out")
		local f
		local count = 0

		local fn_out, fn_in
		fn_out = function()
			f = Flux.to(color.color, f_in_out.duration, {
				[4] = 0
			}):oncomplete(function()
				fn_in()
				count = count + 1
				if count == f_in_out.count then
					f:stop()
					e:remove("color_fade_in_out")
				end
			end)
		end

		fn_in = function()
			f = Flux.to(color.color, f_in_out.duration, {
				[4] = 1
			}):oncomplete(function()
				fn_out()
				count = count + 1
				if count == f_in_out.count then
					f:stop()
					e:remove("color_fade_in_out")
				end
			end)
		end

		if color.color[4] == 1 then
			fn_out()
		elseif color.color[4] == 0 then
			fn_in()
		end
	end

	self.pool_color.onEntityAdded = function(pool, e)
		local color = e:get("color")
		local target = e:get("target_color")
		local on_complete = e:get("lerp_on_complete")
		Flux.to(color.color, target.duration, {
			[1] = target.target_color[1],
			[2] = target.target_color[2],
			[3] = target.target_color[3],
			[4] = target.target_color[4],
		})
		:delay(target.delay)
		:oncomplete(function()
			if on_complete then
				on_complete.callback()
				e:remove("lerp_on_complete")
			end
			e:remove("target_color")
		end)
	end
end

function Color:start_fade()
	for _, e in ipairs(self.pool_fade_to_black) do
		local color = e:get("color")
		local fade = e:get("fade_to_black")
		Flux.to(color.color, fade.duration, {
			[1] = 0,
			[2] = 0,
			[3] = 0,
			[4] = 0,
		}):delay(fade.delay)
	end
end

function Color:start_colors_lerp()
	for _, e in ipairs(self.pool_colors) do
		local color = e:get("color")
		local lc = e:get("lerp_colors")

		local lerp_colors
		lerp_colors = function(duration, delay)
			local current = lc.colors[lc.current_color]
			local next_value = lc.current_color + 1
			if next_value > #lc.colors then
				next_value = 1
			end
			local next_color = lc.colors[next_value]
			Flux.to(color.color, duration, {
				[1] = next_color[1],
				[2] = next_color[2],
				[3] = next_color[3],
				[4] = next_color[4],
			}):delay(delay):oncomplete(function()
				lc.current_color = next_value
				if lc.current_color > #lc.colors then
					lc.current_color = 1
				end
				lerp_colors(duration, delay)
			end)
		end
		lerp_colors(lc.duration, lc.delay)
	end
end


return Color

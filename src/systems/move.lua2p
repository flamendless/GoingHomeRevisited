local Concord = require("modules.concord.concord")
local Flux = require("modules.flux.flux")

local Move = Concord.system({
	pool = {"position", "move_by"},
	pool_move_x = {"position", "move_to_x"},
	pool_original = {"position", "move_to_original"},
})

function Move:init()
	self.pool.onEntityAdded = function(pool, e)
		local pos = e:get("position")
		local move_by = e:get("move_by")
		local on_complete = e:get("move_on_complete")

		local f = Flux.to(pos.pos, move_by.duration, {
				x = pos.pos.x + move_by.pos.x,
				y = pos.pos.y + move_by.pos.y
			})
		:delay(move_by.delay)
		:oncomplete(function()
			if on_complete then
				on_complete.callback()
				e:remove("move_on_complete")
			end
			e:remove("move_by")
		end)
	end

	self.pool_move_x.onEntityAdded = function(pool, e)
		local pos = e:get("position")
		local target = e:get("move_to_x")
		local on_complete = e:get("move_on_complete")

		local f = Flux.to(pos.pos, target.duration, {
				x = target.target_x,
			})
		:delay(target.delay)
		:oncomplete(function()
			if on_complete then
				on_complete.callback()
				e:remove("move_on_complete")
			end
			e:remove("move_to_x")
		end)
	end

	self.pool_original.onEntityAdded = function(pool, e)
		local pos = e:get("position")
		local move = e:get("move_to_original")
		local on_complete = e:get("move_on_complete")

		local f = Flux.to(pos.pos, move.duration, {
			x = pos.original_pos.x,
			y = pos.original_pos.y,
		})
		:delay(move.delay)
		:oncomplete(function()
			if on_complete then
				on_complete.callback()
				e:remove("move_on_complete")
			end
			e:remove("move_to_original")
		end)
	end
end

return Move

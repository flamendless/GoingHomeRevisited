local Concord = require("modules.concord.concord")
local Gamera = require("modules.gamera.gamera")
local Flux = require("modules.flux.flux")
local Log = require("modules.log.log")
local TLE = require("modules.tle.timeline")

local min = math.min
local sub = string.sub

local Assets = require("data_assets")
local Info = require("info")
local NGrading = require("ngrading")
local Preloader = require("preloader")

local StateIntro = class()
StateIntro.id = "Intro"

local Components = {}
Concord.utils.loadNamespace("components", Components)
local Systems = {
	Animation = require("systems.animation"),
	Move = require("systems.move"),
	Parallax = require("systems.parallax"),
	RandomTree = require("systems.random_tree"),
	RenderSprite = require("systems.render_sprite"),
	Transform = require("systems.transform"),
}
local Assemblages = {
	Common = require("assemblages.common"),
	Intro = require("assemblages.intro"),
}

local assets = { images = {}, image_data = {}, fonts = {} }
local effect = { single = nil, multi = nil, multi2 = nil, dt = 0, dt2 = 0, status = 1 }

function StateIntro:new()
	return self:init({
		is_ready = false,
		world = Concord.world(),
		entities = {},
		camera = nil,
	})
end

function StateIntro:load()
	Log.info("State Load: ", self.id)
	local assets_data = Assets:getData("intro")
	Preloader.start(assets_data, assets,
		function()
			self.is_ready = true
			self:start()
		end)
end

function StateIntro:start()
	self.world:addSystem(Systems.Transform)
	self.world:addSystem(Systems.Parallax)
	self.world:addSystem(Systems.RandomTree)
	self.world:addSystem(Systems.RenderSprite)
	self.world:addSystem(Systems.Move)
	self.world:addSystem(Systems.Animation)

	local ww, wh = love.graphics.getDimensions()
	local w, h = assets.images.bg:getDimensions()

	self.scale = min(ww/w, wh/h)
	self.camera = Gamera.new(0, 0, ww * 2, wh * 2)
	self.camera:setWindow(0, (wh - h * self.scale)/2, ww, wh)

	self.entities.bg = Concord.entity(self.world)
		:give("sprite", assets.images.bg)
		:give("position", vec2:new(0, 0))

	self.entities.parallax_building = Concord.entity(self.world)
		:assemble(Assemblages.Intro.parallax, assets.images.parallax_buildings, ww * 2, "building")

	self.entities.parallax_road = Concord.entity(self.world)
		:assemble(Assemblages.Intro.parallax, assets.images.parallax_road, ww * 2, "road")

	self.entities.parallax_grass = Concord.entity(self.world)
		:assemble(Assemblages.Intro.parallax, assets.images.parallax_grass, ww * 2, "grass1")

	self.entities.parallax_grass2 = Concord.entity(self.world)
		:assemble(Assemblages.Intro.parallax, assets.images.parallax_grass2, ww * 2, "grass2")

	self.entities.post = Concord.entity(self.world)
		:assemble(Assemblages.Intro.parallax, assets.images.bg_post, ww * 2, "post")

	self.entities.car = Concord.entity(self.world)
		:assemble(Assemblages.Intro.car, assets.images.sheet_car)

	self.entities.car_reflect = Concord.entity(self.world)
		:assemble(Assemblages.Intro.car_reflect, assets.images.sheet_car_reflect, self.entities.car)

	self.entities.bg_tree_data = Concord.entity(self.world)
		:assemble(Assemblages.Intro.bg_tree_data,
			{
				assets.images.bg_tree1,
				assets.images.bg_tree2,
				assets.images.bg_tree3,
			}, w * 2)

	self.entities.fg_tree_data = Concord.entity(self.world)
		:assemble(Assemblages.Intro.fg_tree_data,
			{
				assets.images.fg_tree1,
				assets.images.fg_tree2,
			}, w)

	self.world:emit("generate_tree", self.entities.bg_tree_data)
	self.world:emit("generate_tree", self.entities.fg_tree_data)

	local lut_size
	local lut_afternoon, lut_dusk, lut_night
	local gl_version = sub(Info.data.version, 1, 3)

	if gl_version == !(_MIN_GL_VERSION) then
		lut_size = 16
		lut_afternoon = assets.image_data.lut_afternoon_16
		lut_dusk = assets.image_data.lut_dusk_16
		lut_night = assets.image_data.lut_night_16
	else
		lut_size = 64
		lut_afternoon = assets.image_data.lut_afternoon_64
		lut_dusk = assets.image_data.lut_dusk_64
		lut_night = assets.image_data.lut_night_64
	end
	Log.info("Using LUT size: " .. lut_size)

	effect.single = NGrading:new(lut_afternoon, lut_size)
	effect.single:setup_data()
	effect.multi = NGrading:new(lut_afternoon, lut_dusk, lut_size)
	effect.multi:setup_data()
	effect.multi2 = NGrading:new(lut_dusk, lut_night, lut_size)
	effect.multi2:setup_data()

	self.timeline = TLE.Do(function()
		--Car enter scene
		TLE.Event.Wait(2)
		self.entities.car:give("move_to_x", 128, 5)
		--TODO do the intro

		--Slow Down
		TLE.Event.Wait(6)
		effect.status = 2
		Flux.to(effect, 5, { dt = 1 })
		self.world:emit("slow_parallax", 0.75)
		self.entities.car:give("move_to_x", 160, 0.75)

		--Car exit scene
		TLE.Event.Wait(1)
		Flux.to(effect, 5, { dt2 = 1 })
		self.world:emit("stop_parallax")
		self.entities.car:give("move_to_x", ww * 1.5, 2)

		--Transition
		TLE.Event.Wait(3)
	end)

	!if not _RELEASE then
	-- Dev.init(self.id, self.world)
	-- for k, v in pairs(self.entities) do
	-- 	v:give("debug_slab", k)
	-- end
	!end
end

function StateIntro:update(dt)
	if not self.is_ready then return end

	self.world:emit("parallax_move_x", dt, 1)

	if effect.status == 2 then
		effect.multi:set_dt(effect.dt)
	elseif effect.status == 3 then
		effect.multi2:set_dt(effect.dt2)
	end

	self.world:emit("update", dt)
end

function StateIntro:draw()
	if not self.is_ready then return end

	self.camera:draw(function()
		love.graphics.push()
		love.graphics.scale(self.scale)

		if effect.status == 1 then
			effect.single:apply()
		elseif effect.status == 2 then
			effect.multi:apply()
		elseif effect.status == 3 then
			effect.multi2:apply()
		end

		self.world:emit("draw")
		self.world:emit("draw_z")

		if effect.status == 1 then
			effect.single:unapply()
		elseif effect.status == 2 then
			effect.multi:unapply()
		elseif effect.status == 3 then
			effect.multi2:unapply()
		end

		love.graphics.pop()
	end)
end

function StateIntro:keypressed(key)
end

function StateIntro:exit()
	for k, v in pairs(self.entities) do
		self.entities[k] = nil
	end
end

return StateIntro

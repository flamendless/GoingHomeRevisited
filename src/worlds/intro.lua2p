local Concord = require("modules.concord.concord")
local Gamera = require("modules.gamera.gamera")
local Flux = require("modules.flux.flux")
local Log = require("modules.log.log")
local Lume = require("modules.lume.lume")
local Timer = require("modules.hump.timer")
local TLE = require("modules.tle.timeline")

local Dialogues = require("dialogues")
local Fade = require("fade")
local Inputs = require("inputs")
local NGrading = require("ngrading")
local Resources = require("resources")
local Preloader = require("preloader")
local Save = require("save")
local Settings = require("settings")

!if not _RELEASE then
local Slab = require("modules.slab")
local Tracker = require("tracker")
!end

local min = math.min

local StateIntro = class()
StateIntro.id = "Intro"

local Components = {}
Concord.utils.loadNamespace("components", Components)

local Systems = {
	Animation = require("systems.animation"),
	Camera = require("systems.camera"),
	Collision = require("systems.collision"),
	Color = require("systems.color"),
	Dialogues = require("systems.dialogues"),
	Parallax = require("systems.parallax"),
	Tree = require("systems.tree"),
	RenderSprite = require("systems.render_sprite"),
	RenderText = require("systems.render_text"),
	TextPaintFade = require("systems.text_paint_fade"),
	Transform = require("systems.transform"),
	-- Move = require("systems.move"),

	!if not _RELEASE then
	Debugging = require("systems.debugging"),
	!end
}

!if not _RELEASE then
local Systems = Tracker.track(Systems)
!end

local Assemblages = {
	Common = require("assemblages.common"),
	Intro = require("assemblages.intro"),
	UI = require("assemblages.ui"),
}

local ParticleSystems = {
	RainIntro = require("particle_systems/rain_intro"),
}

local resources = {images = {}, image_data = {}, fonts = {}}

local effect = {dt = 0, dt2 = 0, status = 1}
local fade_out_duration = 0.1
local dur_in = 2.5
local dur_out = 1.5
local fade_duration = 4
local current_effect
local is_raining = false
local rain_amount = {16, 32, 96}

function StateIntro:update_rain(i)
	!if _ASSERT then
	Assert.should_number(i)
	Assert.should_exists(rain_amount[i])
	!end

	local amount = rain_amount[i]

	is_raining = true
	self.ps1.system:setEmissionRate(amount)
	self.ps2.system:setEmissionRate(amount)
end

function StateIntro:new()
	return self:init({
		is_ready = false,
		world = Concord.world(),
		entities = {},
		camera = nil,
		gamestate = nil
	})
end

function StateIntro:load()
	Log.info("State Load: ", self.id)
	local resources_data = Resources.get("intro")

	Preloader.start(resources_data, resources,
		function()
			self.is_ready = true
			self:start()

			!if not _RELEASE then
			Slab.Initialize()
			!end
		end)
end

function StateIntro:start()
	self.world:addSystem(Systems.Camera)
	self.world:addSystem(Systems.Color)
	self.world:addSystem(Systems.TextPaintFade)
	self.world:addSystem(Systems.Transform)
	self.world:addSystem(Systems.Parallax)
	self.world:addSystem(Systems.Tree)
	self.world:addSystem(Systems.RenderSprite)
	self.world:addSystem(Systems.RenderText)
	self.world:addSystem(Systems.Animation)
	-- self.world:addSystem(Systems.Move)
	self.world:addSystem(Systems.Collision)
	self.world:addSystem(Systems.Dialogues)

	!if not _RELEASE then
	self.world:addSystem(Systems.Debugging)
	Tracker.warn_on_ref_count(Systems, 0)
	!end

	local res_images = resources.images
	local res_fonts = resources.fonts
	local w, h = res_images.bg:getDimensions()

	self.screen_size = vec2:new(love.graphics.getDimensions())
	self.scale = min(self.screen_size.x/w, self.screen_size.y/h)
	self.camera = Gamera.new(0, 0, w, h)
	self.camera:setWindow(0, 0, self.screen_size.x, self.screen_size.y)
	self.camera:setScale(self.scale)
	self.world:emit("camera_set", self.camera)
	self.world:emit("set_camera_clip", w, h, {0, 0, 0, 1})

	self.ps1 = ParticleSystems.RainIntro:new(res_images.rain_drop_tilted, 128, w)
	self.ps2 = ParticleSystems.RainIntro:new(res_images.rain_drop_tilted2, 128, w)

	!if not _RELEASE then
	self.world:emit("debug_particle_system", self.ps1.system)
	self.world:emit("debug_particle_system", self.ps2.system)
	!end

	self.entities.bg = Concord.entity(self.world)
		:give("sprite", res_images.bg)
		:give("position", vec2:new())

	local ssx2 = self.screen_size.x * 2

	self.entities.parallax_building = Concord.entity(self.world)
		:assemble(Assemblages.Intro.parallax,
			res_images.parallax_buildings, ssx2, "building")

	self.entities.parallax_road = Concord.entity(self.world)
		:assemble(Assemblages.Intro.parallax, res_images.parallax_road, ssx2, "road")
		:give("collider", vec2:new(self.screen_size.x, 64), vec2:new(0, 354))

	self.entities.parallax_grass = Concord.entity(self.world)
		:assemble(Assemblages.Intro.parallax, res_images.parallax_grass, ssx2, "grass1")

	self.entities.parallax_grass2 = Concord.entity(self.world)
		:assemble(Assemblages.Intro.parallax, res_images.parallax_grass2, ssx2, "grass2")

	self.entities.parallax_grass_back = Concord.entity(self.world)
		:assemble(Assemblages.Intro.parallax, res_images.parallax_grass_back, ssx2, "grass_back")

	self.entities.parallax_grass_front = Concord.entity(self.world)
		:assemble(Assemblages.Intro.parallax, res_images.parallax_grass_front, ssx2, "grass_front")

	self.entities.parallax_trees_bg = Concord.entity(self.world)
		:assemble(Assemblages.Intro.parallax, res_images.parallax_trees_bg, ssx2, "bg_trees")

	self.entities.bg_tree_cover = Concord.entity(self.world)
		:assemble(Assemblages.Intro.bg_tree_cover, res_images.bg_tree_cover)

	self.entities.parallax_trees_fg = Concord.entity(self.world)
		:assemble(Assemblages.Intro.parallax, res_images.parallax_trees_fg, ssx2, "fg_trees", 2, 2)

	self.entities.post = Concord.entity(self.world)
		:assemble(Assemblages.Intro.parallax, res_images.bg_post, ssx2, "post")

	self.entities.car = Concord.entity(self.world)
		:assemble(Assemblages.Intro.car, res_images.sheet_car)

	self.entities.car_collider_left = Concord.entity(self.world)
		:give("position", vec2:new())
		:give("attach_to", self.entities.car)
		:give("collider", vec2:new(36, 32), vec2:new(0, 16))

	self.entities.car_collider_mid = Concord.entity(self.world)
		:give("position", vec2:new())
		:give("attach_to", self.entities.car)
		:give("collider", vec2:new(45, 48), vec2:new(36, 0))

	self.entities.car_collider_right = Concord.entity(self.world)
		:give("position", vec2:new())
		:give("attach_to", self.entities.car)
		:give("collider", vec2:new(47, 32), vec2:new(81, 16))

	self.entities.car_reflect = Concord.entity(self.world)
		:assemble(Assemblages.Intro.car_reflect,
			res_images.sheet_car_reflect, self.entities.car)
		:give("animation_on_loop", function()
			local chance = Lume.randomchoice({true, false})

			if chance then
				self.entities.car_reflect:remove("hidden")
			else
				self.entities.car_reflect:give("hidden")
			end
		end)

	self.entities.paint_data = Concord.entity(self.world)
		:assemble(Assemblages.UI.paint_data, res_images.sheet_paint)

	local lut_size
	local lut_afternoon, lut_dusk

	if Settings.current.graphics_quality == "Low" then
		lut_size = 16
		lut_afternoon = resources.image_data.lut_afternoon_16
		lut_dusk = resources.image_data.lut_dusk_16
	else
		lut_size = 64
		lut_afternoon = resources.image_data.lut_afternoon_64
		lut_dusk = resources.image_data.lut_dusk_64
	end

	effect.single = NGrading:new(lut_afternoon, lut_size)
	effect.multi = NGrading:new(lut_afternoon, lut_dusk, lut_size)
	current_effect = effect.single

	self.entities.intro_txt1 = Concord.entity(self.world)
		:assemble(Assemblages.UI.ui_text, "flamendless studio presents",
			res_fonts.ui, vec2:new(32, 32))

	self.entities.intro_txt2 = Concord.entity(self.world)
		:assemble(Assemblages.UI.ui_text, !("a game by " .. _NAME_DEVELOPER),
			res_fonts.ui, vec2:new(32, 32))

	self.entities.intro_txt3 = Concord.entity(self.world)
		:assemble(Assemblages.UI.ui_text, !("arts by " .. _NAME_ARTIST),
			res_fonts.ui, vec2:new(32, 32))

	self.entities.intro_txt4 = Concord.entity(self.world)
		:assemble(Assemblages.UI.ui_text, !("music by " .. _NAME_MUSICIAN),
			res_fonts.ui, vec2:new(32, 32))

	self.entities.title = Concord.entity(self.world)
		:assemble(Assemblages.Intro.title,
			res_images.title, vec2:new(self.screen_size.x/2, self.screen_size.y/2))

	self.entities.dialogue = Concord.entity(self.world)
		:assemble(Assemblages.Intro.dialogues, "dialogue_intro",
			Dialogues.get("intro_rain"), res_fonts.dialogue,
			vec2:new(self.screen_size.x/2, 64))

	self.timeline = TLE.Do(function()
		local car_pos = self.entities.car:get("position").pos
		self.camera:setScale(15)
		self.camera:setPosition(53, 544)

		TLE.Event.Wait(2)
		local cx, cy = self.camera:getPosition()
		Flux.to(self.camera, 5, {y = cy - 64})
		Flux.to(self.camera, 5, {scale = 10})

		TLE.Event.Wait(2)
		self.world:emit("fade_text", self.entities.intro_txt1,
			fade_duration, self.timeline, true)
		self.timeline:Pause()

		local cx, cy = self.camera:getPosition()
		Flux.to(self.camera, 5, {scale = 5})
		Flux.to(self.camera, 5, {x = cx + 160, y = cy - 32})
		Flux.to(car_pos, 5, {x = 128})

		self.world:emit("fade_text", self.entities.intro_txt2,
			fade_duration, self.timeline, true)
		self.timeline:Pause()

		--Enter forest
		self.world:emit("start_bg_trees", 3)

		local cx, cy = self.camera:getPosition()

		effect.status = 2
		current_effect = effect.multi
		Flux.to(effect, 15, {dt = 1})
		Flux.to(self.camera, 5, {scale = 3})
		Flux.to(self.camera, 5, {x = cx + 72, y = cy - 32})
		Flux.to(car_pos, 3, {x = 160})

		self.world:emit("fade_text", self.entities.intro_txt3,
			fade_duration, self.timeline, true)
		self.timeline:Pause()

		self.world:emit("fade_text", self.entities.intro_txt4,
			fade_duration, self.timeline, true)
		self.timeline:Pause()

		self:update_rain(1)

		-- TODO play intro radio
		-- TLE.Event.Wait(3)

		self:update_rain(2)

		TLE.Event.Wait(3)
		self.world:emit("start_dialogue", "dialogue_intro",
			self.timeline, dur_in, dur_out)
		self.timeline:Pause()

		self:update_rain(3)

		TLE.Event.Wait(2)
		self.world:emit("slow_parallax", 0.75)
		Flux.to(car_pos, 3, {x = self.screen_size.x/2})

		TLE.Event.Wait(2)
		Flux.to(self.camera, 5, {scale = self.scale})
		Flux.to(self.camera, 5, {x = w/2, y = h/2})

		if self.entities.skip_intro then
			self.entities.skip_intro:give("hidden")
		end

		TLE.Event.Wait(1)
		local color = self.entities.title:get("color")

		self.entities.title:remove("hidden")
		Flux.to(color.color, 4, {[4] = 1})
			:oncomplete(function()
				self.timeline:Unpause()
			end)
		self.timeline:Pause()

		TLE.Event.Wait(2)
		self.world:emit("stop_parallax")
		Flux.to(car_pos, 5, {x = self.screen_size.x * 1.5})

		-- TODO implement lightning to quickly black out scene
		Fade.fade_out(function()
			Save.set_flag("intro_done", true)
			is_raining = false
			self.ps1.system:stop()
			self.ps2.system:stop()
			self.gamestate.switch("Outside")
		end, fade_out_duration)
	end)

	if Save.data.intro_done or not !(_RELEASE) then
		self.entities.skip_intro = Concord.entity(self.world)
			:assemble(Assemblages.Common.skip, res_fonts.ui,
				vec2:new(self.screen_size.x/2, self.screen_size.y - 8))
	end
end

function StateIntro:update(dt)
	if not self.is_ready then return end

	if is_raining then
		self.ps1:update(dt)
		self.ps2:update(dt)
	end

	self.world:emit("parallax_move_x", dt, 1)

	if effect.status == 2 then
		effect.multi:set_dt(effect.dt)
	end

	self.world:emit("update", dt)

	!if not _RELEASE then
	Slab.Update(dt)
	self.world:emit("update_debug", dt)
	if self.draw_debug then
		self.world:emit("draw_slab", dt)
	end
	!end
end

function StateIntro:draw()
	if not self.is_ready then return end

	self.camera:draw(function(l, t, w, h)
		if current_effect then
			current_effect:apply()
		end

		self.world:emit("draw")
		self.world:emit("draw_z")

		if is_raining then
			self.ps1:draw(0, -16)
			self.ps2:draw(0, -16)
		end

		love.graphics.setShader()

		!if not _RELEASE then
		if self.draw_debug then
			self.world:emit("draw_debug", l, t, w, h)
		end
		!end
	end)

	self.world:emit("draw_clip")
	self.world:emit("draw_ui")

	Fade.draw()

	!if not _RELEASE then
	Slab.Draw()
	!end
end

function StateIntro:keypressed(key)
	!if not _RELEASE then
	if key == "`" then
		self.draw_debug = not self.draw_debug
	end

	if key == "1" then
		self:update_rain(1)
	elseif key == "2" then
		self:update_rain(2)
	elseif key == "3" then
		self:update_rain(3)
	end
	!end

	if Save.data.intro_done or not !(_RELEASE) then
		if Inputs.is_pressed("ui_skip", key) then
			Fade.fade_out(function()
				Save.set_intro_done(true)
				self.gamestate.switch("Outside")
			end, 2)
		end
	end
end

function StateIntro:exit()
	self.world:emit("cleanup")
	self.world:clear()

	Timer.clear()
	Resources.clean(resources)

	self.ps1 = nil
	self.ps2 = nil

	for i, e in ipairs(self.world:getEntities()) do
		e:destroy()
	end

	for k, e in pairs(self.entities) do
		self.entities[k]:destroy()
		self.entities[k] = nil
	end

	effect.dt = 0
	effect.dt2 = 0
	effect.status = 1
	current_effect = nil
	is_raining = false
	self.timeline:Die()
end

return StateIntro

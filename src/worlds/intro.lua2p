local Concord = require("modules.concord.concord")
local Gamera = require("modules.gamera.gamera")
local Flux = require("modules.flux.flux")
local Log = require("modules.log.log")
local TLE = require("modules.tle.timeline")

local insert = table.insert
local min = math.min
local sub = string.sub

local Assets = require("data_assets")
local Info = require("info")
local Fade = require("fade")
local Keybinds = require("keybinds")
local NGrading = require("ngrading")
local Palette = require("palette")
local Preloader = require("preloader")
local Settings = require("settings")

local StateIntro = class()
StateIntro.id = "Intro"

local Components = {}
Concord.utils.loadNamespace("components", Components)
local Systems = {
	Animation = require("systems.animation"),
	Color = require("systems.color"),
	Parallax = require("systems.parallax"),
	RandomTree = require("systems.random_tree"),
	RenderSprite = require("systems.render_sprite"),
	RenderText = require("systems.render_text"),
	Transform = require("systems.transform"),
}
local Assemblages = {
	Common = require("assemblages.common"),
	Intro = require("assemblages.intro"),
}

local assets = { images = {}, image_data = {}, fonts = {} }
local effect = { dt = 0, dt2 = 0, status = 1 }

local current_dialogue = 1
local e_dialogues = {}
local dialogues = {
	"Hey, latest reports came in a few minutes ago.",
	"Apparently another case occured.",
	"This one's more disturbing.",
	"Anyways, I know you are on the road.",
	"I'll send the files over as soon as them",
	"investigators are done in the crime scene.",
	"I know you're on the road so umm,",
	"make sure to check it when you got home okay?",
	"Man! Things keep getting worse and wor--"
}

local fade_text = function(e, duration)
	e:remove("hidden")
	local color = e:get("color")
	Flux.to(color.color, duration, { [4] = 1 })
		:oncomplete(function()
			Flux.to(color.color, duration, { [4] = 0 }):oncomplete(function() e:give("hidden") end)
		end)
end

local duration_in = 3
local duration_out = 1
local show_dialogue
show_dialogue = function(timeline)
	if current_dialogue > #e_dialogues then
		timeline:Unpause()
	else
		local e = e_dialogues[current_dialogue]
		e:remove("hidden")
		local color = e:get("color")
		Flux.to(color.color, duration_in, { [4] = 1 })
			:oncomplete(function()
				Flux.to(color.color, duration_out, { [4] = 0 }):oncomplete(function() e:give("hidden") end)
				current_dialogue = current_dialogue + 1
				show_dialogue(timeline)
			end)
	end
end

function StateIntro:new()
	return self:init({
		is_ready = false,
		world = Concord.world(),
		entities = {},
		camera = nil,
		gamestate = nil
	})
end

function StateIntro:load()
	Log.info("State Load: ", self.id)
	local assets_data = Assets:getData("intro")
	Preloader.start(assets_data, assets,
		function()
			self.is_ready = true
			self:start()
		end)
end

function StateIntro:start()
	self.world:addSystem(Systems.Color)
	self.world:addSystem(Systems.Transform)
	self.world:addSystem(Systems.Parallax)
	self.world:addSystem(Systems.RandomTree)
	self.world:addSystem(Systems.RenderSprite)
	self.world:addSystem(Systems.RenderText)
	self.world:addSystem(Systems.Animation)

	local ww, wh = love.graphics.getDimensions()
	local w, h = assets.images.bg:getDimensions()

	self.scale = min(ww/w, wh/h)
	-- self.camera = Gamera.new(0, 0, ww * 2, wh * 2)
	-- self.camera:setWindow(0, (wh - h * self.scale)/2, ww, wh)
	self.camera = Gamera.new(0, 0, w, h)
	self.camera:setWindow(0, 0, ww, wh)
	self.camera:setScale(self.scale)

	self.entities.bg = Concord.entity(self.world)
		:give("sprite", assets.images.bg)
		:give("position", vec2:new(0, 0))

	self.entities.parallax_building = Concord.entity(self.world)
		:assemble(Assemblages.Intro.parallax, assets.images.parallax_buildings, ww * 2, "building")

	self.entities.parallax_road = Concord.entity(self.world)
		:assemble(Assemblages.Intro.parallax, assets.images.parallax_road, ww * 2, "road")

	self.entities.parallax_grass = Concord.entity(self.world)
		:assemble(Assemblages.Intro.parallax, assets.images.parallax_grass, ww * 2, "grass1")

	self.entities.parallax_grass2 = Concord.entity(self.world)
		:assemble(Assemblages.Intro.parallax, assets.images.parallax_grass2, ww * 2, "grass2")

	self.entities.parallax_grass_back = Concord.entity(self.world)
		:assemble(Assemblages.Intro.parallax, assets.images.parallax_grass_back, ww * 2, "grass_back")

	self.entities.parallax_grass_front = Concord.entity(self.world)
		:assemble(Assemblages.Intro.parallax, assets.images.parallax_grass_front, ww * 2, "grass_front")

	self.entities.post = Concord.entity(self.world)
		:assemble(Assemblages.Intro.parallax, assets.images.bg_post, ww * 2, "post")

	self.entities.car = Concord.entity(self.world)
		:assemble(Assemblages.Intro.car, assets.images.sheet_car)

	self.entities.car_reflect = Concord.entity(self.world)
		:assemble(Assemblages.Intro.car_reflect, assets.images.sheet_car_reflect, self.entities.car)

	self.entities.bg_tree_data = Concord.entity(self.world)
		:assemble(Assemblages.Intro.bg_tree_data,
			{
				assets.images.bg_tree1,
				assets.images.bg_tree2,
				assets.images.bg_tree3,
			}, w * 2)

	self.entities.fg_tree_data = Concord.entity(self.world)
		:assemble(Assemblages.Intro.fg_tree_data,
			{
				assets.images.fg_tree1,
				assets.images.fg_tree2,
			}, w)

	self.world:emit("generate_tree", self.entities.bg_tree_data)
	self.world:emit("generate_tree", self.entities.fg_tree_data)

	local lut_size
	local lut_afternoon, lut_dusk, lut_night

	if Settings.current.graphics_quality == "Low" then
		lut_size = 16
		lut_afternoon = assets.image_data.lut_afternoon_16
		lut_dusk = assets.image_data.lut_dusk_16
		lut_night = assets.image_data.lut_night_16
	else
		lut_size = 64
		lut_afternoon = assets.image_data.lut_afternoon_64
		lut_dusk = assets.image_data.lut_dusk_64
		lut_night = assets.image_data.lut_night_64
	end

	effect.single = NGrading:new(lut_afternoon, lut_size)
	effect.single:setup_data()
	effect.single2 = NGrading:new(lut_night, lut_size)
	effect.single2:setup_data()
	effect.multi = NGrading:new(lut_afternoon, lut_dusk, lut_size)
	effect.multi:setup_data()
	effect.multi2 = NGrading:new(lut_dusk, lut_night, lut_size)
	effect.multi2:setup_data()

	self.entities.intro_txt1 = Concord.entity(self.world)
		:assemble(Assemblages.Intro.ui_text, "flamendless studio presents", assets.fonts.ui, vec2:new(32, 32))

	self.entities.intro_txt2 = Concord.entity(self.world)
		:assemble(Assemblages.Intro.ui_text, "a game by Brandon", assets.fonts.ui, vec2:new(32, 32))

	self.entities.intro_txt3 = Concord.entity(self.world)
		:assemble(Assemblages.Intro.ui_text, "arts by Conrad", assets.fonts.ui, vec2:new(32, 32))

	self.entities.intro_txt4 = Concord.entity(self.world)
		:assemble(Assemblages.Intro.ui_text, "music by ???", assets.fonts.ui, vec2:new(32, 32))

	for i, str in ipairs(dialogues) do
		--TODO add voice acting dialogue
		local e = Concord.entity(self.world)
			:assemble(Assemblages.Intro.dialogue_text, str, assets.fonts.dialogue, vec2:new(ww/2, 32))
		insert(e_dialogues, e)
	end

	self.timeline = TLE.Do(function()
		local car_pos = self.entities.car:get("position").pos
		self.camera:setScale(15)
		self.camera:setPosition(53, 544)

		TLE.Event.Wait(2)
		local cx, cy = self.camera:getPosition()
		-- Flux.to(self.camera, 5, { y = 480 })
		Flux.to(self.camera, 5, { y = cy - 64 })
		Flux.to(self.camera, 5, { scale = 10 })

		TLE.Event.Wait(2)
		fade_text(self.entities.intro_txt1, 2)

		TLE.Event.Wait(3)
		local cx, cy = self.camera:getPosition()
		Flux.to(self.camera, 5, { scale = 5 })
		-- Flux.to(self.camera, 5, { x = 260, y = 460 })
		Flux.to(self.camera, 5, { x = cx + 160, y = cy - 32 })
		Flux.to(car_pos, 5, { x = 128 })

		TLE.Event.Wait(2)
		fade_text(self.entities.intro_txt2, 2)

		TLE.Event.Wait(3)
		local cx, cy = self.camera:getPosition()
		effect.status = 2
		Flux.to(effect, 15, { dt = 1 })
		Flux.to(self.camera, 5, { scale = 3 })
		-- Flux.to(self.camera, 5, { x = 356 })
		Flux.to(self.camera, 5, { x = cx + 72, y = cy - 32 })
		Flux.to(car_pos, 3, { x = 160 })

		TLE.Event.Wait(3)
		fade_text(self.entities.intro_txt3, 2)

		TLE.Event.Wait(3)
		fade_text(self.entities.intro_txt4, 2)

		TLE.Event.Wait(3)
		effect.status = 3
		Flux.to(effect, 25, { dt2 = 1 })
			:oncomplete(function()
				effect.status = 4
			end)

		TLE.Event.Wait(3)
		--TODO play intro radio

		TLE.Event.Wait(3)
		self.timeline_dialogue:Unpause()
		self.timeline:Pause()

		TLE.Event.Wait(2)
		self.world:emit("slow_parallax", 0.75)
		Flux.to(car_pos, 3, { x = ww/2 })

		TLE.Event.Wait(2)
		Flux.to(self.camera, 5, { scale = self.scale })
		-- Flux.to(self.camera, 5, { x = ww/2, y = wh/2 })
		Flux.to(self.camera, 5, { x = w/2, y = h/2 })

		TLE.Event.Wait(6)
		self.world:emit("stop_parallax")
		Flux.to(car_pos, 5, { x = ww * 1.5 })

		TLE.Event.Wait(1)
		Fade.fade_out(function()
			Settings.set_intro_done()
			self.gamestate:switch("MainGame")
		end, 2)
	end)

	self.timeline_dialogue = TLE.Do(function()
		show_dialogue(self.timeline)
	end)
	self.timeline_dialogue:Pause()

	if Settings.current.intro_done then
		self.entities.skip_intro = Concord.entity(self.world)
			:give("text", "Press ESC to skip intro")
			:give("font", assets.fonts.ui)
			:give("color", Palette:get_color("ui_red"))
			:give("position", vec2:new(ww/2, wh - 8))
			:give("ui_text")
			:give("transform", 0, 1, 1, 0.5, 1)
			:give("color_fade_in_out", 1)
	end
end

function StateIntro:update(dt)
	if not self.is_ready then return end

	self.world:emit("parallax_move_x", dt, 1)

	if effect.status == 2 then
		effect.multi:set_dt(effect.dt)
	elseif effect.status == 3 then
		effect.multi2:set_dt(effect.dt2)
	end

	self.world:emit("update", dt)
end

function StateIntro:draw()
	if not self.is_ready then return end

	self.camera:draw(function()
		if effect.status == 1 then
			effect.single:apply()
		elseif effect.status == 2 then
			effect.multi:apply()
		elseif effect.status == 3 then
			effect.multi2:apply()
		elseif effect.status == 4 then
			effect.single2:apply()
		end

		self.world:emit("draw")
		self.world:emit("draw_z")

		love.graphics.setShader()
	end)

	self.world:emit("draw_ui")
	Fade.draw()
end

function StateIntro:keypressed(key)
	if Settings.current.intro_done then
		if Keybinds.pressed_ui("skip", key) then
			self.gamestate:switch("MainGame")
		end
	end
end

function StateIntro:exit()
	Assets.clean(assets)
	for i, e in ipairs(self.world:getEntities()) do
		self.world:removeEntity(e)
	end
	effect.dt = 0
	effect.dt2 = 0
	effect.status = 1
	self.timeline:Die()
	self.timeline_dialogue:Die()
end

return StateIntro

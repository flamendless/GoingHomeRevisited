local Gamera = require("modules.gamera.gamera")
local Concord = require("modules.concord.concord")
local Log = require("modules.log.log")

local min = math.min
local random = math.random

local Assets = require("data_assets")
local Preloader = require("preloader")

local StateIntro = class()
StateIntro.id = "Intro"

local Components = {}
Concord.utils.loadNamespace("components", Components)
local Systems = {
	Animation = require("systems.animation"),
	Parallax = require("systems.parallax"),
	RandomTree = require("systems.random_tree"),
	RenderSprite = require("systems.render_sprite"),
	Transform = require("systems.transform"),
}
local Assemblages = {
	Common = require("assemblages.common"),
	Intro = require("assemblages.intro"),
}

local assets = { images = {}, fonts = {} }

function StateIntro:new()
	return self:init({
		is_ready = false,
		world = Concord.world(),
		entities = {},
	})
end

function StateIntro:load()
	Log.info("State Load: ", self.id)
	local assets_data = Assets:getData("intro")
	Preloader.start(assets_data, assets,
		function()
			self.is_ready = true
			self:start()
		end)
end

function StateIntro:start()
	self.world:addSystem(Systems.Transform)
	self.world:addSystem(Systems.Parallax)
	self.world:addSystem(Systems.RandomTree)
	self.world:addSystem(Systems.RenderSprite)
	self.world:addSystem(Systems.Animation)

	local ww, wh = love.graphics.getDimensions()
	local w, h = assets.images.bg:getDimensions()

	self.scale = min(ww/w, wh/h)
	self.camera = Gamera.new(0, 0, ww * 2, wh * 2)
	self.camera:setWindow(0, 0, ww, wh)

	self.entities.bg = Concord.entity(self.world)
		:give("sprite", assets.images.bg)
		:give("position", vec2:new(0, 0))

	self.entities.parallax_building = Concord.entity(self.world)
		:assemble(Assemblages.Intro.parallax, assets.images.parallax_buildings, ww * 2, "building")

	self.entities.parallax_road = Concord.entity(self.world)
		:assemble(Assemblages.Intro.parallax, assets.images.parallax_road, ww * 2, "road")

	self.entities.parallax_grass = Concord.entity(self.world)
		:assemble(Assemblages.Intro.parallax, assets.images.parallax_grass, ww * 2, "grass1")

	self.entities.parallax_grass2 = Concord.entity(self.world)
		:assemble(Assemblages.Intro.parallax, assets.images.parallax_grass2, ww * 2, "grass2")

	self.entities.post = Concord.entity(self.world)
		:assemble(Assemblages.Intro.parallax, assets.images.bg_post, ww * 2, "post")

	self.entities.car = Concord.entity(self.world)
		:assemble(Assemblages.Intro.car, assets.images.sheet_car, vec2:new(0, 0))

	self.entities.car_reflect = Concord.entity(self.world)
		:assemble(Assemblages.Intro.car_reflect, assets.images.sheet_car_reflect, vec2:new(0, 0), self.entities.car)

	self.entities.bg_tree_data = Concord.entity(self.world)
		:assemble(Assemblages.Intro.bg_tree_data,
			{
				assets.images.bg_tree1,
				assets.images.bg_tree2,
				assets.images.bg_tree3,
			}, w * 2)

	self.entities.fg_tree_data = Concord.entity(self.world)
		:assemble(Assemblages.Intro.fg_tree_data,
			{
				assets.images.fg_tree1,
				assets.images.fg_tree2,
			}, w)

	self.world:emit("generate_tree", self.entities.bg_tree_data)
	self.world:emit("generate_tree", self.entities.fg_tree_data)

	!if not _RELEASE then
	for k, v in pairs(self.entities) do
		v:give("debug_slab", k)
	end
	!end
end

function StateIntro:update(dt)
	if not self.is_ready then return end
	self.world:emit("update", dt)

	if love.keyboard.isDown("a") then
		self.world:emit("parallax_move_x", dt, -1)
	elseif love.keyboard.isDown("d") then
		self.world:emit("parallax_move_x", dt, 1)
	end
end

function StateIntro:draw()
	if not self.is_ready then return end
	self.camera:draw(function()
		love.graphics.push()
		love.graphics.scale(self.scale)
		self.world:emit("draw")
		self.world:emit("draw_z")
		love.graphics.pop()
	end)
end

function StateIntro:exit()
	for k, v in pairs(self.entities) do
		self.entities[k] = nil
	end
end

return StateIntro

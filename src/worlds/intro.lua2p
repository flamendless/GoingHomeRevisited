local Concord = require("modules.concord.concord")
local Gamera = require("modules.gamera.gamera")
local Flux = require("modules.flux.flux")
local Log = require("modules.log.log")
local TLE = require("modules.tle.timeline")

local min = math.min
local sub = string.sub

local Assets = require("data_assets")
local Info = require("info")
local NGrading = require("ngrading")
local Preloader = require("preloader")
local Settings = require("settings")

local StateIntro = class()
StateIntro.id = "Intro"

local Components = {}
Concord.utils.loadNamespace("components", Components)
local Systems = {
	Animation = require("systems.animation"),
	Parallax = require("systems.parallax"),
	RandomTree = require("systems.random_tree"),
	RenderSprite = require("systems.render_sprite"),
	RenderText = require("systems.render_text"),
	Transform = require("systems.transform"),
}
local Assemblages = {
	Common = require("assemblages.common"),
	Intro = require("assemblages.intro"),
}

local assets = { images = {}, image_data = {}, fonts = {} }
local effect = { single = nil, multi = nil, multi2 = nil, dt = 0, dt2 = 0, status = 1 }

local fade_text = function(e, duration)
	e:remove("hidden")
	local color_txt1 = e:get("color")
	Flux.to(color_txt1.color, duration, { [4] = 1 })
		:oncomplete(function() Flux.to(color_txt1.color, duration, { [4] = 0 }) end)
end

function StateIntro:new()
	return self:init({
		is_ready = false,
		world = Concord.world(),
		entities = {},
		camera = nil,
	})
end

function StateIntro:load()
	Log.info("State Load: ", self.id)
	local assets_data = Assets:getData("intro")
	Preloader.start(assets_data, assets,
		function()
			self.is_ready = true
			self:start()
		end)
end

function StateIntro:start()
	self.world:addSystem(Systems.Transform)
	self.world:addSystem(Systems.Parallax)
	self.world:addSystem(Systems.RandomTree)
	self.world:addSystem(Systems.RenderSprite)
	self.world:addSystem(Systems.RenderText)
	self.world:addSystem(Systems.Animation)

	local ww, wh = love.graphics.getDimensions()
	local w, h = assets.images.bg:getDimensions()

	self.scale = min(ww/w, wh/h)
	-- self.camera = Gamera.new(0, 0, ww * 2, wh * 2)
	-- self.camera:setWindow(0, (wh - h * self.scale)/2, ww, wh)
	self.camera = Gamera.new(0, 0, ww, wh)
	self.camera:setWindow(0, 0, ww, wh)

	self.entities.bg = Concord.entity(self.world)
		:give("sprite", assets.images.bg)
		:give("position", vec2:new(0, 0))

	self.entities.parallax_building = Concord.entity(self.world)
		:assemble(Assemblages.Intro.parallax, assets.images.parallax_buildings, ww * 2, "building")

	self.entities.parallax_road = Concord.entity(self.world)
		:assemble(Assemblages.Intro.parallax, assets.images.parallax_road, ww * 2, "road")

	self.entities.parallax_grass = Concord.entity(self.world)
		:assemble(Assemblages.Intro.parallax, assets.images.parallax_grass, ww * 2, "grass1")

	self.entities.parallax_grass2 = Concord.entity(self.world)
		:assemble(Assemblages.Intro.parallax, assets.images.parallax_grass2, ww * 2, "grass2")

	self.entities.parallax_grass_back = Concord.entity(self.world)
		:assemble(Assemblages.Intro.parallax, assets.images.parallax_grass_back, ww * 2, "grass_back")

	self.entities.parallax_grass_front = Concord.entity(self.world)
		:assemble(Assemblages.Intro.parallax, assets.images.parallax_grass_front, ww * 2, "grass_front")

	self.entities.post = Concord.entity(self.world)
		:assemble(Assemblages.Intro.parallax, assets.images.bg_post, ww * 2, "post")

	self.entities.car = Concord.entity(self.world)
		:assemble(Assemblages.Intro.car, assets.images.sheet_car)

	self.entities.car_reflect = Concord.entity(self.world)
		:assemble(Assemblages.Intro.car_reflect, assets.images.sheet_car_reflect, self.entities.car)

	self.entities.bg_tree_data = Concord.entity(self.world)
		:assemble(Assemblages.Intro.bg_tree_data,
			{
				assets.images.bg_tree1,
				assets.images.bg_tree2,
				assets.images.bg_tree3,
			}, w * 2)

	self.entities.fg_tree_data = Concord.entity(self.world)
		:assemble(Assemblages.Intro.fg_tree_data,
			{
				assets.images.fg_tree1,
				assets.images.fg_tree2,
			}, w)

	self.world:emit("generate_tree", self.entities.bg_tree_data)
	self.world:emit("generate_tree", self.entities.fg_tree_data)

	local lut_size
	local lut_afternoon, lut_dusk, lut_night

	if Settings.current.graphics_quality == "Low" then
		lut_size = 16
		lut_afternoon = assets.image_data.lut_afternoon_16
		lut_dusk = assets.image_data.lut_dusk_16
		lut_night = assets.image_data.lut_night_16
	else
		lut_size = 64
		lut_afternoon = assets.image_data.lut_afternoon_64
		lut_dusk = assets.image_data.lut_dusk_64
		lut_night = assets.image_data.lut_night_64
	end

	effect.single = NGrading:new(lut_afternoon, lut_size)
	effect.single:setup_data()
	effect.multi = NGrading:new(lut_afternoon, lut_dusk, lut_size)
	effect.multi:setup_data()
	effect.multi2 = NGrading:new(lut_dusk, lut_night, lut_size)
	effect.multi2:setup_data()

	self.entities.intro_txt1 = Concord.entity(self.world)
		:assemble(Assemblages.Intro.ui_text, "flamendless studio presents", vec2:new(32, 32))

	self.entities.intro_txt2 = Concord.entity(self.world)
		:assemble(Assemblages.Intro.ui_text, "a game by Brandon", vec2:new(32, 64))

	self.entities.intro_txt3 = Concord.entity(self.world)
		:assemble(Assemblages.Intro.ui_text, "arts by Conrad", vec2:new(32, 96))

	self.entities.intro_txt4 = Concord.entity(self.world)
		:assemble(Assemblages.Intro.ui_text, "music by ???", vec2:new(ww/2, wh/2))
		:give("transform", 0, 1, 1, 0.5, 0.5)

	self.timeline = TLE.Do(function()
		--Setup camera
		local cam_scale = self.camera:getScale()
		self.camera:setScale(15)
		self.camera:setPosition(53, 544)

		TLE.Event.Wait(2)
		Flux.to(self.camera, 5, { y = 480 })
		Flux.to(self.camera, 5, { scale = 10 })

		TLE.Event.Wait(2)
		fade_text(self.entities.intro_txt1, 2)

		TLE.Event.Wait(3)
		local car_pos = self.entities.car:get("position").pos
		Flux.to(self.camera, 5, { scale = 5 })
		Flux.to(self.camera, 5, { x = 260, y = 460 })
		Flux.to(car_pos, 5, { x = 128 })

		TLE.Event.Wait(2)
		fade_text(self.entities.intro_txt2, 2)

		TLE.Event.Wait(3)
		effect.status = 2
		Flux.to(effect, 15, { dt = 1 })
		Flux.to(self.camera, 5, { scale = 3 })
		Flux.to(self.camera, 5, { x = 356 })
		Flux.to(car_pos, 3, { x = 160 })

		TLE.Event.Wait(2)
		fade_text(self.entities.intro_txt3, 2)

		TLE.Event.Wait(2)
		self.world:emit("slow_parallax", 0.75)
		Flux.to(car_pos, 3, { x = ww/2 })
		fade_text(self.entities.intro_txt4, 2)

		TLE.Event.Wait(2)
		Flux.to(self.camera, 5, { scale = 1 })
		Flux.to(self.camera, 5, { x = ww/2, y = wh/2 })

		-- TLE.Event.Wait(6)
		-- self.world:emit("stop_parallax")
		-- Flux.to(car_pos, 5, { x = ww * 1.5 })
	end)

	!if not _RELEASE then
	-- Dev.init(self.id, self.world)
	-- for k, v in pairs(self.entities) do
	-- 	v:give("debug_slab", k)
	-- end
	!end
end

function StateIntro:update(dt)
	if not self.is_ready then return end

	self.world:emit("parallax_move_x", dt, 1)

	if effect.status == 2 then
		effect.multi:set_dt(effect.dt)
	elseif effect.status == 3 then
		effect.multi2:set_dt(effect.dt2)
	end

	self.world:emit("update", dt)
end

function StateIntro:draw()
	if not self.is_ready then return end

	self.camera:draw(function()
		love.graphics.push()
		love.graphics.scale(self.scale)

		if effect.status == 1 then
			effect.single:apply()
		elseif effect.status == 2 then
			effect.multi:apply()
		elseif effect.status == 3 then
			effect.multi2:apply()
		end

		self.world:emit("draw")
		self.world:emit("draw_z")

		if effect.status == 1 then
			effect.single:unapply()
		elseif effect.status == 2 then
			effect.multi:unapply()
		elseif effect.status == 3 then
			effect.multi2:unapply()
		end

		love.graphics.pop()
	end)

	self.world:emit("draw_ui")
end

function StateIntro:keypressed(key)
	local cs = self.camera:getScale()
	local cx, cy = self.camera:getPosition()
	if key == "-" then
		self.camera:setScale(cs - 0.1)
		print(self.camera:getScale())
	elseif key == "=" then
		self.camera:setScale(cs + 0.1)
		print(self.camera:getScale())
	elseif key == "left" then
		self.camera:setPosition(cx - 32, cy)
		print(self.camera:getPosition())
	elseif key == "right" then
		self.camera:setPosition(cx + 32, cy)
		print(self.camera:getPosition())
	elseif key == "up" then
		self.camera:setPosition(cx, cy - 32)
		print(self.camera:getPosition())
	elseif key == "down" then
		self.camera:setPosition(cx, cy + 32)
		print(self.camera:getPosition())
	end
end

function StateIntro:exit()
	for k, v in pairs(self.entities) do
		self.entities[k] = nil
	end
end

return StateIntro

local Gamera = require("modules.gamera.gamera")
local Concord = require("modules.concord.concord")
local Log = require("modules.log.log")
local NGrading = require("modules.ngrading.ngrading")
local TLE = require("modules.tle.timeline")

local min = math.min
local random = math.random

local Assets = require("data_assets")
local Preloader = require("preloader")

local StateIntro = class()
StateIntro.id = "Intro"

local Components = {}
Concord.utils.loadNamespace("components", Components)
local Systems = {
	Animation = require("systems.animation"),
	Move = require("systems.move"),
	Parallax = require("systems.parallax"),
	RandomTree = require("systems.random_tree"),
	RenderSprite = require("systems.render_sprite"),
	Transform = require("systems.transform"),
}
local Assemblages = {
	Common = require("assemblages.common"),
	Intro = require("assemblages.intro"),
}

local assets = { images = {}, image_data = {}, fonts = {} }
local effect

function StateIntro:new()
	return self:init({
		is_ready = false,
		world = Concord.world(),
		entities = {},
		camera = nil,
	})
end

function StateIntro:load()
	Log.info("State Load: ", self.id)
	local assets_data = Assets:getData("intro")
	Preloader.start(assets_data, assets,
		function()
			self.is_ready = true
			self:start()
		end)
end

function StateIntro:start()
	self.world:addSystem(Systems.Transform)
	self.world:addSystem(Systems.Parallax)
	self.world:addSystem(Systems.RandomTree)
	self.world:addSystem(Systems.RenderSprite)
	self.world:addSystem(Systems.Move)
	self.world:addSystem(Systems.Animation)

	local ww, wh = love.graphics.getDimensions()
	local w, h = assets.images.bg:getDimensions()

	self.scale = min(ww/w, wh/h)
	self.camera = Gamera.new(0, 0, ww * 2, wh * 2)
	self.camera:setWindow(0, (wh - h * self.scale)/2, ww, wh)

	self.entities.bg = Concord.entity(self.world)
		:give("sprite", assets.images.bg)
		:give("position", vec2:new(0, 0))

	self.entities.parallax_building = Concord.entity(self.world)
		:assemble(Assemblages.Intro.parallax, assets.images.parallax_buildings, ww * 2, "building")

	self.entities.parallax_road = Concord.entity(self.world)
		:assemble(Assemblages.Intro.parallax, assets.images.parallax_road, ww * 2, "road")

	self.entities.parallax_grass = Concord.entity(self.world)
		:assemble(Assemblages.Intro.parallax, assets.images.parallax_grass, ww * 2, "grass1")

	self.entities.parallax_grass2 = Concord.entity(self.world)
		:assemble(Assemblages.Intro.parallax, assets.images.parallax_grass2, ww * 2, "grass2")

	self.entities.post = Concord.entity(self.world)
		:assemble(Assemblages.Intro.parallax, assets.images.bg_post, ww * 2, "post")

	self.entities.car = Concord.entity(self.world)
		:assemble(Assemblages.Intro.car, assets.images.sheet_car)

	self.entities.car_reflect = Concord.entity(self.world)
		:assemble(Assemblages.Intro.car_reflect, assets.images.sheet_car_reflect, self.entities.car)

	self.entities.bg_tree_data = Concord.entity(self.world)
		:assemble(Assemblages.Intro.bg_tree_data,
			{
				assets.images.bg_tree1,
				assets.images.bg_tree2,
				assets.images.bg_tree3,
			}, w * 2)

	self.entities.fg_tree_data = Concord.entity(self.world)
		:assemble(Assemblages.Intro.fg_tree_data,
			{
				assets.images.fg_tree1,
				assets.images.fg_tree2,
			}, w)

	self.world:emit("generate_tree", self.entities.bg_tree_data)
	self.world:emit("generate_tree", self.entities.fg_tree_data)

	self.timeline = TLE.Do(function()
		--Car enter scene
		TLE.Event.Wait(2)
		self.entities.car:give("move_to_x", 128, 5)
		--TODO do the intro

		--Slow Down
		TLE.Event.Wait(6)
		self.world:emit("slow_parallax", 0.75)
		self.entities.car:give("move_to_x", 160, 0.75)

		--Car exit scene
		TLE.Event.Wait(1)
		self.world:emit("stop_parallax")
		self.entities.car:give("move_to_x", ww * 1.5, 2)

		--Transition
		TLE.Event.Wait(3)
	end)
	effect = NGrading.load(assets.image_data.neutral_lut64, 64)

	!if not _RELEASE then
	Dev.init(self.id, self.world)
	for k, v in pairs(self.entities) do
		v:give("debug_slab", k)
	end
	!end
end

function StateIntro:update(dt)
	if not self.is_ready then return end

	self.world:emit("parallax_move_x", dt, 1)
	self.world:emit("update", dt)
end

function StateIntro:draw()
	if not self.is_ready then return end

	self.camera:draw(function()
		love.graphics.push()
		love.graphics.scale(self.scale)

		effect:apply()

		self.world:emit("draw")
		self.world:emit("draw_z")

		love.graphics.setShader()

		love.graphics.pop()
	end)
end

function StateIntro:exit()
	for k, v in pairs(self.entities) do
		self.entities[k] = nil
	end
end

return StateIntro

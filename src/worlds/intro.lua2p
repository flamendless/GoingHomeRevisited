local Concord = require("modules.concord.concord")
local Gamera = require("modules.gamera.gamera")
local Flux = require("modules.flux.flux")
local Log = require("modules.log.log")
local Lume = require("modules.lume.lume")
local TLE = require("modules.tle.timeline")

local insert = table.insert
local min = math.min
local sub = string.sub

local Assets = require("data_assets")
local Info = require("info")
local Fade = require("fade")
local Keybinds = require("keybinds")
local NGrading = require("ngrading")
local Preloader = require("preloader")
local Settings = require("settings")

local StateIntro = class()
StateIntro.id = "Intro"

local Components = {}
Concord.utils.loadNamespace("components", Components)
local Systems = {
	Animation = require("systems.animation"),
	Color = require("systems.color"),
	Parallax = require("systems.parallax"),
	RainIntro = require("systems.rain_intro"),
	RandomTree = require("systems.random_tree"),
	RenderSprite = require("systems.render_sprite"),
	RenderText = require("systems.render_text"),
	Transform = require("systems.transform"),
}
local Assemblages = {
	Common = require("assemblages.common"),
	Intro = require("assemblages.intro"),
}

local assets = { images = {}, image_data = {}, fonts = {} }
local effect = { dt = 0, dt2 = 0, status = 1 }
local current_effect

local paint_data

local current_dialogue = 1
local e_dialogues = {}
local dialogues = {
	"Hey, latest reports came in a few minutes ago.",
	"Apparently another case occured.",
	"This one's more disturbing.",
	"Anyways, I know you are on the road.",
	"I'll send the files over as soon as them",
	"investigators are done in the crime scene.",
	"I know you're on the road so umm,",
	"make sure to check it when you got home okay?",
	"Man! Things keep getting worse and wor--"
}

local generate_paint = function(e, duration, duration_out)
	local world = e:getWorld()

	local transform = e:get("transform")
	local text = e:get("static_text").text
	local font = e:get("font").font
	local str_w = font:getWidth(text)
	local str_h = font:getHeight(text)
	local offset = 96
	local text_pos = e:get("position").pos
	local pos = vec2:new(text_pos.x + str_w/2, text_pos.y + str_h/2)
	if transform then
		pos.x = text_pos.x
		pos.y = text_pos.y
	end
	local chance = Lume.randomchoice({true, false})
	local sx = chance == true and -1 or 1

	local paint = Concord.entity(world)
		:assemble(Assemblages.Intro.bg_paint, paint_data, pos)
		:give("auto_scale", str_w + offset, str_h + offset, false)
		:give("transform", 0, sx, nil, 0.5, 0.5)
		:give("color", {1, 1, 1, 0})

	local color = paint:get("color")
	Flux.to(color.color, duration, { [4] = 1 })
		:oncomplete(function()
			Flux.to(color.color, duration_out or duration, { [4] = 0 })
				:oncomplete(function()
					paint:destroy()
				end)
				:delay(1)
		end)
end

local fade_text = function(e, duration, timeline)
	local world = e:getWorld()
	generate_paint(e, duration)

	e:remove("hidden")
	local color = e:get("color")
	Flux.to(color.color, duration, { [4] = 1 })
		:oncomplete(function()
			Flux.to(color.color, duration, { [4] = 0 })
				:oncomplete(function()
					timeline:Unpause()
					e:give("hidden")
					e:destroy()
				end)
		end)
end

local duration_in = 3
local duration_out = 2
local show_dialogue
show_dialogue = function(timeline)
	if current_dialogue > #e_dialogues then
		timeline:Unpause()
	else
		local e = e_dialogues[current_dialogue]
		local world = e:getWorld()
		generate_paint(e, duration_in, duration_out)

		e:remove("hidden")
		local color = e:get("color")
		Flux.to(color.color, duration_in, { [4] = 1 })
			:oncomplete(function()
				Flux.to(color.color, duration_out, { [4] = 0 })
					:oncomplete(function()
						e:give("hidden")
						e:destroy()
						current_dialogue = current_dialogue + 1
						show_dialogue(timeline)
					end)
			end)
	end
end

function StateIntro:new()
	return self:init({
		is_ready = false,
		world = Concord.world(),
		entities = {},
		camera = nil,
		gamestate = nil
	})
end

function StateIntro:load()
	Log.info("State Load: ", self.id)
	local assets_data = Assets:getData("intro")
	Preloader.start(assets_data, assets,
		function()
			self.is_ready = true
			self:start()
		end)
end

function StateIntro:start()
	self.world:addSystem(Systems.Color)
	self.world:addSystem(Systems.Transform)
	self.world:addSystem(Systems.Parallax)
	self.world:addSystem(Systems.RainIntro)
	self.world:addSystem(Systems.RandomTree)
	self.world:addSystem(Systems.RenderSprite)
	self.world:addSystem(Systems.RenderText)
	self.world:addSystem(Systems.Animation)

	local ww, wh = love.graphics.getDimensions()
	local w, h = assets.images.bg:getDimensions()

	self.scale = min(ww/w, wh/h)
	-- self.camera = Gamera.new(0, 0, ww * 2, wh * 2)
	-- self.camera:setWindow(0, (wh - h * self.scale)/2, ww, wh)
	self.camera = Gamera.new(0, 0, w, h)
	self.camera:setWindow(0, 0, ww, wh)
	self.camera:setScale(self.scale)

	self.entities.bg = Concord.entity(self.world)
		:give("sprite", assets.images.bg)
		:give("position", vec2:new(0, 0))

	self.entities.parallax_building = Concord.entity(self.world)
		:assemble(Assemblages.Intro.parallax, assets.images.parallax_buildings, ww * 2, "building")

	self.entities.parallax_road = Concord.entity(self.world)
		:assemble(Assemblages.Intro.parallax, assets.images.parallax_road, ww * 2, "road")

	self.entities.parallax_grass = Concord.entity(self.world)
		:assemble(Assemblages.Intro.parallax, assets.images.parallax_grass, ww * 2, "grass1")

	self.entities.parallax_grass2 = Concord.entity(self.world)
		:assemble(Assemblages.Intro.parallax, assets.images.parallax_grass2, ww * 2, "grass2")

	self.entities.parallax_grass_back = Concord.entity(self.world)
		:assemble(Assemblages.Intro.parallax, assets.images.parallax_grass_back, ww * 2, "grass_back")

	self.entities.parallax_grass_front = Concord.entity(self.world)
		:assemble(Assemblages.Intro.parallax, assets.images.parallax_grass_front, ww * 2, "grass_front")

	self.entities.post = Concord.entity(self.world)
		:assemble(Assemblages.Intro.parallax, assets.images.bg_post, ww * 2, "post")

	self.entities.car = Concord.entity(self.world)
		:assemble(Assemblages.Intro.car, assets.images.sheet_car)

	self.entities.car_reflect = Concord.entity(self.world)
		:assemble(Assemblages.Intro.car_reflect, assets.images.sheet_car_reflect, self.entities.car)

	self.entities.bg_tree_data = Concord.entity(self.world)
		:assemble(Assemblages.Intro.bg_tree_data, {assets.images.bg_tree1, assets.images.bg_tree2, assets.images.bg_tree3}, w * 2)

	self.entities.fg_tree_data = Concord.entity(self.world)
		:assemble(Assemblages.Intro.fg_tree_data, {assets.images.fg_tree1, assets.images.fg_tree2}, w)

	self.entities.rain_data = Concord.entity(self.world)
		:give("rain_tilted")
		:give("rain_data", {
			metadata = {
				drop = {
					frames = {"1-3", 1},
					delay = 0.1,
					rows_count = 1,
					columns_count = 3,
				},
				splash = {
					frames = {"1-5", 1},
					delay = 0.1,
					rows_count = 1,
					columns_count = 5,
				}
			},
			drop = {
				assets.images.rain_drop_tilted,
				assets.images.rain_drop_tilted2
			},
			splash = {
				assets.images.rain_splash_tilted,
				assets.images.rain_splash_tilted2
			},
		}, 128)
	paint_data = {
		spritesheet = assets.images.sheet_paint,
		frames = { "1-7", 1, "1-7", 2, "1-7", 3 },
		delay = 0.1,
		rows_count = 3,
		columns_count = 7,
		n_frames = 21
	}

	self.world:emit("generate_tree", self.entities.bg_tree_data)
	self.world:emit("generate_tree", self.entities.fg_tree_data)

	local lut_size
	local lut_afternoon, lut_dusk, lut_night

	if Settings.current.graphics_quality == "Low" then
		lut_size = 16
		lut_afternoon = assets.image_data.lut_afternoon_16
		lut_dusk = assets.image_data.lut_dusk_16
		lut_night = assets.image_data.lut_night_16
	else
		lut_size = 64
		lut_afternoon = assets.image_data.lut_afternoon_64
		lut_dusk = assets.image_data.lut_dusk_64
		lut_night = assets.image_data.lut_night_64
	end

	effect.single = NGrading:new(lut_afternoon, lut_size)
	effect.single:setup_data()
	effect.single2 = NGrading:new(lut_night, lut_size)
	effect.single2:setup_data()
	effect.multi = NGrading:new(lut_afternoon, lut_dusk, lut_size)
	effect.multi:setup_data()
	effect.multi2 = NGrading:new(lut_dusk, lut_night, lut_size)
	effect.multi2:setup_data()
	current_effect = effect.single

	self.entities.intro_txt1 = Concord.entity(self.world)
		:assemble(Assemblages.Intro.ui_text, "flamendless studio presents", assets.fonts.ui, vec2:new(32, 32))

	self.entities.intro_txt2 = Concord.entity(self.world)
		:assemble(Assemblages.Intro.ui_text, "a game by Brandon", assets.fonts.ui, vec2:new(32, 32))

	self.entities.intro_txt3 = Concord.entity(self.world)
		:assemble(Assemblages.Intro.ui_text, "arts by Conrad", assets.fonts.ui, vec2:new(32, 32))

	self.entities.intro_txt4 = Concord.entity(self.world)
		:assemble(Assemblages.Intro.ui_text, "music by ???", assets.fonts.ui, vec2:new(32, 32))

	self.entities.title = Concord.entity(self.world)
		:assemble(Assemblages.Intro.title, assets.images.title, vec2:new(ww/2, wh/2))

	for i, str in ipairs(dialogues) do
		--TODO add voice acting dialogue
		local e = Concord.entity(self.world)
			:assemble(Assemblages.Intro.dialogue_text, str, assets.fonts.dialogue, vec2:new(ww/2, 64))
		insert(e_dialogues, e)
	end

	self.timeline = TLE.Do(function()
		local car_pos = self.entities.car:get("position").pos
		self.camera:setScale(15)
		self.camera:setPosition(53, 544)

		TLE.Event.Wait(2)
		local cx, cy = self.camera:getPosition()
		Flux.to(self.camera, 5, { y = cy - 64 })
		Flux.to(self.camera, 5, { scale = 10 })

		TLE.Event.Wait(2)
		local fade_duration = 4
		fade_text(self.entities.intro_txt1, fade_duration, self.timeline)
		self.timeline:Pause()

		local cx, cy = self.camera:getPosition()
		Flux.to(self.camera, 5, { scale = 5 })
		Flux.to(self.camera, 5, { x = cx + 160, y = cy - 32 })
		Flux.to(car_pos, 5, { x = 128 })

		fade_text(self.entities.intro_txt2, fade_duration, self.timeline)
		self.timeline:Pause()

		local cx, cy = self.camera:getPosition()
		effect.status = 2
		current_effect = effect.multi
		Flux.to(effect, 15, { dt = 1 })
		Flux.to(self.camera, 5, { scale = 3 })
		Flux.to(self.camera, 5, { x = cx + 72, y = cy - 32 })
		Flux.to(car_pos, 3, { x = 160 })

		fade_text(self.entities.intro_txt3, fade_duration, self.timeline)
		self.timeline:Pause()

		fade_text(self.entities.intro_txt4, fade_duration, self.timeline)
		self.timeline:Pause()

		effect.status = 3
		current_effect = effect.multi2
		Flux.to(effect, 25, { dt2 = 1 })
			:oncomplete(function()
				effect.status = 4
				current_effect = effect.single2
			end)

		--TODO play intro radio
		-- TLE.Event.Wait(3)

		TLE.Event.Wait(3)
		show_dialogue(self.timeline)
		self.timeline:Pause()

		TLE.Event.Wait(2)
		self.world:emit("slow_parallax", 0.75)
		Flux.to(car_pos, 3, { x = ww/2 })

		TLE.Event.Wait(2)
		Flux.to(self.camera, 5, { scale = self.scale })
		Flux.to(self.camera, 5, { x = w/2, y = h/2 })

		if self.entities.skip_intro then
			self.entities.skip_intro:give("hidden")
		end

		TLE.Event.Wait(1)
		local color = self.entities.title:get("color")
		self.entities.title:remove("hidden")
		Flux.to(color.color, 4, { [4] = 1 })
			:oncomplete(function()
				Flux.to(color.color, 4, { [4] = 0 })
					:oncomplete(function()
						self.entities.title:give("hidden")
						self.entities.title:destroy()
					end)
				self.timeline:Unpause()
			end)
		self.timeline:Pause()

		TLE.Event.Wait(2)
		self.world:emit("stop_parallax")
		Flux.to(car_pos, 5, { x = ww * 1.5 })

		Fade.fade_out(function()
			Settings.set_intro_done()
			self.gamestate:switch("MainGame")
		end, 2)
	end)

	if Settings.current.intro_done or not !(_RELEASE) then
		self.entities.skip_intro = Concord.entity(self.world)
			:assemble(Assemblages.Common.skip, assets.fonts.ui, vec2:new(ww/2, wh - 8))
	end
end

function StateIntro:update(dt)
	if not self.is_ready then return end

	self.world:emit("emit_rain", 32)
	self.world:emit("parallax_move_x", dt, 1)

	if effect.status == 2 then
		effect.multi:set_dt(effect.dt)
	elseif effect.status == 3 then
		effect.multi2:set_dt(effect.dt2)
	end

	self.world:emit("update", dt)
end

function StateIntro:draw()
	if not self.is_ready then return end

	self.camera:draw(function()

		if current_effect then
			current_effect:apply()
		end

		self.world:emit("draw")
		self.world:emit("draw_z")

		love.graphics.setShader()
	end)

	self.world:emit("draw_ui")
	Fade.draw()
end

function StateIntro:keypressed(key)
	if Settings.current.intro_done or not !(_RELEASE) then
		if Keybinds.pressed_ui("skip", key) then
			Fade.fade_out(function()
				Settings.set_intro_done()
				self.gamestate:switch("MainGame")
			end, 2)
		end
	end
end

function StateIntro:exit()
	Assets.clean(assets)
	for i, e in ipairs(self.world:getEntities()) do
		e:destroy()
	end
	effect.dt = 0
	effect.dt2 = 0
	effect.status = 1
	current_effect = nil
	current_dialogue = 1
	self.timeline:Die()
end

return StateIntro

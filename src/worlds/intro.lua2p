local Gamera = require("modules.gamera.gamera")
local Concord = require("modules.concord.concord")
local Log = require("modules.log.log")
!if not _RELEASE then
local Slab = require("modules.slab")
!end

local min = math.min
local random = math.random

local Assets = require("data_assets")
local Preloader = require("preloader")

local StateIntro = class()
StateIntro.id = "Intro"

local Components = {}
Concord.utils.loadNamespace("components", Components)
local Systems = {
	Animation = require("systems.animation"),
	Parallax = require("systems.parallax"),
	RandomTree = require("systems.random_tree"),
	RenderSprite = require("systems.render_sprite"),
	Transform = require("systems.transform"),
}
!if not _RELEASE then
Systems.BoundingBox = require("systems.bounding_box")
Systems.DebugSlab = require("systems.debug_slab")
!end
local Assemblages = {
	Common = require("assemblages.common")
}

local assets = { images = {}, fonts = {} }

function StateIntro:new()
	return self:init({
		is_ready = false,
		world = Concord.world(),
		entities = {},
	})
end

function StateIntro:load()
	Log.info("State Load: ", self.id)
	local assets_data = Assets:getData("intro")
	Preloader.start(assets_data, assets,
		function()
			self.is_ready = true
			self:start()
		end)
	!if not _RELEASE then
	Slab.Initialize()
	!end
end

function StateIntro:start()
	self.world:addSystem(Systems.Transform)
	self.world:addSystem(Systems.Parallax)
	self.world:addSystem(Systems.RandomTree)
	self.world:addSystem(Systems.RenderSprite)
	self.world:addSystem(Systems.Animation)
	!if not _RELEASE then
	self.world:addSystem(Systems.DebugSlab)
	self.world:addSystem(Systems.BoundingBox)
	!end

	local ww, wh = love.graphics.getDimensions()
	local w, h = assets.images.bg:getDimensions()

	self.scale = min(ww/w, wh/h)
	self.camera = Gamera.new(0, 0, ww * 2, wh * 2)
	self.camera:setWindow(0, 0, ww, wh)

	self.entities.bg = Concord.entity(self.world)
		:give("sprite", assets.images.bg)
		:give("position", vec2:new(0, 0))

	local building_w, building_h = assets.images.parallax_buildings:getDimensions()
	self.entities.parallax_building = Concord.entity(self.world)
		:assemble(Assemblages.Common.parallax_sprite,
			assets.images.parallax_buildings,
			love.graphics.newQuad(0, 0, ww * 2, building_h, building_w, building_h),
			vec2:new(0, 0),
			vec2:new(32, 0))

	local road_w, road_h = assets.images.parallax_road:getDimensions()
	self.entities.parallax_road = Concord.entity(self.world)
		:assemble(Assemblages.Common.parallax_sprite,
			assets.images.parallax_road,
			love.graphics.newQuad(0, 0, ww * 2, road_h, road_w, road_h),
			vec2:new(0, 0),
			vec2:new(128, 0))

	local post_w, post_h = assets.images.bg_post:getDimensions()
	self.entities.post = Concord.entity(self.world)
		:assemble(Assemblages.Common.parallax_sprite,
			assets.images.bg_post,
			love.graphics.newQuad(0, 0, ww * 2, post_h, post_w, post_h),
			vec2:new(0, 0),
			vec2:new(128, 0))
		:give("z_index", 1)

	self.entities.car = Concord.entity(self.world)
		:assemble(Assemblages.Common.animated_sprite,
			{
				spritesheet = assets.images.sheet_car,
				frames = { "1-3", 1, "1-3", 2, "1-3", 3, "1-3", 4 },
				delay = 0.2,
				rows_count = 4,
				columns_count = 3,
				n_frames = 12
			},
			vec2:new(0, 0), false)

	self.entities.car_reflect = Concord.entity(self.world)
		:assemble(Assemblages.Common.animated_sprite,
			{
				spritesheet = assets.images.sheet_car_reflect,
				frames = { "1-3", 1, "1-3", 2, "1-3", 3, "1-3", 4 },
				delay = 0.1,
				rows_count = 4,
				columns_count = 3,
				n_frames = 12
			},
			vec2:new(0, 0), false)
		:give("attach_to", self.entities.car)

	self.entities.bg_tree_data = Concord.entity(self.world)
		:give("tree_data", {
				images = {
					assets.images.bg_tree1,
					assets.images.bg_tree2,
					assets.images.bg_tree3,
				},
				z_index = 2,
				max_width = building_w * 2,
				parallax = vec2:new(-96, 0),
				offset_y = -16
		})

	self.entities.fg_tree_data = Concord.entity(self.world)
		:give("tree_data", {
				images = {
					assets.images.fg_tree1,
					assets.images.fg_tree2,
				},
				z_index = 3,
				max_width = building_w,
				parallax = vec2:new(-160, 0)
		})

	self.world:emit("generate_tree", self.entities.bg_tree_data)
	self.world:emit("generate_tree", self.entities.fg_tree_data)
end

function StateIntro:update(dt)
	if not self.is_ready then return end
	self.world:emit("update", dt)

	if love.keyboard.isDown("a") then
		self.world:emit("parallax_move_x", dt, -1)
	elseif love.keyboard.isDown("d") then
		self.world:emit("parallax_move_x", dt, 1)
	end

	!if not _RELEASE then
	Slab.Update(dt)
	self.world:emit("draw_slab")
	!end
end

function StateIntro:draw()
	if not self.is_ready then return end
	self.camera:draw(function()
		love.graphics.push()
		love.graphics.scale(self.scale)
		self.world:emit("draw")
		self.world:emit("draw_z")
		love.graphics.pop()
	end)

	!if not _RELEASE then
	Slab.Draw()
	self.world:emit("draw_debug", self.scale)
	!end
end

return StateIntro

local Concord = require("modules.concord.concord")
local Enum = require("modules.enum.enum")
local Flux = require("modules.flux.flux")
local Gamera = require("modules.gamera.gamera")
local Log = require("modules.log.log")
local LoveSplash = require("modules.splashes.o-ten-one")
local SDF = require("modules.sdf").mount()
local Slab = require("modules.slab")
local Timer = require("modules.hump.timer")

local max = math.max
local min = math.min
local format = string.format
local lower = string.lower
local upper = string.upper
local gsub = string.gsub
local insert = table.insert

local Assets = require("data_assets")
local Dissolve = require("dissolve")
local Fade = require("fade")
local Image = require("image")
local Info = require("info")
local Keybinds = require("keybinds")
local MotionBlur = require("motion_blur")
local Palette = require("palette")
local Preloader = require("preloader")
local Save = require("save")
local Settings = require("settings")
local WindowMode = require("window_mode")

local StateMenu = class()
StateMenu.id = "Menu"

local Components = {}
Concord.utils.loadNamespace("components", Components)
local Systems = {
	Animation = require("systems.animation"),
	BoundingBox = require("systems.bounding_box"),
	Click = require("systems.click"),
	Color = require("systems.color"),
	HoverEffect = require("systems.hover_effect"),
	Menu = require("systems.menu"),
	Move = require("systems.move"),
	RenderText = require("systems.render_text"),
	RenderSprite = require("systems.render_sprite"),
	Transform = require("systems.transform"),
}
local Assemblages = {
	Common = require("assemblages.common")
}

local assets = { images = {}, sources = {}, fonts = {} }

local states = Enum("menu", "play", "settings", "about", "exit")
local current_state = states.menu
local options = { "Play", "Settings", "About", "Exit" }
local options_sub = { "Continue", "New Game" }
local is_sub_menu = false
local is_transition = false
local ent_options = {}
local ent_options_sub = {}

local ANGLE_UP = 90
local ANGLE_DOWN = 270
local ANGLE_LEFT = 180
local ANGLE_RIGHT = 0

local current_gq
local current_wm
local flag_game_sounds
local flag_game_music
local show_message_box_reset = false
local show_message_box_conflict = {}
local list_gq = { "Low", "High" }

local duration_show = 0.75
local duration_hide = 0.75
local duration_pos = 0.75
local tx = 176

local tools = {
	"LÃ¶ve Framework", "Vim", "Trello", "Aseprite", "Audacity",
	"Brave Browser", "Manjaro", "i3-WM",
}

local libs = {
	"Anim8", "Arson", "Batteries", "Bump", "Concord",
	"Crush", "Enum", "Flux", "Gamera", "HTTPS",
	"HUMP", "JSON", "Inspect", "Lily", "Log",
	"Luapreprocessor", "Lume", "NGrading", "SDF", "Semver",
	"Slab", "Splashed", "TimelineEvents",
}

!if not _RELEASE and _ASSERT then
for i, str in ipairs(options) do
	local lstr = lower(str)
	local test = states[lstr]
end
!end

function StateMenu:on_menu()
	self.world:emit("allow_cursor", true)
	self.world:emit("set_to_prev_cursor")
	self.world:emit("set_page", 1)
end

function StateMenu:show_main_menu(duration)
	for i, e in ipairs(ent_options) do
			e
			:remove("hidden")
			:give("target_color", Palette:get_color("white", 1), duration or duration_show)
			:give("lerp_on_complete", function()
				self:on_menu()
				is_transition = false
			end)
			:give("move_to_original", duration or duration_pos)
	end
end

function StateMenu:hide_main_menu(duration)
	for i, e in ipairs(ent_options) do
			e
			:give("target_color", Palette:get_color("white", 0), duration or duration_hide)
			:give("lerp_on_complete", function()
				e:give("hidden")
			end)
			:give("move_by", vec2:new(tx, 0), duration or duration_pos)
	end
end

function StateMenu:show_sub_menu(duration)
	local next_cursor = 0
	if Save:exists() then
		next_cursor = 1
	else
		next_cursor = 2
	end

	for i, e in ipairs(ent_options_sub) do
			e
			:remove("hidden")
			:give("target_color", Palette:get_color("white", 1), duration or duration_show)
			:give("lerp_on_complete", function()
				self.world:emit("allow_cursor", true)
				self.world:emit("set_cursor", next_cursor)
				is_transition = false
			end)
			:give("move_to_original", duration or duration_pos)
			if next_cursor == 2 and i == 1 then
				e:give("option_disabled")
			end
	end
	self.world:emit("set_page", 2)
end

function StateMenu:hide_sub_menu(duration)
	for i, e in ipairs(ent_options_sub) do
			e
			:give("target_color", Palette:get_color("white", 0), duration or duration_hide)
			:give("lerp_on_complete", function()
				e:give("hidden")
			end)
			:give("move_by", vec2:new(tx, 0), duration or duration_pos)
	end
end

function StateMenu:turn_off_lamp()
	local ww = love.graphics.getWidth()
	local wh = love.graphics.getHeight()
	local duration = 2
	local timer = 1.75
	--TODO turn off BGM

	self:hide_sub_menu()
	self.entities.desk:give("hidden")
	self.entities.title
		:give("target_color", Palette:get_color("white", 0), duration)
	self.entities.subtitle
		:give("target_color", Palette:get_color("white", 0), duration)

	self.entities.desk_fast = Concord.entity(self.world)
		:assemble(Assemblages.Common.animated_sprite,
			{
				spritesheet = assets.images.sheet_desk,
				frames = { "1-3", 1, "1-3", 2, "1-1", 3 },
				delay = 0.001,
				rows_count = 3,
				columns_count = 3,
				n_frames = 7
			}, vec2:new(ww/2, wh/2), false)
		:give("transform", 0, 1, 1, 0.5, 0.5)
		:give("auto_scale", ww, wh, true)
		:give("color", {1, 1, 1, 1})

	Timer.after(timer, function()
		--TODO add sudden static sound
		self.entities.desk_fast:give("hidden")
	end)
end

function StateMenu:on_play()
	is_transition = true
	is_sub_menu = true
	self.world:emit("allow_cursor", false)
	self:hide_main_menu()
	self:show_sub_menu()
end

function StateMenu:on_newgame()
	self:turn_off_lamp()
	self.gamestate:switch("Intro")
end

function StateMenu:on_continue()
	--TODO load saved game here
end

function StateMenu:initialize_settings_value()
	current_gq = Settings.current.graphics_quality
	current_wm = WindowMode.list[Settings.current.current_wm]
	flag_game_sounds = Settings.current.game_sounds
	flag_game_music = Settings.current.game_music
end

function StateMenu:on_settings()
	self.world:emit("allow_cursor", false)
	local l, t, w, h = self.camera:getWorld()
	local cworld = { x = l, y = t, w = w, h = h }
	self:initialize_settings_value()
	self:MB_move(cworld.w, nil, ANGLE_RIGHT)
end

function StateMenu:on_about()
	self:setup_about()
	self.world:emit("allow_cursor", false)
	local l, t, w, h = self.camera:getWorld()
	local cworld = { x = l, y = t, w = w, h = h }
	self:MB_move(nil, cworld.h, ANGLE_UP)
end

function StateMenu:on_exit()
	self.world:emit("allow_cursor", false)
	!if _PLATFORM == "desktop" then
		local btn = love.window.showMessageBox("Alert", "Are you sure you want to exit the game?", { "Exit", "Cancel", escapebutton = 2 })
		if btn == 1 then
			self:hide_main_menu()
			self.dissolve_ff.flag_process = true
			self.dissolve_ff.on_complete = function()
				love.event.quit()
			end
		elseif btn == 2 then
			current_state = states.menu
			Log.info("Switched Menu State to: ", current_state)
			self:on_menu()
		end
	!end
end

function StateMenu:setup_menu()
	local ww = love.graphics.getWidth()
	local wh = love.graphics.getHeight()
	local bg_door = assets.images.bg_door
	local bg_hallway = assets.images.bg_hallway
	local title = assets.images.title
	local subtitle = assets.images.subtitle

	local scale = min(ww/bg_door:getWidth(), wh/bg_door:getHeight())
	local scale_hallway = min(ww/bg_hallway:getWidth(), wh/bg_hallway:getHeight())
	local scale_title = min((bg_door:getWidth() * scale)/title:getWidth(), (bg_door:getHeight() * scale)/title:getHeight())
	local scale_subtitle = min((title:getWidth() * scale_title)/subtitle:getWidth(), (title:getHeight() * scale)/subtitle:getHeight())
	scale_subtitle = scale_subtitle * 0.75

	self.entities.bg_door = Concord.entity(self.world)
		:give("position", vec2:new(ww * 1.5, wh/2))
		:give("sprite", bg_door)
		:give("transform", 0, scale, scale, bg_door:getWidth()/2, bg_door:getHeight()/2)

	self.entities.bg_hallway = Concord.entity(self.world)
		:give("position", vec2:new(ww/2, wh * 1.5))
		:give("sprite", bg_hallway)
		:give("transform", 0, scale_hallway, scale_hallway, bg_hallway:getWidth()/2, bg_hallway:getHeight()/2)

	self.entities.desk = Concord.entity(self.world)
		:assemble(Assemblages.Common.animated_sprite,
			{
				spritesheet = assets.images.sheet_desk,
				frames = { "1-3", 1, "1-3", 2, "1-1", 3 },
				durations = { 1, 0.1, 1, 0.1, 0.1, 0.1, 1  },
				rows_count = 3,
				columns_count = 3,
				n_frames = 7
			},
			vec2:new(ww/2, wh/2), false)
		:give("transform", 0, 1, 1, 0.5, 0.5)
		:give("auto_scale", ww, wh, true)
		:give("color", {1, 1, 1, 1})

	self.entities.title = Concord.entity(self.world)
		:give("position", vec2:new(ww * 0.25, wh/2 - 36))
		:give("sprite", title)
		:give("transform", 0, scale_title, scale_title, title:getWidth()/2, title:getHeight()/2)
		:give("color", {1, 1, 1, 0.4})

	self.entities.subtitle = Concord.entity(self.world)
		:give("position", vec2:new(ww * 0.25, wh * 1.5))
		:give("anchor", self.entities.title, "center", "bottom")
		:give("sprite", subtitle)
		:give("color", {1, 1, 1, 0.4})
		:give("transform", 0, scale_subtitle, scale_subtitle, subtitle:getWidth()/2, subtitle:getHeight()/2)

	local sdf_menu = love.graphics.newFontMSDF("assets/fonts/Jamboree.fnt", "assets/fonts/Jamboree.png")
	local font_menu = assets.fonts.menu
	local str_target_h = font_menu:getHeight()
	local str_h = sdf_menu:getHeight()
	local scale = str_target_h/str_h * 0.75
	local offset = 16
	local padding = 2

	for i, str in ipairs(options) do
		local lstr = lower(str)
		local str_w = sdf_menu:getWidth(str) * scale
		local x = self.canvases.bot_canvas.width - str_w - offset
		local y = self.canvases.bot_canvas.y + (i * str_h) + (padding * i) - offset

		local id = "text_" .. lstr
		self.entities[id] = Concord.entity(self.world)
			:assemble(Assemblages.Common.text, vec2:new(x, y), str, sdf_menu, Palette:get_color("white", 1))
			:give("sdf", scale, scale)
			:give("option_key", i, 1)
			:give("on_enter", function()
				current_state = states[lstr]
				Log.info("Switched Menu State to: ", current_state)
				self["on_" .. lstr](self)
			end)
		insert(ent_options, self.entities[id])
	end

	for i, str in ipairs(options_sub) do
		local lstr = lower(str)
		lstr = gsub(lstr, "%s+", "")
		local str_w = sdf_menu:getWidth(str) * scale
		local x = self.canvases.bot_canvas.width - str_w - offset
		local y = self.canvases.bot_canvas.y + (i * str_h) + (padding * i) - offset

		local id = "text_sub_" .. lstr
		self.entities[id] = Concord.entity(self.world)
			:assemble(Assemblages.Common.text, vec2:new(x, y), str, sdf_menu, Palette:get_color("white", 1))
			:give("sdf", scale, scale)
			:give("option_key", i, 2)
			:give("on_enter", function()
				self["on_" .. lstr](self)
			end)
		insert(ent_options_sub, self.entities[id])
	end
end

function StateMenu:setup_settings(dt)
	!if _PLATFORM == "desktop" then
	self:settings_desktop(dt)
	!elseif _PLATFORM == "mobile" then
	!end
end

!if _PLATFORM == "desktop" then
function StateMenu:settings_desktop(dt)
	local x = 64
	local y = 64
	local width = love.graphics.getWidth() - (x * 2)
	local height = love.graphics.getHeight() - (y * 2)
	Slab.Update(dt)
	Slab.BeginWindow("Settings", {
		X = x, Y = y, W = width, H = height,
		AllowMove = false, AllowResize = false, AutoSizeWindow = false, IsOpen = true,
		BgColor = Palette.windows.settings
	})

	self:slab_title("GeneralSettingsTitle", "GENERAL SETTINGS")
	Slab.BeginLayout("GeneralSettingsLayout", { AlignX = "center", AlignY = "top", Columns = 2 })
		Slab.SetLayoutColumn(1)
		Slab.Text("Window Resolution")
		Slab.Text("Graphics Quality")

		if Slab.CheckBox(flag_game_sounds, "Game Sounds") then
			flag_game_sounds = not flag_game_sounds
		end
		if Slab.CheckBox(flag_game_music, "Game Music") then
			flag_game_music = not flag_game_music
		end

		Slab.SetLayoutColumn(2)
		if Slab.BeginComboBox("WindowMode", { Selected = current_wm }) then
			for i, str in ipairs(WindowMode.list) do
				if Slab.TextSelectable(str) then
					current_wm = str
				end
			end
			Slab.EndComboBox()
		end

		if Slab.BeginComboBox("GraphicsQuality", { Selected = current_gq }) then
			for i, str in ipairs(list_gq) do
				if Slab.TextSelectable(str) then
					current_gq = str
				end
			end
			Slab.EndComboBox()
		end

		--TODO add sliders here
		Slab.Text("Volume Game Sounds")
		Slab.Text("Volume Game Music")
	Slab.EndLayout()
	Slab.Separator()

	self:slab_title("KeybindingsTitle", "KEYBINDINGS")
	Slab.BeginLayout("KeybindingsLayout", { AlignX = "center", AlignY = "top", Columns = 3 })
		for key_name, key_table in pairs(Keybinds.ui) do
			local id = "ui_" .. key_name
			Slab.SetLayoutColumn(1)
			Slab.Text(id)
			for i, key_ui in ipairs(key_table) do
				Slab.SetLayoutColumn(i + 1)
				local id2 = id .. "_" .. i
				if Slab.BeginComboBox(id2, { Selected =  key_ui}) then
					for j, new_key_ui in ipairs(Keybinds.key_constants) do
						if Slab.TextSelectable(new_key_ui) then
							local is_conflict, conflict_key_name = Keybinds.check_for_conflicts_ui(key_name, new_key_ui)
							if is_conflict then
								show_message_box_conflict = { true, conflict_key_name }
							end
							key_table[i] = new_key_ui
						end
					end
					Slab.EndComboBox()
				end
			end
			if #key_table == 1 then
				Slab.SetLayoutColumn(3)
				Slab.NewLine()
			end
		end
	Slab.EndLayout()
	Slab.Separator()

	Slab.BeginLayout("GeneralOptionsLayout", { AlignX = "center", AlignY = "bottom", Columns = 1 })
		if Slab.Button("Reset to defaults") then
			show_message_box_reset = true
		end

		if Slab.Button("Apply") then
			Settings.update_graphics_quality(current_gq)
			Settings.update_window_mode(current_wm)
			Settings.set_game_sounds(flag_game_sounds)
			Settings.set_game_music(flag_game_music)
			Settings.update_keybindings()
			Settings.overwrite()
		end

		if Slab.Button("Return to Main Menu") then
			self:keypressed("escape")
		end
	Slab.EndLayout()

	if show_message_box_reset then
		local res = Slab.MessageBox("Alert", "Are you sure you want to reset the settings to default?", { Buttons = { "Confirm", "Cancel" } })
		if res ~= "" then
			table.copy(Keybinds.ui_default, Keybinds.ui)
			Settings.create_new()
			self:initialize_settings_value()
			show_message_box_reset = false
		end
	end

	if show_message_box_conflict[1] then
		local res = Slab.MessageBox("Alert", "There's a conflict with button " .. show_message_box_conflict[2], { Buttons = { "Confirm" } })
		if res ~= "" then
			show_message_box_conflict[1] = false
			show_message_box_conflict[2] = nil
		end
	end

	Slab.EndWindow()
end
!end --PLATFORM == "desktop"

function StateMenu:slab_title(title, text)
	Slab.BeginLayout(title, { AlignX = "center", AlignY = "top", Columns = 1 })
	Slab.SetLayoutColumn(1)
	if text then Slab.Text(text) end
	Slab.EndLayout()
	Slab.Separator()
end

local function generate_about()
	local t = {
		{ upper(!(_GAME_TITLE)), assets.fonts.about_64, 12},
		{ "A Game By:" },
		{ "Brandon Blanker Lim-it @flamendless" },
		{ "Arts By:" },
		{ "Conrad Reyes @wits" },

		{ "@LAYOUT:LEFT" },
		{ "TOOLS USED:" },
	}

	for i = 1, #tools, 2 do
		local a = tools[i]
		local b = tools[i + 1] or ""
		local subt = { format("%s, %s", a, b) }
		insert(t, subt)
	end

	insert(t, { "@LAYOUT:RIGHT" })
	insert(t, { "LIBRARIES USED:" })

	for i = 1, #libs, 3 do
		local a = libs[i]
		local b = libs[i + 1] or ""
		local c = libs[i + 2] or ""
		local subt = { format("%s, %s, %s", a, b, c) }
		insert(t, subt)
	end

	insert(t, { "@LAYOUT:CENTER" })
	insert(t, { "" })
	insert(t, { "SPECIAL THANKS to the people at the LÃ¶ve Discord server:" })
	insert(t, { "" })
	insert(t, { assets.images.twitter, assets.images.website, assets.images.mail })

	return t
end

function StateMenu:setup_about()
	local about = generate_about()
	local about_links = { !(_URL_TWITTER), !(_URL_WEBSITE), !(_URL_MAIL), }

	local l, t, w, h = self.camera:getVisible()
	local font_about = assets.fonts.about_24
	local base_x = w/2
	local base_y = h + 16
	local layout = false
	local layout_base_y = 0
	local largest = 0
	for i, el in ipairs(about) do
		if type(el[1]) == "string" then
			local str = el[1]
			local font = el[2] or font_about
			local space = el[3]
			local str_w = font:getWidth(str)
			local str_h = font:getHeight(str)
			local x = base_x - str_w/2
			local y = base_y
			if space then base_y = base_y + space end
			if str == "@LAYOUT:LEFT" then
				base_x = w * 0.25
				layout_base_y = base_y
				layout = true
			elseif str == "@LAYOUT:RIGHT" then
				base_x = w * 0.75
				layout_base_y = base_y
				layout = true
			elseif str == "@LAYOUT:CENTER" then
				base_x = w/2
				base_y = largest
				layout = false
			else
				if layout then
					y = layout_base_y
					layout_base_y = layout_base_y + str_h
					largest = max(largest, layout_base_y)
				end
				local id = "about_text_" .. i
				self.entities[id] = Concord.entity(self.world)
					:assemble(Assemblages.Common.text, vec2:new(x, y), str, font, Palette.colors.white)
					:give("position", vec2:new(x, y))
					:give("camera")

				if not layout then base_y = base_y + str_h end
			end

		elseif el[1].type and el[1]:type() == "Image" then
			local pad = 32
			local img_h
			for i2, image in ipairs(el) do
				local id = "about_image_" .. (i + i2)
				local image_base_x = base_x - (#el/2 * image:getWidth()) - pad
				local x = image_base_x + (image:getWidth() + pad) * (i2 - 1)
				local y = base_y + image:getHeight()/2 - pad
				img_h = image:getHeight()
				self.entities[id] = Concord.entity(self.world)
					:give("sprite", image)
					:give("position", vec2:new(x, y))
					:give("color", Palette.colors.white)
					:give("camera")
					:give("bounding_box", x, y, image:getWidth(), image:getHeight())
					:give("clickable", 1, function()
						local url = about_links[i2]
						love.system.openURL(url)
					end)
					:give("hoverable")
					:give("hover_change_color", Palette.colors.red, 0.5)

					!if not _RELEASE then
					self.entities[id]:give("bounding_box_color", {1, 0, 0, 0.5})
					!end
			end
			base_y = base_y + img_h + pad
		end
	end
end

function StateMenu:new()
	return self:init({
		camera = nil,
		world = Concord.world(),
		entities = {},
		canvases = {},
		is_ready = false,
		gamestate = nil,
	})
end

function StateMenu:load()
	Log.info("State Load: ", self.id)
	local assets_data = Assets:getData("menu")
	Preloader.start(assets_data, assets,
		function()
			--TODO play BGM
			self.is_ready = true
			self:start()
			Slab.Initialize()
		end)
end

function StateMenu:start()
	local ww = love.graphics.getWidth()
	local wh = love.graphics.getHeight()

	self.camera = Gamera.new(0, 0, ww * 2, wh * 2)
	self.camera:setWindow(0, 0, ww, wh)
	self.canvas_main = self.canvases.main_canvas
	self.mb_main = MotionBlur:new(self.canvas_main)

	local img_ff = Image.resize_image(assets.images.flowfield)
	self.dissolve_ff = Dissolve:new(img_ff, 2)

	self.world:addSystem(Systems.Animation)
	self.world:addSystems(Systems.RenderSprite)
	self.world:addSystems(Systems.RenderText)
	self.world:addSystems(Systems.Menu)
	self.world:addSystems(Systems.Click)
	self.world:addSystems(Systems.Color)
	self.world:addSystems(Systems.BoundingBox)
	self.world:addSystems(Systems.HoverEffect)
	self.world:addSystems(Systems.Transform)
	self.world:addSystems(Systems.Move)
	self:setup_menu()

	self:hide_main_menu(0.1)
	self:hide_sub_menu(0.1)

	Fade.set_color({0, 0, 0, 1})
	Fade.fade_in(function()
		self.world:emit("allow_cursor", true)
		self.world:emit("set_cursor", 1)
		self.entities.subtitle:remove("anchor")
		self:show_main_menu()
	end, 1.5, 0.25)
end

function StateMenu:update(dt)
	if not self.is_ready then return end
	local mx, my = love.mouse.getPosition()
	self.world:emit("update", dt)
	self.world:emit("change_color", mx, my)

	if current_state == states.settings and not self.mb_main.flag_process then
		self:setup_settings(dt)
	elseif current_state == states.exit then
		self.dissolve_ff:update(dt)
	end
end

function StateMenu:draw()
	if not self.is_ready then return end
	love.graphics.setColor(1, 1, 1, 1)

	if current_state == states.menu or
		current_state == states.settings or
		current_state == states.about or
		current_state == states.play then
		self.canvas_main:attach()
		self.camera:draw(function(l, t, w, h)
			self.world:emit("draw")
			if current_state == states.settings and not self.mb_main.flag_process then
				love.graphics.push()
				love.graphics.translate(l, t)
				Slab.Draw()
				love.graphics.pop()
			end
			Fade.draw()
		end)
		self.canvas_main:detach()
		self.mb_main:post_process_draw()
	elseif current_state == states.exit then
		self.dissolve_ff:draw(function()
			self.world:emit("draw")
		end)
	end
end

function StateMenu:canvas_resize(ww, wh, scale)
	self.camera:setWorld(0, 0, ww * 2, wh * 2)
	self.camera:setWindow(0, 0, ww, wh)
	self.world:emit("canvas_resize", ww, wh, scale)
	self.world:emit("menu_set_position")
	local new_l, new_t = self.camera:getVisible()
	self.world:emit("update_position", new_l, new_t)
end

function StateMenu:keypressed(key)
	if not self.is_ready then return end
	local dt = 0
	--TODO add keypress sounds (up = down, enter, disabled, escape)
	if Keybinds.pressed_ui("down", key) then
		dt = 1
	elseif Keybinds.pressed_ui("up", key) then
		dt = -1
	end
	if Keybinds.pressed_ui("interact", key) and not is_transition then
		self.world:emit("enter_option")
	end
	self.world:emit("update_cursor", dt)

	if Keybinds.pressed_ui("back", key) then
		if current_state == states.play and is_sub_menu and not is_transition then
				is_transition = true
				is_sub_menu = false
				self.world:emit("allow_cursor", false)
				self:hide_sub_menu()
				self:show_main_menu()
		elseif current_state ~= states.menu and current_state ~= states.play then
			self:MB_return()
		end
	end

	!if not _RELEASE then
	local scale = self.camera:getScale()
	if key == "i" then
		self.camera:setScale(scale - 0.1)
	elseif key == "p" then
		self.camera:setScale(scale + 0.1)
	end
	!end
end

function StateMenu:mousepressed(mx, my, mb)
	if not self.is_ready then return end
	self.world:emit("mousepressed", mb, mx, my)
end

function StateMenu:MB_move(tx, ty, angle)
	--TODO add motion blur sound
	self.mb_main.flag_process = true
	local l, t, w, h = self.camera:getWorld()
	local cx, cy = self.camera:getPosition()
	local cworld = { x = l, y = t, w = w, h = h }
	local cpos = vec2:new(cx, cy)
	local duration = 1
	local distance = { 1.0 }
	local prev_angle = (angle + 180) % 360

	Flux.to(cpos, duration, { x = tx, y = ty })
	:onstart(function()
		self.mb_main:store_previous(cx, cy, prev_angle)
		self.mb_main:set_angle(angle)
		Flux.to(distance, duration, { [1] = 0.0 })
		:onupdate(function()
			self.mb_main:set_strength(distance[1])
		end)
	end)
	:onupdate(function()
		self.camera:setPosition(cpos.x, cpos.y)
		self.world:emit("on_camera_move", self.camera)
	end)
	:oncomplete(function()
		self.mb_main.flag_process = false
	end)
end

function StateMenu:MB_return()
	--TODO add motion blur sound
	self.mb_main.flag_process = true
	local l, t, w, h = self.camera:getWorld()
	local cx, cy = self.camera:getPosition()
	local cworld = { x = l, y = t, w = w, h = h }
	local cpos = vec2:new(cx, cy)
	local duration = 1
	local distance = { 1.0 }
	local temp_mb = self.mb_main.previous

	Flux.to(cpos, duration, { x = temp_mb.target.x, y = temp_mb.target.y })
	:onstart(function()
		self.mb_main:set_angle(temp_mb.angle)
		Flux.to(distance, duration, { [1] = 0.0 })
		:onupdate(function()
			self.mb_main:set_strength(distance[1])
		end)
	end)
	:onupdate(function()
		self.camera:setPosition(cpos.x, cpos.y)
		self.world:emit("on_camera_move", self.camera)
	end)
	:oncomplete(function()
		current_state = states.menu
		Log.info("Switched Menu State to: ", current_state)
		self.mb_main.flag_process = false
		self:on_menu()
	end)
end

function StateMenu:exit()
	Assets.clean(assets)
	for i, e in ipairs(self.world:getEntities()) do
		self.world:removeEntity(e)
	end
end

return StateMenu

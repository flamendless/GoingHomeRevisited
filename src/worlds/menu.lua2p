local Animation = require("modules.anim8.anim8")
local Concord = require("modules.concord.concord")
local Enum = require("modules.enum.enum")
local Log = require("modules.log.log")
local LoveSplash = require("modules.splashes.o-ten-one")

local lower = string.lower

local Canvas = require("canvas")
local Fade = require("fade")
local Preloader = require("preloader")

local StateMenu = {
	id = "Menu",
	world = Concord.world(),
	entities = {},
	canvases = {},
	is_ready = false,
}

local Components = {}
Concord.utils.loadNamespace("components", Components)
local Systems = {
	Menu = require("systems.menu"),
	MotionBlur = require("systems.motion_blur"),
	RenderText = require("systems.render_text"),
}

local assets_data = {
	image = {
		{ "bg_title", "assets/images/menu/title.png" },
	},
	font = {
		{ "jamboree", "assets/fonts/Jamboree.ttf", 24 },
	}
}
local assets = { images = {}, sources = {}, fonts = {} }

local states = Enum("menu", "play", "settings", "about", "exit")
local current_state = states.menu
local options = { "Play", "Settings", "About", "Exit" }
table.reverse(options)

!if not _RELEASE and _ASSERT then
for i, str in ipairs(options) do
	local lstr = lower(str)
	local test = states[lstr]
end
!end

function StateMenu:on_play()
	self.world:emit("set_shader_process", true)
end

function StateMenu:on_settings()
end

function StateMenu:on_about()
end

function StateMenu:on_exit()
end

function StateMenu:load()
	Log.info("State Load: ", self.id)
	local p = Preloader.start(assets_data, assets)
	p:onComplete(function()
		self.is_ready = true

		self.world:addSystems(Systems.RenderText)
		self.world:addSystems(Systems.MotionBlur)
		self.world:addSystems(Systems.Menu)

		local target_canvas = Canvas:new(self.canvases.bot_canvas)
		target_canvas.flags.draw_bounds = true
		target_canvas.custom_color_bounds = {0, 1, 0, 1}
		self.world:emit("set_target_canvas", target_canvas)

		local font = assets.fonts.jamboree_24
		for i, str in ipairs(options) do
			local padding = 32
			local str_w = font:getWidth(str)
			local str_h = font:getHeight(str)
			local x = self.canvases.bot_canvas.width - str_w - padding
			local y = self.canvases.bot_canvas.height - (i * str_h) - padding
			local lstr = lower(str)

			local id = "text_" .. lstr
			self.entities[id] = Concord.entity(self.world)
				:give("position", vec2:new(x, y))
				:give("text", str, font)
				:give("color", {1, 1, 1, 1})
				:give("option_key", i)
				:give("on_enter", function()
					current_state = states[lstr]
					Log.info("Switched Menu State to: ", current_state)
					self["on_" .. lstr](self)
				end)
				:give("motion_blur")
		end
	end)
end

function StateMenu:update(dt)
	if not self.is_ready then return end
	self.world:emit("update", dt)
	if current_state == states.play then
		love.graphics.setColor(1, 1, 1, 1)
		self.world:emit("shader_send_update", dt)
	end
end

function StateMenu:game_draw(canvas)
	if not self.is_ready then return end
	love.graphics.setColor(1, 1, 1, 1)
	love.graphics.draw(assets.images.bg_title, 0, 0, 0, canvas.scale)
end

function StateMenu:ui_draw(canvas)
	if not self.is_ready then return end
	love.graphics.setColor(1, 1, 1, 1)
	self.world:emit("draw")
end

function StateMenu:draw()
	if not self.is_ready then return end
	love.graphics.setColor(1, 1, 1, 1)
	self.world:emit("post_process_draw")
end

function StateMenu:keypressed(key)
	if not self.is_ready then return end
	local dt = 0
	if key == "s" or key == "down" then
		dt = -1
	elseif key == "w" or key == "up" then
		dt = 1
	elseif key == "e" or key == "return" or key == "space" then
		self.world:emit("enter_option")
	end
	self.world:emit("update_cursor", dt)
end

return StateMenu

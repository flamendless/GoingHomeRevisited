local Animation = require("modules.anim8.anim8")
local Concord = require("modules.concord.concord")
local Enum = require("modules.enum.enum")
local Flux = require("modules.flux.flux")
local Gamera = require("modules.gamera.gamera")
local Log = require("modules.log.log")
local LoveSplash = require("modules.splashes.o-ten-one")
local SDF = require("modules.sdf").mount()
local Slab = require("modules.slab")
local Timer = require("modules.hump.timer")

local cos = math.cos
local floor = math.floor
local max = math.max
local min = math.min
local rad = math.rad
local sin = math.sin
local lower = string.lower
local upper = string.upper

local Canvas = require("canvas")
local Dissolve = require("dissolve")
local Fade = require("fade")
local Image = require("image")
local Info = require("info")
local Keybinds = require("keybinds")
local MotionBlur = require("motion_blur")
local Palette = require("palette")
local Preloader = require("preloader")

local StateMenu = {
	id = "Menu",
	camera = nil,
	world = Concord.world(),
	entities = {},
	canvases = {},
	is_ready = false,
}

local Components = {}
Concord.utils.loadNamespace("components", Components)
local Systems = {
	BoundingBox = require("systems.bounding_box"),
	Click = require("systems.click"),
	HoverEffect = require("systems.hover_effect"),
	Lerp = require("systems.lerp"),
	Menu = require("systems.menu"),
	RenderText = require("systems.render_text"),
	RenderSprite = require("systems.render_sprite"),
	Transform = require("systems.transform"),
}
local Assemblages = {
	Common = require("assemblages.common")
}

local assets_data = {
	image = {
		-- { "bg_title", "assets/images/menu/title.png" },
		{ "bg_title", "assets/images/menu/menu_background.png" },
		{ "title", "assets/images/menu/menu_title.png" },
		{ "subtitle", "assets/images/menu/menu_subtitle.png" },
		{ "twitter", "assets/images/menu/twitter.png" },
		{ "website", "assets/images/menu/website.png" },
		{ "mail", "assets/images/menu/mail.png" },
		{ "flowfield", "assets/textures/perlin.png" },
	},
	font = {
		{ "menu", "assets/fonts/Jamboree.ttf", 24, "default" },
		{ "about", "assets/fonts/DigitalDisco.ttf", 24 },
		{ "about", "assets/fonts/DigitalDisco.ttf", 64 },
	}
}
local assets = { images = {}, sources = {}, fonts = {} }

local states = Enum("menu", "play", "settings", "about", "exit")
local current_state = states.menu
local options = { "Play", "Settings", "About", "Exit" }
table.reverse(options)

local ANGLE_UP = 90
local ANGLE_DOWN = 270
local ANGLE_LEFT = 180
local ANGLE_RIGHT = 0

!if not _RELEASE and _ASSERT then
for i, str in ipairs(options) do
	local lstr = lower(str)
	local test = states[lstr]
end
!end

function StateMenu:on_menu()
	self.world:emit("allow_cursor", true)
end

function StateMenu:on_play()
	self.world:emit("allow_cursor", false)
	local ww, wh = love.graphics.getDimensions()
	--TODO set this to the door's size and position
	local tpos = vec2:new(ww/2, wh/2)
	local tw = 128
	local th = 64

	local target_scale = min(ww/tw, wh/th)
	local cam_scale = self.camera:getScale()
	local x, y = self.camera:getPosition()
	local c = { x = x, y = y, scale = cam_scale }
	local duration = 3

	Flux.to(c, duration, {
		x = tpos.x, y = tpos.y,
		scale = target_scale
	}):onupdate(function()
		self.camera:setPosition(c.x, c.y)
		self.camera:setScale(c.scale)
	end):oncomplete(function()
		self.dissolve_noise.flag_process = true
		self.dissolve_noise.on_complete = function()
			G_state_switch("Intro")
		end
	end)
end

local current_wm
local flag_game_sounds = true
local flag_game_music = true
local show_message_box_kb_reset = false
local show_message_box_conflict = {}
function StateMenu:on_settings()
	self.world:emit("allow_cursor", false)
	current_wm = Info.data.current_mode
	local l, t, w, h = self.camera:getWorld()
	local cworld = { x = l, y = t, w = w, h = h }
	self:MB_move(cworld.w, nil, ANGLE_RIGHT)
end

function StateMenu:on_about()
	self:setup_about()
	self.world:emit("allow_cursor", false)
	local l, t, w, h = self.camera:getWorld()
	local cworld = { x = l, y = t, w = w, h = h }
	self:MB_move(nil, cworld.h, ANGLE_UP)
end

function StateMenu:on_exit()
	self.world:emit("allow_cursor", false)
	!if _PLATFORM == "desktop" then
		local btn = love.window.showMessageBox("Alert", "Are you sure you want to exit the game?", { "Exit", "Cancel", escapebutton = 2 })
		if btn == 1 then
			self.dissolve_ff.flag_process = true
			self.dissolve_ff.on_complete = function()
				Timer.after(1, function()
					love.event.quit()
				end)
			end
		elseif btn == 2 then
			current_state = states.menu
			Log.info("Switched Menu State to: ", current_state)
			self:on_menu()
		end
	!end
end

function StateMenu:setup_menu()
	local ww = love.graphics.getWidth()
	local wh = love.graphics.getHeight()
	local main_bg = assets.images.bg_title
	local title = assets.images.title
	local subtitle = assets.images.subtitle

	local scale = min(ww/main_bg:getWidth(), wh/main_bg:getHeight())
	local scale_title = min((main_bg:getWidth() * scale)/title:getWidth(), (main_bg:getHeight() * scale)/title:getHeight())
	local scale_subtitle = min((title:getWidth() * scale_title)/subtitle:getWidth(), (title:getHeight() * scale)/subtitle:getHeight())
	self.entities.main_bg = Concord.entity(self.world)
		:give("position", vec2:new(ww/2, wh/2))
		:give("sprite", main_bg)
		:give("transform", 0, scale, scale, main_bg:getWidth()/2, main_bg:getHeight()/2)

	self.entities.title = Concord.entity(self.world)
		-- :give("position", vec2:new(ww * 0.25, wh/2 - 36))
		:give("position", vec2:new(ww * 0.25, -wh/2))
		:give("sprite", title)
		:give("transform", 0, scale_title, scale_title, title:getWidth()/2, title:getHeight()/2)

	self.entities.subtitle = Concord.entity(self.world)
		:give("position", vec2:new(ww * 0.25, wh * 1.5))
		:give("anchor", self.entities.title, "center", "bottom")
		:give("sprite", subtitle)
		:give("color", {1, 1, 1, 0})
		:give("transform", 0, scale_subtitle, scale_subtitle, subtitle:getWidth()/2, subtitle:getHeight()/2)

	local sdf_menu = love.graphics.newFontMSDF("assets/fonts/Jamboree.fnt", "assets/fonts/Jamboree.png")
	local font_menu = assets.fonts.menu_default
	local str_target_h = font_menu:getHeight()
	local str_h = sdf_menu:getHeight()
	local scale = str_target_h/str_h * 0.75
	local offset = 16
	local padding = 2

	for i, str in ipairs(options) do
		local lstr = lower(str)
		local str_w = sdf_menu:getWidth(str) * scale
		local x = self.canvases.bot_canvas.width - str_w - offset
		local y = self.canvases.bot_canvas.y + self.canvases.bot_canvas.height - ( i * str_h ) - (padding * i) - offset

		local id = "text_" .. lstr
		self.entities[id] = Concord.entity(self.world)
			:assemble(Assemblages.Common.text, vec2:new(x, y), str, sdf_menu, Palette.colors.white)
			:give("sdf", scale, scale)
			:give("option_key", i)
			:give("on_enter", function()
				current_state = states[lstr]
				Log.info("Switched Menu State to: ", current_state)
				self["on_" .. lstr](self)
			end)
	end
end

function StateMenu:setup_settings(dt)
	!if _PLATFORM == "desktop" then
	self:settings_desktop(dt)
	!elseif _PLATFORM == "mobile" then
	!end
end

!if _PLATFORM == "desktop" then
function StateMenu:settings_desktop(dt)
	local x = 64
	local y = 64
	local width = love.graphics.getWidth() - (x * 2)
	local height = love.graphics.getHeight() - (y * 2)
	Slab.Update(dt)
	Slab.BeginWindow("Settings", { X = x, Y = y, W = width, H = height, AllowMove = false, AllowResize = false, AutoSizeWindow = false, })

	self:slab_title("GeneralSettingsTitle", "GENERAL SETTINGS")
	Slab.BeginLayout("GeneralSettingsLayout", { AlignX = "center", AlignY = "top", Columns = 2 })
		Slab.SetLayoutColumn(1)
		Slab.Text("Window Resolution")
		if Slab.CheckBox(flag_game_sounds, "Game Sounds") then
			flag_game_sounds = not flag_game_sounds
		end
		if Slab.CheckBox(flag_game_music, "Game Music") then
			flag_game_music = not flag_game_music
		end

		Slab.SetLayoutColumn(2)
		if Slab.BeginComboBox("WindowMode", { Selected = current_wm }) then
			for i, str in ipairs(Info.data.supported_modes_str) do
				if Slab.TextSelectable(str) then
					current_wm = str
					G_window_resize(i)
				end
			end
			Slab.EndComboBox()
		end
		--TODO add sliders here
		Slab.Text("Volume Game Sounds")
		Slab.Text("Volume Game Music")
	Slab.EndLayout()
	Slab.Separator()

	self:slab_title("KeybindingsTitle", "KEYBINDINGS")
	Slab.BeginLayout("KeybindingsLayout", { AlignX = "center", AlignY = "top", Columns = 3 })
		for key_name, key_table in pairs(Keybinds.ui) do
			local id = "ui_" .. key_name
			Slab.SetLayoutColumn(1)
			Slab.Text(id)
			for i, key_ui in ipairs(key_table) do
				Slab.SetLayoutColumn(i + 1)
				local id2 = id .. "_" .. i
				if Slab.BeginComboBox(id2, { Selected =  key_ui}) then
					for j, new_key_ui in ipairs(Keybinds.key_constants) do
						if Slab.TextSelectable(new_key_ui) then
							local is_conflict, conflict_key_name = Keybinds.check_for_conflicts_ui(key_name, new_key_ui)
							if is_conflict then
								show_message_box_conflict = { true, conflict_key_name }
							end
							key_table[i] = new_key_ui
						end
					end
					Slab.EndComboBox()
				end
			end
			if #key_table == 1 then
				Slab.SetLayoutColumn(3)
				Slab.NewLine()
			end
		end
		Slab.SetLayoutColumn(2)
		Slab.NewLine()
		if Slab.Button("Reset to defaults") then
			show_message_box_kb_reset = true
		end
	Slab.EndLayout()
	Slab.Separator()

	if show_message_box_kb_reset then
		local res = Slab.MessageBox("Alert", "Are you sure you want to reset the keybindings to default?", { Buttons = { "Confirm", "Cancel" } })
		if res ~= "" then
			table.copy(Keybinds.ui_default, Keybinds.ui)
			show_message_box_kb_reset = false
		end
	end

	if show_message_box_conflict[1] then
		local res = Slab.MessageBox("Alert", "There's a conflict with button " .. show_message_box_conflict[2], { Buttons = { "Confirm" } })
		if res ~= "" then
			show_message_box_conflict[1] = false
			show_message_box_conflict[2] = nil
		end
	end

	Slab.EndWindow()
end
!end --PLATFORM == "desktop"

function StateMenu:slab_title(title, text)
	Slab.BeginLayout(title, { AlignX = "center", AlignY = "top", Columns = 1 })
	Slab.SetLayoutColumn(1)
	if text then Slab.Text(text) end
	Slab.EndLayout()
	Slab.Separator()
end

function StateMenu:setup_about()
	local about = {
		{ upper(!(_GAME_TITLE)), assets.fonts.about_64, 12},
		{ "A Game By:" },
		{ "Brandon Blanker Lim-it @flamendless" },
		{ "" },
		{ "Arts By:" },
		{ "Conrad Reyes @wits" },
		{ assets.images.twitter, assets.images.website, assets.images.mail },
		{ "@LAYOUT:LEFT" },
		{ "TOOLS USED:" },
		{ "Löve framework" },
		{ "Vim, Git, Trello" },
		{ "Aseprite, Laigter" },
		{ "Audacity" },
		{ "Manjaro i3-wm Linux" },
		{ "Brave Browser" },

		{ "@LAYOUT:RIGHT" },
		{ "LIBRARIES USED:" },
		{ "Anim8, Batteries" },
		{ "Concord, Crush" },
		{ "Enum, Flux" },
		{ "Gamera, Hump" },
		{ "Lily, Log" },
		{ "Luapreprocess, Lume" },
		{ "Semver, Splashes" },

		{ "@LAYOUT:CENTER" },
		{ "" },
		{ "SPECIAL THANKS TO:" },
		{ "People at the Löve Discord server" },
	}
	local about_links = { !(_URL_TWITTER), !(_URL_WEBSITE), !(_URL_MAIL), }

	local l, t, w, h = self.camera:getVisible()
	local font_about = assets.fonts.about_24
	local base_x = w/2
	local base_y = h + 16
	local layout = false
	local layout_base_y = 0
	local largest = 0
	for i, el in ipairs(about) do
		if type(el[1]) == "string" then
			local str = el[1]
			local font = el[2] or font_about
			local space = el[3]
			local str_w = font:getWidth(str)
			local str_h = font:getHeight(str)
			local x = base_x - str_w/2
			local y = base_y
			if space then base_y = base_y + space end
			if str == "@LAYOUT:LEFT" then
				base_x = w * 0.25
				layout_base_y = base_y
				layout = true
			elseif str == "@LAYOUT:RIGHT" then
				base_x = w * 0.75
				layout_base_y = base_y
				layout = true
			elseif str == "@LAYOUT:CENTER" then
				base_x = w/2
				base_y = largest
				layout = false
			else
				if layout then
					y = layout_base_y
					layout_base_y = layout_base_y + str_h
					largest = max(largest, layout_base_y)
				end
				local id = "about_text_" .. i
				self.entities[id] = Concord.entity(self.world)
					:assemble(Assemblages.Common.text, vec2:new(x, y), str, font, Palette.colors.white)
					:give("position", vec2:new(x, y))
					:give("camera")

				if not layout then base_y = base_y + str_h end
			end

		elseif el[1].type and el[1]:type() == "Image" then
			local pad = 32
			local img_h
			for i2, image in ipairs(el) do
				local id = "about_image_" .. (i + i2)
				local image_base_x = base_x - (#el/2 * image:getWidth()) - pad
				local x = image_base_x + (image:getWidth() + pad) * (i2 - 1)
				local y = base_y + image:getHeight()/2 - pad
				img_h = image:getHeight()
				self.entities[id] = Concord.entity(self.world)
					:assemble(Assemblages.Common.sprite, image, vec2:new(x, y), Palette.colors.white)
					:give("camera")
					:give("bounding_box", x, y, image:getWidth(), image:getHeight())
					:give("clickable", 1, function()
						local url = about_links[i2]
						love.system.openURL(url)
					end)
					:give("hoverable")
					:give("hover_change_color", Palette.colors.red, 0.5)
			end
			base_y = base_y + img_h + pad
		end
	end
end

function StateMenu:load()
	Log.info("State Load: ", self.id)
	local p = Preloader.start(assets_data, assets)
	p:onComplete(function()
		self.is_ready = true
		local ww = love.graphics.getWidth()
		local wh = love.graphics.getHeight()

		self.camera = Gamera.new(0, 0, ww * 2, wh * 2)
		self.camera:setWindow(0, 0, ww, wh)

		self.canvas_main = self.canvases.main_canvas
		self.mb_main = MotionBlur:new(self.canvas_main)

		local img_ff = Image.resize_image(assets.images.flowfield)
		self.dissolve_ff = Dissolve:new(img_ff, 3)

		local img_noise_low = Image.generate_noise(ww/8, wh/8)
		local img_noise_scaled = Image.resize_image(img_noise_low)
		self.dissolve_noise = Dissolve:new(img_noise_scaled, 3)

		self.world:addSystems(Systems.Lerp)
		self.world:addSystems(Systems.RenderSprite)
		self.world:addSystems(Systems.RenderText)
		self.world:addSystems(Systems.Menu)
		self.world:addSystems(Systems.Click)
		self.world:addSystems(Systems.BoundingBox)
		self.world:addSystems(Systems.HoverEffect)
		self.world:addSystems(Systems.Transform)
		self:setup_menu()

		local ww = love.graphics.getWidth()
		local wh = love.graphics.getHeight()

		!if _RELEASE then
		local duration = 2
		local delay = 0.5
		!else
		local duration = 0.5
		local delay = 0.1
		!end
		self.entities.title
			:give("target_position", vec2:new(ww * 0.25, wh/2 - 32), duration)
			:give("lerp_on_complete", function()
				self.entities.subtitle
					:give("target_color", {1, 1, 1, 1}, duration, delay)
					:give("lerp_on_complete", function()
						for i, str in ipairs(options) do
							local lstr = lower(str)
							local id = "text_" .. lstr
							self.entities[id]:remove("hidden")
						end
						self.world:emit("allow_cursor", true)
					end)
			end)
		-- self:setup_about()

		Slab.Initialize()
	end)
end

function StateMenu:update(dt)
	if not self.is_ready then return end
	local mx, my = love.mouse.getPosition()
	self.world:emit("update", dt)
	self.world:emit("change_color", mx, my)

	if current_state == states.settings and not self.mb_main.flag_process then
		self:setup_settings(dt)
	elseif current_state == states.play then
		self.dissolve_noise:update(dt)
	elseif current_state == states.exit then
		self.dissolve_ff:update(dt)
	end
end

function StateMenu:draw()
	if not self.is_ready then return end
	love.graphics.setColor(1, 1, 1, 1)

	if current_state == states.menu or current_state == states.settings or current_state == states.about then
		self.canvas_main:attach()
		self.camera:draw(function(l, t, w, h)
			self.world:emit("draw")
			if current_state == states.settings and not self.mb_main.flag_process then
				love.graphics.push()
				love.graphics.translate(l, t)
				Slab.Draw()
				love.graphics.pop()
			end
		end)
		self.canvas_main:detach()
		self.mb_main:post_process_draw()
	elseif current_state == states.play then
		self.dissolve_noise:draw(function()
			self.camera:draw(function(l, t, w, h)
				self.world:emit("draw")
			end)
		end)
	elseif current_state == states.exit then
		self.dissolve_ff:draw(function()
			self.world:emit("draw")
		end)
	end
end

function StateMenu:canvas_resize(ww, wh, scale)
	self.camera:setWorld(0, 0, ww * 2, wh * 2)
	self.camera:setWindow(0, 0, ww, wh)
	self.world:emit("canvas_resize", ww, wh, scale)
	self.world:emit("menu_set_position")
	local new_l, new_t = self.camera:getVisible()
	self.world:emit("update_position", new_l, new_t)
end

function StateMenu:keypressed(key)
	if not self.is_ready then return end
	local dt = 0
	if Keybinds.pressed_ui("down", key) then
		dt = -1
	elseif Keybinds.pressed_ui("up", key) then
		dt = 1
	elseif Keybinds.pressed_ui("enter", key) then
		self.world:emit("enter_option")
	end
	self.world:emit("update_cursor", dt)

	if current_state ~= states.menu and current_state ~= states.play and Keybinds.pressed_ui("escape", key) then
		self:MB_return()
	end

	!if not _RELEASE then
	if key == "o" then
		local s = self.camera:getScale()
		self.camera:setScale(s - 0.5)
	elseif key == "p" then
		local s = self.camera:getScale()
		self.camera:setScale(s + 0.5)
	end
	!end
end

function StateMenu:mousepressed(mx, my, mb)
	if not self.is_ready then return end
	self.world:emit("mousepressed", mb, mx, my)
end

function StateMenu:MB_move(tx, ty, angle)
	self.mb_main.flag_process = true
	local l, t, w, h = self.camera:getWorld()
	local cx, cy = self.camera:getPosition()
	local cworld = { x = l, y = t, w = w, h = h }
	local cpos = vec2:new(cx, cy)
	local duration = 1
	local distance = { 1.0 }
	local prev_angle = (angle + 180) % 360

	Flux.to(cpos, duration, { x = tx, y = ty })
	:onstart(function()
		self.mb_main:store_previous(cx, cy, prev_angle)
		self.mb_main:set_angle(angle)
		Flux.to(distance, duration, { [1] = 0.0 })
		:onupdate(function()
			self.mb_main:set_strength(distance[1])
		end)
	end)
	:onupdate(function()
		self.camera:setPosition(cpos.x, cpos.y)
		self.world:emit("on_camera_move", self.camera)
	end)
	:oncomplete(function()
		self.mb_main.flag_process = false
	end)
end

function StateMenu:MB_return()
	self.mb_main.flag_process = true
	local l, t, w, h = self.camera:getWorld()
	local cx, cy = self.camera:getPosition()
	local cworld = { x = l, y = t, w = w, h = h }
	local cpos = vec2:new(cx, cy)
	local duration = 1
	local distance = { 1.0 }
	local temp_mb = self.mb_main.previous

	Flux.to(cpos, duration, { x = temp_mb.target.x, y = temp_mb.target.y })
	:onstart(function()
		self.mb_main:set_angle(temp_mb.angle)
		Flux.to(distance, duration, { [1] = 0.0 })
		:onupdate(function()
			self.mb_main:set_strength(distance[1])
		end)
	end)
	:onupdate(function()
		self.camera:setPosition(cpos.x, cpos.y)
		self.world:emit("on_camera_move", self.camera)
	end)
	:oncomplete(function()
		current_state = states.menu
		Log.info("Switched Menu State to: ", current_state)
		self.mb_main.flag_process = false
		self:on_menu()
	end)
end

return StateMenu

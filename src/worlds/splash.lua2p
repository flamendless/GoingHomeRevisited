local Concord = require("modules.concord.concord")
local Enum = require("modules.enum.enum")
local Flux = require("modules.flux.flux")
local Log = require("modules.log.log")
local LoveSplash = require("modules.splashes.o-ten-one")
local Lume = require("modules.lume.lume")
local Timer = require("modules.hump.timer")

local floor = math.floor
local min = math.min

local Assets = require("data_assets")
local Keybinds = require("keybinds")
local Fade = require("fade")
local Palette = require("palette")
local Preloader = require("preloader")
local Settings = require("settings")

local StateSplash = class()
StateSplash.id = "Splash"

local Components = {}
Concord.utils.loadNamespace("components", Components)
local Systems = {
	Animation = require("systems.animation"),
	Color = require("systems.color"),
	GhostEffect = require("systems.ghost_effect"),
	GlitchEffect = require("systems.glitch_effect"),
	RenderSprite = require("systems.render_sprite"),
	RenderText = require("systems.render_text"),
	Typewriter = require("systems.typewriter"),
}
local Assemblages = {
	Common = require("assemblages.common")
}

local assets = { images = {}, fonts = {} }

local states = Enum("splash_love", "splash_wits", "splash_flam")
local current_state = states.splash_love

local splash_love
local delay_skip = 0.5
local timer_flam_skip, timer_wits_skip, timer_love_skip

local splash_love_skippable = false
local splash_wits_skippable = false
local splash_flam_skippable = false

local color_a = {0.898, 0.48627451, 0.074509804, 1}
local color_b = {0.952941176, 0.952941176, 0.054901961, 1}

local is_switching = false
local switch = function(gamestate)
	if is_switching then return end
	is_switching = true
	Fade.fade_out(function()
		Settings.set_splash_done()
		gamestate:switch("Menu")
	end)
end

function StateSplash:new()
	return self:init({
		is_ready = false,
		world = Concord.world(),
		entities = {},
		gamestate = nil,
	})
end

function StateSplash:load()
	Log.info("State Load: ", self.id)
	local assets_data = Assets:getData("splash")
	Preloader.start(assets_data, assets,
		function()
			self.is_ready = true
			self:start()
		end)

	timer_love_skip = Timer()
	timer_wits_skip = Timer()
	timer_flam_skip = Timer()

	timer_love_skip:after(delay_skip, function()
		splash_love_skippable = true
	end)

	splash_love = LoveSplash()
	splash_love.onDone = function()
		current_state = states.splash_wits
		timer_wits_skip:after(delay_skip, function()
			splash_wits_skippable = true
		end)
	end
end

function StateSplash:start()
	self.world:addSystems(Systems.GhostEffect)
	self.world:addSystems(Systems.GlitchEffect)
	self.world:addSystem(Systems.Typewriter)
	self.world:addSystem(Systems.Animation)
	self.world:addSystem(Systems.Color)
	self.world:addSystem(Systems.RenderSprite)
	self.world:addSystem(Systems.RenderText)

	local ww, wh = love.graphics.getDimensions()
	self.entities.splash_wits = Concord.entity(self.world)
		:assemble(Assemblages.Common.animated_sprite,
			{
				spritesheet = assets.images.sheet_wits,
				frames = { "1-3", 1, "1-3", 2, "1-3", 3, "1-3", 4, },
				delay = 0.15,
				rows_count = 4,
				columns_count = 3,
			},
			vec2:new(ww/2, wh/2)
		):give("color", Palette.colors.white)
		:give("transform", 0, 1, 1, 0.5, 0.5)
		:give("auto_scale", ww, wh, true)
		:give("fade_to_black", 1.5, 1)
		:give("animation_on_complete", function()
			self.world:emit("start_fade")
			Timer.after(2, function()
				current_state = states.splash_flam
				timer_flam_skip:after(delay_skip, function()
					splash_flam_skippable = true
				end)
				self.world:emit("start_colors_lerp")
				self.world:emit("start_typewriter")
			end)
		end, "pauseAtEnd")

	local font = assets.fonts.firefly_256
	self.entities.ghost_effect = Concord.entity(self.world)
		:give("random_text", "flamendless")
		:give("font", font)
		:give("ghost_effect")

	self.entities.glitch_effect = Concord.entity(self.world)
		:give("random_text", {"flamendless", "brandon"})
		:give("font", font)
		:give("glitch_effect")
		:give("glitch_colors", Palette.color_glitches)
		:give("color", color_a)
		:give("lerp_colors", {color_a, color_b})
		:give("position", vec2:new(love.graphics.getWidth()/2, love.graphics.getHeight()/2))
		:give("transform", 0, 1, 1, 0.5, 0.5)

	self.entities.typewriter = Concord.entity(self.world)
		:give("color", Palette.colors.white)
		:give("position", vec2:new(love.graphics.getWidth()/2, love.graphics.getHeight() * 0.3))
		:give("transform", 0, 1, 1, 0.5, 0.5)
		:give("text", "")
		:give("font", assets.fonts.uncle_type_32)
		:give("typewriter", "a game by", 0.4)
		:give("typewriter_on_finish", function()
			switch(self.gamestate)
		end, 2)

	if Settings.current.splash_done then
		self.entities.skip_splash = Concord.entity(self.world)
			:assemble(Assemblages.Common.skip, assets.fonts.ui, vec2:new(ww/2, wh - 8))
	end
end

function StateSplash:update(dt)
	if not self.is_ready then return end
	if current_state == states.splash_love then
		timer_love_skip:update(dt)
		splash_love:update(dt)
	elseif current_state == states.splash_wits then
		self.world:emit("update", dt)
		timer_wits_skip:update(dt)
	elseif current_state == states.splash_flam then
		self.world:emit("update", dt)
		timer_flam_skip:update(dt)
	end
end

function StateSplash:draw()
	if not self.is_ready then return end
	if current_state == states.splash_love then
		splash_love:draw()
	elseif current_state == states.splash_wits then
		self.world:emit("draw")
	elseif current_state == states.splash_flam then
		self.world:emit("draw")
		self.world:emit("effect_draw")
	end
	self.world:emit("draw_ui")
	Fade.draw()
end

function StateSplash:keypressed(key)
	if not self.is_ready then return end
	if Settings.current.splash_done then
		if Keybinds.pressed_ui("skip", key) then
			if splash_love and splash_love_skippable then
				splash_love:skip()
			end
			if current_state == states.splash_wits and splash_wits_skippable then
				self.entities.splash_wits:give("animation_stop", "pauseAtEnd")
				splash_wits_skippable = false
			end
			if current_state == states.splash_flam and splash_flam_skippable then
				switch(self.gamestate)
				splash_flam_skippable = false
			end
		end
	end
end

function StateSplash:exit()
	Assets.clean(assets)
	for i, e in ipairs(self.world:getEntities()) do
		e:destroy()
	end
end

return StateSplash

local Concord = require("modules.concord.concord")
local Gamera = require("modules.gamera.gamera")
local Log = require("modules.log.log")
local TLE = require("modules.tle.timeline")
!if not _RELEASE then
local Slab = require("modules.slab")
!end

local min = math.min
local random = love.math.random
local format = string.format

local Info = require("info")
local NGrading = require("ngrading")
local Resources = require("resources")
local Preloader = require("preloader")
local Settings = require("settings")
local Tracker = require("tracker")

local StateOutside = class()
StateOutside.id = "Outside"

local Components = {}
Concord.utils.loadNamespace("components", Components)

local Systems = {
	Animation = require("systems.animation"),
	Bump3DCollision = require("systems.bump3d_collision"),
	Camera = require("systems.camera"),
	Collision = require("systems.collision"),
	Fireflies = require("systems.fireflies"),
	PlayerController = require("systems.player_controller"),
	Movement = require("systems.movement"),
	RainOutside = require("systems.rain_outside"),
	RenderSprite = require("systems.render_sprite"),
	RenderText = require("systems.render_text"),
}

!if not _RELEASE then
local Systems = Tracker.track(Systems)
!end

local Assemblages = {
	Common = require("assemblages.common"),
	Outside = require("assemblages.outside"),
	Player = require("assemblages.player"),
}

local resources = { images = {}, image_data = {}, fonts = {} }
local rain_state = { current = 0, max_amount = 0 }
local effect

function StateOutside:new()
	return self:init({
		is_ready = false,
		world = Concord.world(),
		entities = {},
		camera = nil,
		gamestate = nil
	})
end

function StateOutside:load()
	Log.info("State Load: ", self.id)
	local resources_data = Resources:getData("outside")
	Preloader.start(resources_data, resources,
		function()
			self.is_ready = true
			self:start()
			!if not _RELEASE then
			Slab.Initialize()
			!end
		end)
end

function StateOutside:start()

	self.world:addSystem(Systems.Animation)
	self.world:addSystem(Systems.Bump3DCollision)
	self.world:addSystem(Systems.Fireflies)
	self.world:addSystem(Systems.PlayerController)
	self.world:addSystem(Systems.RainOutside)
	self.world:addSystem(Systems.RenderSprite)
	self.world:addSystem(Systems.RenderText)
	self.world:addSystem(Systems.Collision)
	self.world:addSystem(Systems.Camera)
	self.world:addSystem(Systems.Movement)

	!if not _RELEASE then
	Tracker.warn_on_ref_count(Systems, 0)
	!end

	local ww, wh = love.graphics.getDimensions()
	local w, h = resources.images.bg:getDimensions()
	self.scale = min(ww/w, wh/h)

	self.camera = Gamera.new(0, 0, w, h)
	self.camera:setWindow(0, 0, ww, wh)
	self.entities.camera = Concord.entity(self.world)
		:give("camera", self.camera, true)
		:give("camera_transform", 0, self.scale)
		:give("camera_clip", w, h, { 0, 0, 0, 1 })

	self.entities.bg = Concord.entity(self.world)
		:assemble(Assemblages.Outside.bg, resources.images.bg)

	self.entities.left_bounds = Concord.entity(self.world)
		:assemble(Assemblages.Outside.left_bounds)

	self.entities.right_bounds = Concord.entity(self.world)
		:assemble(Assemblages.Outside.right_bounds)

	self.entities.left_wall = Concord.entity(self.world)
		:assemble(Assemblages.Outside.left_wall)

	self.entities.right_wall = Concord.entity(self.world)
		:assemble(Assemblages.Outside.right_wall)

	self.entities.wood = Concord.entity(self.world)
		:assemble(Assemblages.Outside.wood)

	self.entities.house = Concord.entity(self.world)
		:assemble(Assemblages.Outside.house)

	self.entities.house_side = Concord.entity(self.world)
		:assemble(Assemblages.Outside.house_side)

	-- self.entities.player = Concord.entity(self.world)
	-- 	:assemble(Assemblages.Player.outside_house,
	-- 		resources.images.sheet_player_idle,
	-- 		resources.images.sheet_player_walk,
	-- 		resources.images.sheet_player_run)
	-- self.world:emit("face_left", self.entities.player)


	self.entities.car = Concord.entity(self.world)
		:assemble(Assemblages.Outside.car, resources.images.car)

	self.entities.fence = Concord.entity(self.world)
		:assemble(Assemblages.Outside.fence, resources.images.fence)

	self.entities.fence_right = Concord.entity(self.world)
		:assemble(Assemblages.Outside.fence_right)

	self.entities.gate = Concord.entity(self.world)
		:assemble(Assemblages.Outside.gate, resources.images.gate)

	local splashes = resources.images.splashes
	local is_compatible = Info.is_texturesize_compatible(splashes:getWidth())

	if not is_compatible then
		splashes = resources.images.splashes_low
		Log.warn("Texture size for splashes use 'low' version")
	end

	self.entities.splashes = Concord.entity(self.world)
		:assemble(Assemblages.Outside.splashes, splashes, is_compatible)

	self.world:emit("generate_fireflies", random(5, 10), resources.images.firefly,
		vec2:new(670, 222), vec2:new(922, 298))
	self.world:emit("generate_fireflies", random(5, 10), resources.images.firefly,
		vec2:new(1030, 230), vec2:new(1136, 286))
	self.world:emit("move_fireflies")

	self.entities.rain_data = Concord.entity(self.world)
		:assemble(Assemblages.Outside.rain, ww, wh,
			resources.images.rain_drop, resources.images.rain_drop2)

	local lut_size, lut_dusk
	if Settings.current.graphics_quality == "Low" then
		lut_size = 16
		lut_dusk = resources.image_data.lut_dusk_16
	else
		lut_size = 64
		lut_dusk = resources.image_data.lut_dusk_64
	end

	effect = NGrading:new(lut_dusk, lut_size)
	effect:setup_data()

	self.timeline = TLE.Do(function()
		rain_state.current = 16
		rain_state.max_amount = 64
		-- self.camera:setScale(3)
	end)
end

function StateOutside:update(dt)
	if not self.is_ready then return end

	self.world:emit("preupdate", dt)
	self.world:emit("update_topdown", dt)
	self.world:emit("update", dt)
	self.world:emit("camera_follow")

	local cx, cy, cw, ch = self.camera:getVisible()
	self.world:emit("emit_rain", rain_state.current, rain_state.max_amount, cx, cw)

	!if not _RELEASE then
	Slab.Update(dt)
	self.world:emit("update_debug", dt)
	if self.draw_debug then
		self.world:emit("draw_slab", dt)
	end
	!end
end

function StateOutside:draw()
	if not self.is_ready then return end

	self.camera:draw(function()
		effect:apply()
		self.world:emit("draw")
		self.world:emit("draw_z")

		!if not _RELEASE then
		if self.draw_debug then
			self.world:emit("draw_debug", self.camera:getScale())
		end
		!end

		love.graphics.setShader()
	end)

	self.world:emit("draw_clip")

	!if not _RELEASE then
	Slab.Draw()
	!end
end

function StateOutside:keypressed(key)
	!if not _RELEASE then
	if key == "`" then
		self.draw_debug = not self.draw_debug
	end
	!end
end

function StateOutside:exit()
	Resources.clean(resources)
	for i, e in ipairs(self.world:getEntities()) do
		e:destroy()
	end
	rain_state.current = 0
	rain_state.max_amount = 0
	effect = nil
end

return StateOutside

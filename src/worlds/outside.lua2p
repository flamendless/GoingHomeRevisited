local Concord = require("modules.concord.concord")
local Flux = require("modules.flux.flux")
local Gamera = require("modules.gamera.gamera")
local Log = require("modules.log.log")
local Timer = require("modules.hump.timer")
local TLE = require("modules.tle.timeline")

!if not _RELEASE then
local Slab = require("modules.slab")
local Tracker = require("tracker")
!end

local EventsList = require("data.events_list")
local EventManager = require("event_manager")
local Info = require("info")
local Inputs = require("inputs")
local NGrading = require("ngrading")
local Resources = require("resources")
local Palette = require("palette")
local Preloader = require("preloader")
local Settings = require("settings")

local floor = math.floor
local min = math.min
local random = love.math.random
local format = string.format
local insert = table.insert

local StateOutside = class()
StateOutside.id = "Outside"

local Components = {}
Concord.utils.loadNamespace("components", Components)

local Systems = {
	Animation = require("systems.animation"),
	Bump3DCollision = require("systems.bump3d_collision"),
	Camera = require("systems.camera"),
	Collision = require("systems.collision"),
	Color = require("systems.color"),
	Fireflies = require("systems.fireflies"),
	PlayerController = require("systems.player_controller"),
	Move = require("systems.move"),
	Movement = require("systems.movement"),
	RainOutside = require("systems.rain_outside"),
	RenderSprite = require("systems.render_sprite"),
	RenderText = require("systems.render_text"),
	TextPaint = require("systems.text_paint"),
	Transform = require("systems.transform"),
	RenderCircle = require("systems.render_circle"),

	!if not _RELEASE then
	Debugging = require("systems.debugging"),
	!end
}

!if not _RELEASE then
local Systems = Tracker.track(Systems)
local world
!end

local Assemblages = {
	Common = require("assemblages.common"),
	Outside = require("assemblages.outside"),
	Player = require("assemblages.player"),
	UI = require("assemblages.ui"),
}

local resources = { images = {}, image_data = {}, fonts = {} }
local rain_state = { current = 0, max_amount = 0 }
local effect
local fireflies_flag = false
local overlay_flag = false
local overlay = { 0, 0, 0, 1 }

local tasks = {
	"Get out of the car",
	"Get inside the house",
}

local tle_log = function(msg)
	local str = format("TLE: %s", msg)
	!if not _RELEASE then
	local e = Concord.entity(world):give("log", str)
	!else
	Log.debug(str)
	!end
end

function StateOutside:new()
	return self:init({
		is_ready = false,
		world = Concord.world(),
		entities = {},
		camera = nil,
		gamestate = nil
	})
end

function StateOutside:load()
	Log.info("State Load: ", self.id)
	local resources_data = Resources.get("outside")
	Preloader.start(resources_data, resources,
		function()
			self.is_ready = true
			self:start()
			!if not _RELEASE then
			Slab.Initialize()
			world = self.world
			!end
		end)
end

function StateOutside:start()
	self.world:addSystem(Systems.Animation)
	self.world:addSystem(Systems.Bump3DCollision)
	self.world:addSystem(Systems.Fireflies)
	self.world:addSystem(Systems.PlayerController)
	self.world:addSystem(Systems.RainOutside)
	self.world:addSystem(Systems.RenderSprite)
	self.world:addSystem(Systems.RenderText)
	self.world:addSystem(Systems.Collision)
	self.world:addSystem(Systems.Color)
	self.world:addSystem(Systems.Camera)
	self.world:addSystem(Systems.Move)
	self.world:addSystem(Systems.Movement)
	self.world:addSystem(Systems.TextPaint)
	self.world:addSystem(Systems.Transform)
	self.world:addSystem(Systems.RenderCircle)

	!if not _RELEASE then
	self.world:addSystem(Systems.Debugging)
	Tracker.warn_on_ref_count(Systems, 0)
	!end

	local res_images = resources.images
	local res_fonts = resources.fonts

	local w, h = res_images.bg_house:getDimensions()
	self.screen_size = vec2:new(love.graphics.getDimensions())
	self.scale = min(self.screen_size.x/w, self.screen_size.y/h)

	self.camera = Gamera.new(0, 0, w, h)
	self.camera:setWindow(0, 0, self.screen_size.x, self.screen_size.y)
	self.entities.camera = Concord.entity(self.world)
		:give("camera", self.camera, true)
		:give("camera_transform", 0, self.scale)
		:give("camera_clip", w, h, { 0, 0, 0, 1 })

	self.entities.bg_sky = Concord.entity(self.world)
		:assemble(Assemblages.Outside.bg_sky, res_images.bg_sky)

	local bg_house = res_images.bg_house
	local bg_house_w, bg_house_h = bg_house:getDimensions()
	local div = 2
	local qw = bg_house_w/div
	local qh = bg_house_h/div

	for i = 1, div * div do
		local id = "bg_house_" .. i
		local x = bg_house_w * ((i - 1) % div)/div
		local y = bg_house_h * floor((i - 1)/div)/div
		local pos = vec2:new(x, y)
		local quad = love.graphics.newQuad(x, y, qw, qh, bg_house_w, bg_house_h)

		self.entities[id] = Concord.entity(self.world)
			:assemble(Assemblages.Outside.bg_house, bg_house, pos, quad)
	end

	self.entities.left_bounds = Concord.entity(self.world)
		:assemble(Assemblages.Outside.left_bounds)

	self.entities.right_bounds = Concord.entity(self.world)
		:assemble(Assemblages.Outside.right_bounds)

	self.entities.left_wall = Concord.entity(self.world)
		:assemble(Assemblages.Outside.left_wall)

	self.entities.right_wall = Concord.entity(self.world)
		:assemble(Assemblages.Outside.right_wall)

	self.entities.wood = Concord.entity(self.world)
		:assemble(Assemblages.Outside.wood)

	self.entities.house = Concord.entity(self.world)
		:assemble(Assemblages.Outside.house)

	self.entities.house_side = Concord.entity(self.world)
		:assemble(Assemblages.Outside.house_side)

	self.entities.car = Concord.entity(self.world)
		:assemble(Assemblages.Outside.car, res_images.car)

	self.entities.fence = Concord.entity(self.world)
		:assemble(Assemblages.Outside.fence, res_images.fence)

	self.entities.fence_right = Concord.entity(self.world)
		:assemble(Assemblages.Outside.fence_right)

	self.entities.gate = Concord.entity(self.world)
		:assemble(Assemblages.Outside.gate, res_images.gate)

	self.entities.splat_data = Concord.entity(self.world)
		:assemble(Assemblages.UI.splat_data, res_images.sheet_splat)

	local font_ui = res_fonts.ui
	local pos_ui = vec2:new(self.screen_size.x/2, self.screen_size.y * 0.9)
	for i, str in ipairs(tasks) do
		local id = "task" .. i
		self.entities[id] = Concord.entity(self.world)
			:assemble(Assemblages.UI.ui_text, str, font_ui, pos_ui:copy())
			:give("transform", 0, 1, 1, 0.5, 0.5)
			:give("text_with_paint")
			:give("task", "flash", Palette.get("task_on_complete"))
	end

	local splashes = res_images.splashes
	local is_compatible = Info.is_texturesize_compatible(splashes:getWidth())
	if not is_compatible then
		splashes = res_images.splashes_low
		Log.warn("Texture size for splashes use 'low' version")
	end

	self.splashes = {}
	for i = 1, 3 do
		local x = (i == 1) and 0 or random(-16, 0)
		local y = (i == 1) and 0 or random(-8, 8)
		local pos = vec2:new(x, y)

		local e = Concord.entity(self.world)
			:assemble(Assemblages.Outside.splashes, splashes, pos, is_compatible)

		insert(self.splashes, e)
	end

	self.entities.rain_data = Concord.entity(self.world)
		:assemble(Assemblages.Outside.rain, self.screen_size.x, self.screen_size.y,
			res_images.rain_drop, res_images.rain_drop2)

	self.world:emit("generate_fireflies",
		random(5, 20), res_images.firefly,
		vec2:new(670, 222), vec2:new(1136, 286))

	local lut_size, lut_dusk
	if Settings.current.graphics_quality == "Low" then
		lut_size = 16
		lut_dusk = resources.image_data.lut_dusk_16
	else
		lut_size = 64
		lut_dusk = resources.image_data.lut_dusk_64
	end
	effect = NGrading:new(lut_dusk, lut_size)

	self.timeline = TLE.Do(function()
		!if not _RELEASE then
		self.timeline:Pause()
		!end

		rain_state.current = 32
		rain_state.max_amount = 64
		fireflies_flag = true
		overlay_flag = true

		tle_log("begin timeline")
		self.camera:setScale(6)
		self.camera:setPosition(262, 61)

		tle_log("start fade in")
		Flux.to(overlay, 4, { [4] = 0 })
			:oncomplete(function()
				overlay_flag = false
				tle_log("end fade in")
			end)

		tle_log("start camera pan and zoom")
		Flux.to(self.camera, 6, { x = 520, y = 193 })
			:delay(2)
			:oncomplete(function()
				self.timeline:Unpause()
			end)
		self.timeline:Pause()

		Flux.to(self.camera, 10, { x = 960, y = 296, scale = 4 })

		tle_log("begin rain fade")
		TLE.Event.Wait(3)
		local dur_fade_rain = 8
		self.world:emit("fade_splashes", dur_fade_rain)
		Flux.to(rain_state, dur_fade_rain, { current = 0, max_amount = 0 })
			:onupdate(function()
				if rain_state.current <= 4 then
					if fireflies_flag then
						self.world:emit("move_fireflies")
						self.world:emit("show_fireflies", 5, function()
								self.world:emit("flicker_fireflies", 3, 5)
							end)
						fireflies_flag = false
						tle_log("fireflies start")
					end
				end
			end)
			:oncomplete(function()
				for i, e in ipairs(self.splashes) do
					e:destroy()
					self.splashes[i] = nil
				end
				tle_log("splashes stopped")

				self.timeline:Unpause()
				self.world:emit("cleanup_rain")
				tle_log("end rain fade")
			end)
		self.timeline:Pause()

		local timer_hold_key = 1
		local dur_fade_task = 2
		local dur_camera_follow = 1.5
		local p_interact_id = "player_interact"
		local key_hold = Inputs.get(p_interact_id)

		tle_log("task: " .. tasks[1])
		self.world:emit("show_text_paint", self.entities.task1, dur_fade_task)

		tle_log("wait for action")
		self.entities.ui_hold_progress = Concord.entity(self.world)
			:assemble(Assemblages.UI.hold_progress,
				vec2:new(self.screen_size.x/2, self.screen_size.y/2), timer_hold_key, 64)

		self.entities.ui_keypress = Concord.entity(self.world)
			:assemble(Assemblages.UI.keypress, true, res_images.sheet_keypress, self.entities.ui_hold_progress)

		self.entities.ui_key = Concord.entity(self.world)
			:assemble(Assemblages.UI.key, key_hold, res_fonts.ui, self.entities.ui_keypress)

		local event1 = EventsList.hold_key(key_hold, p_interact_id, timer_hold_key, self.entities.ui_hold_progress)
		event1.on_complete = function()
			tle_log("action completed")
			self.entities.ui_hold_progress:give("color_fade_out", dur_fade_task)
			self.entities.ui_keypress:give("color_fade_out", dur_fade_task)
			self.entities.ui_key:give("color_fade_out", dur_fade_task)
			self.world:emit("fade_text_paint", self.entities.task1, dur_fade_task,
				function()
					self.entities.ui_hold_progress:destroy()
					self.entities.ui_keypress:destroy()
					self.entities.ui_key:destroy()
					self.timeline:Unpause()
				end)

			self.entities.player = Concord.entity(self.world)
				:assemble(Assemblages.Player.outside_house,
					res_images.sheet_player_idle,
					res_images.sheet_player_walk,
					res_images.sheet_player_run)
			self.world:emit("face_left", self.entities.player)
			self.world:emit("camera_follow", self.entities.player, dur_camera_follow)
			Flux.to(self.camera, 1, { scale = 3 })
			tle_log("player created")
		end

		EventManager.add(event1)
		self.timeline:Pause()

		TLE.Event.Wait(1.5)
		tle_log("task: " .. tasks[2])
		self.world:emit("show_text_paint", self.entities.task2, dur_fade_task)

		self.timeline:Pause()
	end)
end

function StateOutside:update(dt)
	if not self.is_ready then return end

	self.world:emit("preupdate", dt)
	self.world:emit("update_topdown", dt)
	self.world:emit("update", dt)

	local cx, cy, cw, ch = self.camera:getVisible()
	self.world:emit("emit_rain", rain_state.current, rain_state.max_amount, cx - 128, cw + 128)

	!if not _RELEASE then
	Slab.Update(dt)
	self.world:emit("update_debug", dt)
	if self.draw_debug then
		self.world:emit("draw_slab", dt)
	end
	!end
end

function StateOutside:draw()
	if not self.is_ready then return end

	self.camera:draw(function(l, t, w, h)
		effect:apply()
		self.world:emit("draw")
		self.world:emit("draw_z")

		!if not _RELEASE then
		if self.draw_debug then
			self.world:emit("draw_debug", l, t, w, h)
		end
		!end

		love.graphics.setShader()

		if overlay_flag then
			love.graphics.setColor(overlay)
			love.graphics.rectangle("fill", l, t, w, h)
		end
	end)

	self.world:emit("draw_clip")
	self.world:emit("draw_ui")

	!if not _RELEASE then
	Slab.Draw()
	!end
end

function StateOutside:keypressed(key)
	!if not _RELEASE then
	if key == "`" then
		self.draw_debug = not self.draw_debug
	elseif key == "space" then
		self.timeline:Unpause()
	end
	!end
end

function StateOutside:exit()
	Timer.clear()
	Resources.clean(resources)
	for i, e in ipairs(self.world:getEntities()) do
		e:destroy()
	end
	for k, v in pairs(self.entities) do
		v:destroy()
		self.entities[k] = nil
	end
	rain_state.current = 0
	rain_state.max_amount = 0
	effect = nil
	fireflies_flag = false
	overlay_flag = false
end

return StateOutside

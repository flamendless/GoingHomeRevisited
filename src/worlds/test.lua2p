local Concord = require("modules.concord.concord")
local Gamera = require("modules.gamera.gamera")

local Resources = require("resources")
local Preloader = require("preloader")
local Tracker = require("tracker")

local StateTest = class()
StateTest.id = "Test"

local Components = {}
Concord.utils.loadNamespace("components", Components)

local Systems = {
	Animation = require("systems.animation"),
	Bump3DCollision = require("systems.bump3d_collision"),
	Collision = require("systems.collision"),
	Camera = require("systems.camera"),
	PlayerController = require("systems.player_controller"),
	Light = require("systems.light"),
	Movement = require("systems.movement"),
	RenderSprite = require("systems.render_sprite"),
	RenderText = require("systems.render_text"),
}

!if not _RELEASE then
Systems = Tracker.track(Systems)
!end

local Assemblages = {
	Common = require("assemblages.common"),
	Player = require("assemblages.player"),
	Outside = require("assemblages.outside"),
}

local path_lights = "res/lights/"
local resources_data = {
	image = {
		{"bg", "res/test/bg.png"},
		{"sheet_player_idle", "res/images/player/player_idle.png"},
		{"sheet_player_walk", "res/images/player/player_walk.png"},
		{"sheet_player_run", "res/images/player/player_run.png"},
		{"light_round", path_lights .. "round.png"},
		{"light_rectangle", path_lights .. "rectangle.png"},
		{"light_cone", path_lights .. "cone.png"},
	},
}
local resources = {images = {}}
local scale = 1

function StateTest:new()
	return self:init({
		is_ready = false,
		world = Concord.world(),
		entities = {},
		camera = nil,
	})
end

function StateTest:load()
	Preloader.start(resources_data, resources,
		function()
			self.is_ready = true
			self:start()
		end)
end

function StateTest:start()
	self.world:addSystem(Systems.Collision)
	self.world:addSystem(Systems.Animation)
	self.world:addSystem(Systems.Bump3DCollision)
	self.world:addSystem(Systems.PlayerController)
	self.world:addSystem(Systems.Light)
	self.world:addSystem(Systems.Movement)
	self.world:addSystem(Systems.RenderSprite)
	self.world:addSystem(Systems.RenderText)
	self.world:addSystem(Systems.Camera)

	!if not _RELEASE then
	Tracker.error_on_ref_count(Systems, 0)
	!end

	local ww, wh = love.graphics.getDimensions()
	local w, h = ww, wh

	self.camera = Gamera.new(0, 0, ww, wh)
	self.camera:setWindow(0, 0, ww, wh)
	self.entities.camera = Concord.entity(self.world)
		:assemble(Assemblages.Common.camera, self.camera, 1, w, h)

	self.world:emit("create_light_map", w, h)
	local lw, lh = resources.images.light_round:getDimensions()
	local ox, oy = lw/2, lh/2
	self.entities.test_light = Concord.entity(self.world)
		:give("id", "test_light")
		:give("position", vec2:new(w/2, h/2))
		:give("transform", 0, 1, 1, ox, oy)
		:give("color", {0.9, 1, 0})
		:give("light", "round", resources.images.light_round, 1)
		:give("light_type", "normal")

	self.entities.test_light2 = Concord.entity(self.world)
		:give("id", "test_light")
		:give("position", vec2:new(w/3, h/3))
		:give("transform", 0, 1, 1, ox, oy)
		:give("color", {0.8, 0.8, 0.8})
		:give("light", "round", resources.images.light_round, 1)
		:give("light_type", "normal")

	local ground = Concord.entity(self.world)
		:give("position", vec3:new(256, 412, 32))
		:give("collider3d", vec3:new(512, 128, 32))
		:give("bump3d")
		:give("z_index", 0)

	local left_wall = Concord.entity(self.world)
		:give("position", vec3:new(230, 284))
		:give("collider3d", vec3:new(64, 128))
		:give("collider3d", vec3:new(512, 128, 32))
		:give("bump3d", "wall")
		:give("z_index", 0)

	local right_wall = Concord.entity(self.world)
		:give("position", vec3:new(768, 284))
		:give("collider3d", vec3:new(64, 128))
		:give("collider3d", vec3:new(512, 128, 32))
		:give("bump3d")
		:give("z_index", 0)

	local bg = Concord.entity(self.world)
		:give("sprite", resources.images.bg)
		:give("position", vec2:new(0, 0))

	self.player = Concord.entity(self.world)
		:assemble(Assemblages.Player.base, "topdown",
			vec2:new(496, 256),
			{idle = vec2:new(), walk = vec2:new(128, 96), run = vec2:new(180, 148)},
			320,
			{
				sheet_idle = resources.images.sheet_player_idle,
				sheet_walk = resources.images.sheet_player_walk,
				sheet_run = resources.images.sheet_player_run,
			}, {can_move = true})
		:give("z_index", 2)
end

function StateTest:update(dt)
	if not self.is_ready then return end

	self.world:emit("preupdate", dt)
	self.world:emit("update_topdown", dt)
	self.world:emit("update", dt)
	self.world:emit("light_update", dt)
end

function StateTest:custom_draw(canvas)
	if not self.is_ready then return end
	self.camera:draw(function()
		self.world:emit("draw_light_start")
		self.world:emit("draw_light")

		-- canvas:attach()
		-- love.graphics.clear()
		love.graphics.setBlendMode("alpha")
		love.graphics.setColor(1, 1, 1, 1)
		love.graphics.setCanvas(canvas.canvas)

		self.world:emit("draw")
		self.world:emit("draw_z")

		self.world:emit("draw_light_end")
		love.graphics.setCanvas()
		-- love.graphics.draw(canvas.canvas)
		canvas:render()
	end)
end

function StateTest:keypressed(key)
	if not self.is_ready then return end

	self.world:emit("keypressed", key)
end

function StateTest:exit()
	Resources.clean(resources)

	for i, e in ipairs(self.world:getEntities()) do
		e:destroy()
	end

	for k, e in pairs(self.entities) do
		self.entities[k]:destroy()
		self.entities[k] = nil
	end
end

return StateTest

local Concord = require("modules.concord.concord")
local Gamera = require("modules.gamera.gamera")
local Timer = require("modules.hump.timer")

!if not _RELEASE then
local DebugFlags = require("debug_flags")
local Tracker = require("tracker")
!end

local MapData = require("data.map_data")
local Resources = require("resources")
local Preloader = require("preloader")
local ScreenInfo = require("screen_info")

local min = math.min

local StateStorageRoom = class()
StateStorageRoom.id = "StorageRoom"

local Components = {}
Concord.utils.loadNamespace("components", Components)

local Systems = {
	!if not _RELEASE then
	Debugging = require("systems.debugging"),
	!end

	Animation = require("systems.animation"),
	Bump3DCollision = require("systems.bump3d_collision"),
	Camera = require("systems.camera"),
	Map = require("systems.map"),
	Movement = require("systems.movement"),
	PlayerController = require("systems.player_controller"),
	RenderSprite = require("systems.render_sprite"),
	Tilemap = require("systems.tilemap"),
}

!if not _RELEASE then
local Systems = Tracker.track(Systems)
!end

local Assemblages = {
	Common = require("assemblages.common"),
	Player = require("assemblages.player"),
}

local resources = {images = {}, fonts = {}}
local res_images, res_fonts
local screen_size

function StateStorageRoom:spawn_player()
	self.entities.player = Concord.entity(self.world)
		:assemble(Assemblages.Player.test,
			res_images.sheet_player_idle,
			res_images.sheet_player_walk,
			res_images.sheet_player_run)
end

function StateStorageRoom:new()
	return self:init({
		is_ready = false,
		world = Concord.world(),
		entities = {},
		camera = nil,
		gamestate = nil
	})
end

function StateStorageRoom:load()
	local resources_data = Resources.get("storage_room")

	Preloader.start(resources_data, resources,
		function()
			res_images = resources.images
			res_fonts = resources.fonts

			self.is_ready = true
			self:start()
		end)
end

function StateStorageRoom:start()
	self.world:addSystem(Systems.Animation)
	self.world:addSystem(Systems.Bump3DCollision)
	self.world:addSystem(Systems.Camera)
	self.world:addSystem(Systems.RenderSprite)
	self.world:addSystem(Systems.Map)
	self.world:addSystem(Systems.Movement)
	self.world:addSystem(Systems.PlayerController)
	self.world:addSystem(Systems.Tilemap)

	!if not _RELEASE then
	self.world:addSystem(Systems.Debugging)
	Tracker.error_on_ref_count(Systems, 0)
	!end

	-- local w, h = res_images.bg_house:getDimensions()
	-- local w, h = love.graphics.getDimensions()
	local world_size = MapData.get_size("Test")
	local w, h = world_size[1], world_size[2]
	local ww, hh = love.graphics.getDimensions()

	screen_size = vec2:new(ww, hh)
	self.scale = min(screen_size.x/w, screen_size.y/h)

	self.camera = Gamera.new(0, 0, w, h)
	self.camera:setWindow(0, 0, screen_size.x, screen_size.y)
	self.entities.camera = Concord.entity(self.world)
		:assemble(Assemblages.Common.camera, self.camera, self.scale, w, h)

	ScreenInfo.set(w, h, ww, hh, self.scale)

	self.world:emit("set_gamestate", self.gamestate)

	!if not _RELEASE then
	self.world:emit("debug_camera", self.camera)
	!end

	--TEST
	self.entities.test_map = Concord.entity(self.world)
		:give("id", "test_map")
		:give("tilemap", "res/tilemaps/test.lua")

	self:spawn_player()
end

function StateStorageRoom:update(dt)
	if not self.is_ready then return end

	self.world:emit("preupdate", dt)
	self.world:emit("update_topdown", dt)
	self.world:emit("update", dt)

	!if not _RELEASE then
	self.world:emit("debugging_update", dt)
	!end
end

function StateStorageRoom:draw()
	if not self.is_ready then return end

	self.camera:draw(function(l, t, w, h)
		self.world:emit("draw_map")
		self.world:emit("draw")
		self.world:emit("draw_z")

		!if not _RELEASE then
		self.world:emit("debugging_draw", l, t, w, h)
		!end
	end)

	-- self.world:emit("draw_clip")
	self.world:emit("draw_ui")
end

function StateStorageRoom:keypressed(key)
	if not self.is_ready then return end

	self.world:emit("keypressed", key)
end

function StateStorageRoom:exit()
	Timer.clear()
	Resources.clean(resources)

	self.world:emit("cleanup")
	self.world:clear()

	for i, e in ipairs(self.world:getEntities()) do
		e:destroy()
	end

	for k, v in pairs(self.entities) do
		v:destroy()
		self.entities[k] = nil
	end
end

return StateStorageRoom

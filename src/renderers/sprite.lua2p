local Helper = require("helper")

local RendererSprite = {}

!if _DEV then
RendererSprite.debug_batched = {}
!end

local function draw(e, ...)
	local outline = e.outline and e.outline.outliner
	if outline then
		outline:draw(e.outline_val.value, ...)
	else
		!if _GLSL_NORMALS then
		local array_image = e.array_image
		if array_image then
			love.graphics.drawLayer(array_image.image, 1)
		else
			love.graphics.draw(...)
		end
		!else
		love.graphics.draw(...)
		!end
	end
end

function RendererSprite:setup_sprite(e)
	local sprite = e.sprite
	!if _GLSL_NORMALS then
	if sprite.container == "array_images" then
		e:give("array_image")
	end
	!end

	!if _DEV then
	local s_id = sprite.resource_id
	if not self.debug_batched[s_id] then
		self.debug_batched[s_id] = {current = 0, highest = 0}
	end
	!end
end

function RendererSprite:render(e)
	local rot, sx, sy, ox, oy, kx, ky
	local pos = e.pos
	local sprite = e.sprite

	local quad = e.quad
	if quad then
		local quad_transform = e.quad_transform
		if quad_transform then
			rot = quad_transform.rotation
			sx, sy = quad_transform.sx, quad_transform.sy
			ox, oy = quad_transform.ox, quad_transform.oy
			kx, ky = quad_transform.kx, quad_transform.ky
		end
		draw(e, sprite.image, quad.quad, pos.x, pos.y, rot, sx, sy, ox, oy, kx, ky)
	else
		local transform = e.transform
		if transform then
			rot = transform.rotation
			sx, sy = transform.sx, transform.sy
			ox, oy = Helper.get_offset(e)
			kx, ky = transform.kx, transform.ky
		end
		draw(e, sprite.image, pos.x, pos.y, rot, sx, sy, ox, oy, kx, ky)
	end

	!if _DEV then
	local s_id = sprite.resource_id
	local db = self.debug_batched[s_id]
	if db and self.debug_prev_id and self.debug_prev_id == s_id then
		db.current = db.current + 1
	end
	if db and self.debug_prev_id ~= s_id then
		db.highest = math.max(db.highest, db.current)
		db.current = 0
	end
	self.debug_prev_id = s_id
	!end
end

local function sort_z_ex(a, b)
	local a_z = a.z_index
	local b_z = b.z_index
	if a_z.sortable and b_z.sortable then
		local a_pos = a.pos
		local b_pos = b.pos
		return a_pos.y < b_pos.y
	elseif a_z.current and b_z.current then
		return a_z.current < b_z.current
	end

	return a_z.value < b_z.value
end

local function draw(e, ...)
	local outline = e.outline
	local outline_val = e.outline_val
	if outline and outline.outliner then
		outline.outliner:draw(outline_val.value, ...)
	else
		!if _GLSL_NORMALS then
		local array_image = e.array_image
		if array_image then
			love.graphics.drawLayer(array_image.image, 1)
		else
			love.graphics.draw(...)
		end
		!else
		love.graphics.draw(...)
		!end
	end
end

-- function RenderSprite:init(world)
-- 	self.world = world
--
-- 	!if _DEV then
-- 	self.debug_batched = {}
-- 	self.pool_layer.onAdded = function(pool, e)
-- 		self:setup_sprite(e)
-- 	end
-- 	!end
--
-- 	self.pool.onAdded = function(pool, e)
-- 		self:setup_sprite(e)
-- 	end
--
-- 	self.pool_z.onAdded = function(pool, e)
-- 		self:setup_sprite(e)
-- 		self:sort_z()
-- 	end
--
-- 	self.pool_z.onRemoved = function(pool, e)
-- 		self:sort_z()
-- 	end
-- end
--
-- function RenderSprite:sort_z()
-- 	self.pool_z:sort(sort_z_ex)
-- 	for i, e in ipairs(self.pool_z) do
-- 		local z = e.z_index
-- 		z.current = i
-- 	end
-- end
--
-- function RenderSprite:draw_z()
-- 	@@profb("render_sprite_z")
-- 	local temp = love.graphics.getShader()
-- 	for _, e in ipairs(self.pool_z) do
-- 		if e.fog and not e.hidden then
-- 			@@profb("draw_fog")
-- 			self.world:emit("draw_fog", e)
-- 			self:draw_sprite_ex(e)
-- 			self.world:emit("end_draw_fog")
-- 			@@profe("draw_fog")
-- 		elseif e.outline and not e.hidden then
-- 			self:draw_sprite_ex(e)
-- 		else
-- 			love.graphics.setShader(temp)
-- 			self:draw_sprite_ex(e)
-- 		end
-- 	end
-- 	@@profe("render_sprite_z")
-- end

!if _DEV then
local Slab = require("modules.slab")
local prev_id

function RendererSprite:debug_batching()
	for _, v in pairs(self.debug_batched) do
		v.current = 0
		v.highest = 0
	end
end

function RendererSprite:debug_update(dt)
	if not self.debug_show then return end
	self.debug_show = Slab.BeginWindow("renderer_sprite", {
		Title = "RendererSprite",
		IsOpen = self.debug_show
	})
	Slab.Text("Batching")
	Slab.Indent()
	for k, v in pairs(self.debug_batched) do
		if v.current ~= 0 or v.highest ~= 0 then
			local str = string.format("%s: %d/%d", k, v.current + 1, v.highest + 1)
			Slab.Text(str)
		end
	end
	Slab.Unindent()

	if Slab.BeginTree("z_index") then
		for _, e in ipairs(self.pool_z) do
			local s_id = e.sprite.resource_id
			if prev_id and prev_id ~= s_id then
				Slab.Separator()
			end
			local id = e.id.value
			local z = e.z_index
			Slab.Text(z.value)
			Slab.SameLine()
			Slab.Text(id)
			Slab.SameLine()
			Slab.Text(tostring(z.sortable))
			prev_id = s_id
		end
		Slab.EndTree()
	end
	Slab.EndWindow()
end
!end

return RendererSprite

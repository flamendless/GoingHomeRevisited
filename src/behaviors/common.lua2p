local get_dt = love.timer.getDelta
local lm_random = love.math.random

local Enums = require("enums")
local bt_enemy = Enums.bt.enemy

local Common = {}

local function set_tag(e, tag)
	@@assert(e.__isEntity and e.behavior_tree)
	@@assert(type(tag) == "string")
	local bt = e.behavior_tree
	bt.current_node = bt_enemy[tag]
end

local function get_distance(e, other_e)
	@@assert(e.__isEntity and e.behavior_tree)
	@@assert(other_e.__isEntity)
	local co = e.controller_origin.vec2
	local other_co = other_e.controller_origin.vec2
	return co:distance(other_co)
end

function Common.set_node(e, tag)
	@@assert(e.__isEntity and e.behavior_tree)
	@@assert(type(tag) == "string")
	return function()
		set_tag(e, tag)
		return $_BT_SUCCESS
	end
end

function Common.random(tbl)
	@@assert(type(tbl) == "table" and #tbl > 0)
	!if _DEV then
	for _, bt in ipairs(tbl) do @@assert(type(bt) == "function") end
	!end
	local i = lm_random(1, #tbl)
	return tbl[i]
end

function Common.wait_random(e, min, max)
	@@assert(e.__isEntity and e.behavior_tree)
	@@assert(type(min) == "number")
	@@assert(type(max) == "number")
	@@assert(min > 0 and min < max)
	local elapsed = 0
	local r = lm_random(min, max)

	return function()
		elapsed = elapsed + get_dt()
		if elapsed >= r then
			elapsed = 0
			r = lm_random(min, max)
			return $_BT_SUCCESS
		end
		return $_BT_RUNNING
	end
end

function Common.sees_other(world, e)
	@@assert(world.__isWorld)
	@@assert(e.__isEntity and e.behavior_tree)
	@@assert(e.ref_e_key)
	local other_e = world:getEntityByKey(e.ref_e_key.value)
	local distance = get_distance(e, other_e)
	local sees = distance <= e.line_of_sight.value
	return sees and $_BT_SUCCESS or $_BT_FAILURE
end

function Common.chase_other(world, e)
	@@assert(world.__isWorld)
	@@assert(e.__isEntity and e.behavior_tree)
	@@assert(e.ref_e_key)
	set_tag(e, "chase")
	local collide_with = e.collide_with
	return collide_with and $_BT_RUNNING or $_BT_SUCCESS
end

return Common
